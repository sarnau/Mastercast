/*** *	generelle Window-Klasse * *	©1994 Dekotec Info-Sys, Markus Fritze ***/#include "WindowBase.h"#include "DoEvent.h"#include "GlobalLib.h"#include "ZoomCode.h"#include <Sound.h>#include <ToolUtils.h>/*** *	Aus einem WindowPtr den Ptr auf die WindowBase-Klasse ermitteln ***/WindowBase		*WindowBase::Class(WindowPtr theWindow){WindowBase	*wc;	if(!theWindow) return nil;	wc = (WindowBase*)GetWRefCon(theWindow);	ThrowIfNil_(wc);	return wc;}/*** *	Window-Klassenptr des vordersten Fensters (kein Float!) ermitteln ***/WindowBase		*WindowBase::BaseFrontWindow(void){	return Class((WindowPtr)FrontNonFloatingWindowX());}/*** *	Tracking und ReceiveDrop Handler für den Support des Drag & Drop Manager ***/pascal OSErr	WindowBase::MyTrackingHandler(short message, WindowPtr theWindow, void *handlerRefCon, DragReference theDrag){	UNUSED(handlerRefCon);	WindowBase	*wc = WindowBase::Class((WindowPtr)theWindow);	return wc->STracking(message, theDrag);}pascal OSErr	WindowBase::MyReceiveDropHandler(WindowPtr theWindow, void *handlerRefCon, DragReference theDrag){	UNUSED(handlerRefCon);	WindowBase	*wc = WindowBase::Class((WindowPtr)theWindow);	return wc->SReceiveDrop(theDrag);}pascal OSErr	WindowBase::MySendDataProc(FlavorType theFlavor, void *refCon, ItemReference theItem, DragReference theDrag){	WindowBase	*wc = (WindowBase*)refCon;	return wc->SSendData(theFlavor, theItem, theDrag);}/*** *	Activate Handler der WindowExtensions-Library ***/pascal void		WindowBase::WindActivateHandlerProc(WindowRefX theWindow, Boolean activateWindow){WindowBase	*wc = WindowBase::Class((WindowPtr)theWindow);	wc->EventActivate(activateWindow);	// evtl. aktives Menü freischalten, Toolbar updaten	AdjustMenu(activateWindow ? wc : nil);}/*** *	Window erstellen ***/void		WindowBase::Open(short windResourceID, WindowScrapAttributes scrapattr, WindowRefX behind){	ScrapAttr = scrapattr;	ActivHandPtr = NewActivateHandlerProc(WindActivateHandlerProc);	ThrowIfOSErr_(GetNewWindowReference(&WindRef, windResourceID, behind, ActivHandPtr));	SetPort((GrafPtr)WindRef);	SetWindowRefcon(WindRef, (long)this);	if(gDrapAndDrop) {		DragTrackHandPtr = NewDragTrackingHandlerProc(MyTrackingHandler);		DragReceiveHandPtr = NewDragReceiveHandlerProc(MyReceiveDropHandler);		if(ScrapAttr & wcTracking)			ThrowIfOSErr_(InstallTrackingHandler(DragTrackHandPtr, (WindowPtr)WindRef, 0L));		if(ScrapAttr & wcReceiveDrop)			ThrowIfOSErr_(InstallReceiveHandler(DragReceiveHandPtr, (WindowPtr)WindRef, 0L));	}}/*** *	Window erstellen ***/void		WindowBase::Open(const Rect *boundsRect, ConstStr255Param title, Boolean visible,									WindowAttributes attributes, WindowScrapAttributes scrapattr, WindowRefX behind){	ScrapAttr = scrapattr;	ActivHandPtr = NewActivateHandlerProc(WindActivateHandlerProc);	ThrowIfOSErr_(NewWindowReference(&WindRef, boundsRect, title, visible, attributes, behind, (long)this, ActivHandPtr));	SetPort((GrafPtr)WindRef);	if(gDrapAndDrop) {		DragTrackHandPtr = NewDragTrackingHandlerProc(MyTrackingHandler);		DragReceiveHandPtr = NewDragReceiveHandlerProc(MyReceiveDropHandler);		if(ScrapAttr & wcTracking)			ThrowIfOSErr_(InstallTrackingHandler(DragTrackHandPtr, (WindowPtr)WindRef, 0L));		if(ScrapAttr & wcReceiveDrop)			ThrowIfOSErr_(InstallReceiveHandler(DragReceiveHandPtr, (WindowPtr)WindRef, 0L));	}}/*** *	Contructor (Window-Variablen initialisieren) ***/			WindowBase::WindowBase(){	WindRef = nil;	SetPt(&MinSize, 64, 64);			// eine willkürliche minimale Windowgröße	SetPt(&MaxSize, 16383, 16383);		// maximale Windowgröße ("ziemlich" groß)	SetPt(&SnapSize, 1, 1);				// Pixelweise snappen	SetPt(&ToolbarOffset, 0, 0);		// keine Toolbar	SetPt(&SliderOffset, 0, 0);			// keine Slider}/*** *	Window killen ***/			WindowBase::~WindowBase(){	if(gDrapAndDrop) {		if(ScrapAttr & wcTracking)			ThrowIfOSErr_(RemoveTrackingHandler(DragTrackHandPtr, (WindowPtr)WindRef));		if(ScrapAttr & wcReceiveDrop)			ThrowIfOSErr_(RemoveReceiveHandler(DragReceiveHandPtr, (WindowPtr)WindRef));		DisposeRoutineDescriptor(DragTrackHandPtr);		DisposeRoutineDescriptor(DragReceiveHandPtr);	}	DisposeWindowReference(WindRef);	WindRef = nil;	DisposeRoutineDescriptor(ActivHandPtr);	AdjustMenu(WindowBase::BaseFrontWindow());}/*** *	Maus wurde bewegt ***/void		WindowBase::AdjustCursor(Point thePt, RgnHandle *mouseRgn){WindowRefX		theWindow;WindowBase		*wb;	// Get the first visible window in the window list.	theWindow = (WindowRefX)FrontWindow();	// Keep searching until a visible window whose windowKind is not	// kApplicationFloaterKind is found, or the end of the window list is reached.	while((theWindow != nil) && (GetWindowKindX(theWindow) == kApplicationFloaterKind)) {		do {			if(GetWindowVisible(theWindow)) {	// Fenster sichtbar?				if(PtInRgn(thePt, ((WindowPeek)theWindow)->contRgn)) {	// Mauszeiger im Fenster?					wb = Class((WindowPtr)theWindow);					if(wb) {						CopyRgn(((WindowPeek)wb->WindRef)->contRgn, *mouseRgn);	// Maus-Region = ganzes Fenster						wb->MausMoved(thePt, mouseRgn);					}					return;				}			}			theWindow = GetNextWindowX(theWindow);		} while((theWindow != nil) && (GetWindowVisible(theWindow) == false));	}	// ggf. das oberste nicht-Float abtesten	if(theWindow && PtInRgn(thePt, ((WindowPeek)theWindow)->contRgn)) {	// Mauszeiger im Fenster?		wb = Class((WindowPtr)theWindow);		if(wb) {			CopyRgn(((WindowPeek)wb->WindRef)->contRgn, *mouseRgn);	// Maus-Region = ganzes Fenster			wb->MausMoved(thePt, mouseRgn);		}		return;	}	// Maus ist außerhalb aller Fenster	SetEmptyRgn(*mouseRgn);	pfeil();}/*** *	Default-Mauszeiger für die Fenster setzen ***/void		WindowBase::MausMoved(Point where, RgnHandle *mouseRgn){	UNUSED(mouseRgn); UNUSED(where);	pfeil();}/*** *	Window updaten ***/void		WindowBase::EventDraw(void){	SetPort((GrafPtr)WindRef);	BeginUpdate((WindowPtr)WindRef);	if(!EmptyRgn(((WindowPtr)WindRef)->visRgn))		// überhaupt was upzudaten?		Draw();	EndUpdate((WindowPtr)WindRef);}/*** *	Window soll gedraggt werden ***/void		WindowBase::EventDrag(void){	SetPort((GrafPtr)WindRef);	WindowBase	*fw = Class((WindowPtr)FrontNonFloatingWindowX());	if(fw && fw->IsModal() && fw != this)		SysBeep(1);	else		DragReferencedWindow(WindRef, gTheEvent.where, &(**GetGrayRgn()).rgnBBox);	// Verschieben des Fensters (neue Zielkoordinate wird übergeben)	WindowMoved(topLeft((*((WindowPeek)WindRef)->contRgn)->rgnBBox));}/*** *	Windowgröße setzen ***/void		WindowBase::SetSize(short maxw, short maxh){	EraseGrowIcon(WindRef);	// Window so skalieren, daß nur ganze Zellen sichtbar sind!	maxh -= ToolbarOffset.v + SliderOffset.v;	maxw -= ToolbarOffset.h + SliderOffset.h;	maxw = ((maxw + ((SnapSize.h * 2) / 3)) / SnapSize.h) * SnapSize.h;			// wenn 1/3 einer Zelle sichtbar ist => Zelle ganz darstellen	maxh = ((maxh + ((SnapSize.v * 2) / 3)) / SnapSize.v) * SnapSize.v;	SizeWindow((WindowPtr)WindRef, maxw + ToolbarOffset.h + SliderOffset.h, maxh + ToolbarOffset.v + SliderOffset.v, true);		// Windowgröße ändern	Adjust();}/*** *	Windowgröße ermitteln ***/void		WindowBase::GetSize(short *maxw, short *maxh){Rect		*r = &(*((WindowPeek)WindRef)->contRgn)->rgnBBox;	*maxw = r->right - r->left;	*maxh = r->bottom - r->top;}/*** *	Window soll vergrößert/verkleinert werden ***/void		WindowBase::EventGrow(void){long		newSize;Rect		size;	SetPort((GrafPtr)WindRef);	topLeft(size) = MinSize;	botRight(size) = MaxSize;	if((newSize = GrowWindow((WindowPtr)WindRef, gTheEvent.where, &size)) != 0L)	// Größe verändert?		SetSize(LoWord(newSize), HiWord(newSize));}/*** *	Klick ins Window, ggf. Mehrfachklick ***/void		WindowBase::EventKlick(Point p, short clicks){	WindowBase	*fw = Class((WindowPtr)FrontNonFloatingWindowX());	if(fw && fw->IsModal() && fw != this)		SysBeep(1);	else {		if(fw != this && (WindRef != FrontNonFloatingWindowX() && WindRef != (WindowRefX)FrontWindow()))			SelectReferencedWindow(WindRef);		else {			SetPort((GrafPtr)WindRef);			GlobalToLocal(&p);			Boolean		onItem = false;			Klick(p, clicks, onItem);			if(onItem && gDrapAndDrop && WaitMouseMoved(gTheEvent.where))	// Maus auf einem Objekt und Draggen begonnen?				ThrowIfOSErr_(SStartDrag(&gTheEvent));		}	}}/*** *	Zoom-Funktion ***/void		WindowBase::CalcIdealDocumentSize(Rect *idealContentSize){	SetRect(idealContentSize, 0, 0, MaxSize.h - 1, MaxSize.v - 1);	OffsetRect(idealContentSize, 3, 3);}/*** *	Zoom-Funktion Callback der “ZoomTheWindow” Funktion ***/void		WindowBase::CalcIdealDocumentSizeProc(WindowPtr theWindow, Rect *idealContentSize){WindowBase		*wb = WindowBase::Class(theWindow);	wb->CalcIdealDocumentSize(idealContentSize);}/*** *	Klick in die Zoom-Box ***/void		WindowBase::EventZoom(short partCode){	Rect	saveRect = (*((WindowPeek)WindRef)->strucRgn)->rgnBBox;			// aktuelle Windowgröße merken	ZoomTheWindow((WindowPeek)WindRef, partCode, CalcIdealDocumentSizeProc);// Window zoomen	if(!EqualRect(&saveRect, &(*((WindowPeek)WindRef)->strucRgn)->rgnBBox))	// hat sich die Größe verändert?		Adjust();															// dann Adjust() aufrufen}/*** *	Klick in den Closer ***/void		WindowBase::EventGoAway(void){	delete this;			// Hiermit killen wir uns selbst… (der Destructor macht den Rest)}/*** *	Taste bei getoppten gedrückt, (true, wenn Taste angenommen wurde) ***/Boolean			WindowBase::AllEventKey(long key, short modifiers){WindowRefX		theWindow;WindowBase		*wb;Boolean			done = false;	// Get the first visible window in the window list.	theWindow = (WindowRefX)FrontWindow();	// Keep searching until a visible window whose windowKind is not	// kApplicationFloaterKind is found, or the end of the window list is reached.	while((theWindow != nil) && (GetWindowKindX(theWindow) == kApplicationFloaterKind) && !done) {		do {			// Tastendruck an alle sichtbaren Floats abschicken			if(GetWindowVisible(theWindow)) {				wb = Class((WindowPtr)theWindow);				if(wb)					done = wb->EventKey(key, modifiers);			}			theWindow = GetNextWindowX(theWindow);		} while((theWindow != nil) && (GetWindowVisible(theWindow) == false) && !done);	}	// Tastendruck ggf. noch ans oberste nicht-Float schicken	if(theWindow && !done) {		wb = Class((WindowPtr)theWindow);		if(wb)			done = wb->EventKey(key, modifiers);	}	return done;}/*** *	Idle-Event für Windows ***/void			WindowBase::AllEventIdle(void){WindowRefX		theWindow;	// Get the first visible window in the window list.	theWindow = (WindowRefX)FrontWindow();	while(theWindow) {		if(GetWindowVisible(theWindow)) {			// Tastendruck an alle Floats abschicken			SetPort((GrafPtr)theWindow);			WindowBase *wb = Class((WindowPtr)theWindow);			if(wb)				wb->Idle();		}		theWindow = GetNextWindowX(theWindow);	}}/*** *	Ticks, die WaitNextEvent maximal warten soll ermitteln ***/long			WindowBase::AllGetTicks(void){WindowRefX		theWindow;long			ticks = 60;		// mindestens einmal pro Sekunde melden	// Get the first visible window in the window list.	theWindow = (WindowRefX)::FrontWindow();	while(theWindow) {		if(GetWindowVisible(theWindow)) {			WindowBase *wb = Class((WindowPtr)theWindow);			if(wb) {				long	t = wb->SleepTicks();				if(t < ticks)	// minimale Ticks-Zeit ermitteln					ticks = t;			}		}		theWindow = GetNextWindowX(theWindow);	}	return ticks;}/*** *	Grow-Icon ohne zusätzliche Linien zeichnen ***/void			WindowBase::DrawGrowIcon(WindowRefX theWindow){Rect		iconRect;RgnHandle	oldClip;	::SetPort((WindowPtr)theWindow);	oldClip = NewRgn();	::GetClip(oldClip);	iconRect = ((WindowPtr)theWindow)->portRect;	iconRect.top = iconRect.bottom - (ScrollBar_Size - 1);	iconRect.left = iconRect.right - (ScrollBar_Size - 1);	::ClipRect(&iconRect);	::PenNormal();	::DrawGrowIcon((WindowPtr)theWindow);	::ValidRect(&iconRect);	::SetClip(oldClip);	::DisposeRgn(oldClip);}/*** *	Grow-Icon löschen ***/void			WindowBase::EraseGrowIcon(WindowRefX theWindow){Rect		iconRect;	::SetPort((WindowPtr)theWindow);	iconRect = ((WindowPtr)theWindow)->portRect;	iconRect.top = iconRect.bottom - (ScrollBar_Size - 1);	iconRect.left = iconRect.right - (ScrollBar_Size - 1);	::InvalRect(&iconRect);}