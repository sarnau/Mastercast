// *****************************************************************************////	WindoidDraw.c//// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ//	Copyright © 1991-95 Infinity Systems.  All rights reserved.// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ//	DESCRIPTION://		This file contains the code that the WDEF uses to get the locations//		and sizes of parts, and to draw them.// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ//	WRITTEN BY://		Troy Gaul//		Infinity Systems// *****************************************************************************#include "WindoidDraw.h"	#include <Memory.h>#include "WindoidTypes.h"#include "WindoidUtil.h"// *****************************************************************************////	Routines to get Rects for title bar parts													 //// *****************************************************************************// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ////	GetTitleBarRect//// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑvoid GetTitleBarRect(WindowPeek window, Rect *titleBar) {	*titleBar = (**window->strucRgn).rgnBBox;	if (WindData.isHoriz) {		// Titlebar on top.		titleBar->bottom = titleBar->top + kTitleHeight;		titleBar->right -= 1;		// Shadow compensation.			} else {		// Titlebar on left.		titleBar->right = titleBar->left + kTitleHeight;		titleBar->bottom -= 1; 		// Shadow compensation.	}}// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ////	GetCloseBox//// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑvoid GetCloseBox(WindowPeek window, Rect *theRect) {	GetTitleBarRect(window, theRect);	if (WindData.isHoriz)		InsetRect(theRect, kGadgetMargin, kGadgetInset);	// Titlebar on top.	else		InsetRect(theRect, kGadgetInset, kGadgetMargin);	// Titlebar on left.	theRect->bottom = theRect->top  + kGadgetSize;	theRect->right  = theRect->left + kGadgetSize;}// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ////	GetZoomBox//// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑvoid GetZoomBox(WindowPeek window, Rect *theRect) {	GetTitleBarRect(window, theRect);	if (WindData.isHoriz) {#if !qApple75Design		// Align zoom box with titlebar pattern.		if (IsEven(theRect->right - theRect->left))			OffsetRect(theRect, -1, 0);#endif		InsetRect(theRect, kGadgetMargin, kGadgetInset);	// Titlebar on top.		} else {#if !qApple75Design		// Align zoom box with titlebar pattern.		if (IsEven(theRect->bottom - theRect->top))			OffsetRect(theRect, 0, -1);#endif		InsetRect(theRect, kGadgetInset, kGadgetMargin);	// Titlebar on left.	}		theRect->top  = theRect->bottom - kGadgetSize;	theRect->left = theRect->right  - kGadgetSize;}// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ////	GetGrowBox//// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑvoid GetGrowBox(WindowPeek window, Rect *theRect) {	GetGlobalContentRect(window, theRect);	theRect->left = ++theRect->right  - kScrollBarPixels;	theRect->top  = ++theRect->bottom - kScrollBarPixels;}// *****************************************************************************////	Color Setup routines													 //// *****************************************************************************// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ////	SetWFrameColor//// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑvoidSetWFrameColor(WindowPeek window, Boolean isColor) {	Boolean isActive = WindData.ignoreHilite || window->hilited;	if (isColor) {		if (isActive)			WctbForeColor(window, wFrameColor);		else			AvgWctbForeColor(window, wHiliteColorLight, wHiliteColorDark,							 wInactiveFramePct);							 	} else {		ForeColor(blackColor);	}}// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ////	SetWTitleColor//// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑvoidSetWTitleColor(WindowPeek window, Boolean isColor) {	Boolean isActive = WindData.ignoreHilite || window->hilited;	if (isColor) {		if (isActive)			WctbForeColor(window, wTextColor);		else		// Set the color for inactive titlebar text.			AvgWctbForeColor(window, wHiliteColorLight, wHiliteColorDark,							 wInactiveTextPct);							 	} else {		ForeColor(blackColor);	}}// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ////	SetWTitleBarColors//// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ//		Set the foreground and background for the drawing of the //		titlebar pattern.// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑvoidSetWTitleBarColors(WindowPeek window, Boolean isColor) {	Boolean isActive = WindData.ignoreHilite || window->hilited;	if (isColor) {		if (isActive) {			AvgWctbForeColor(window, wHiliteColorLight, wHiliteColorDark, 							 wTitleBarDarkPct);			AvgWctbBackColor(window, wHiliteColorLight, wHiliteColorDark, 							 wTitleBarLightPct);							 		} else {			WctbForeColor(window, wContentColor);			WctbBackColor(window, wContentColor);		}			} else {		ColorsNormal();	}}// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ////	SetGadgetFrameEraseColors//// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ//		Set the foreground and background for the drawing of the //		titlebar pattern, in inverse so we can erase some of the//		background by using normal drawing routines.// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑvoidSetGadgetFrameEraseColors(WindowPeek window, Boolean isColor) {	if (isColor) {		AvgWctbBackColor(window, wHiliteColorLight, wHiliteColorDark, 						 wTitleBarDarkPct);		AvgWctbForeColor(window, wHiliteColorLight, wHiliteColorDark, 						 wTitleBarLightPct);						 	} else {		ForeColor(whiteColor);		BackColor(blackColor);	}}// *****************************************************************************////	Drawing routines													 //// *****************************************************************************// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ////	DrawTitlebarTinges//// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑstatic voidDrawTitlebarTinges(WindowPeek window, Boolean isColor, const Rect *bounds) {	Rect tempRect = *bounds;	InsetRect(&tempRect, 1, 1);		if (isColor) {		AvgWctbForeColor(window, wTingeLight, wTingeDark, 						 wTitleBarTingeDarkPct);		FrameBottomRightShading(tempRect);		WctbForeColor(window, wTingeLight);		tempRect.right--;		tempRect.bottom--;		FrameTopLeftShading(tempRect);			} else {		ForeColor(whiteColor);		BackColor(blackColor);		FrameRect(&tempRect);	}}// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ////	DrawCloseBox//// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑvoid DrawCloseBox(WindowPeek window, Boolean isColor, const Rect *theRect) {	Rect tempRect;	// Paint the area on the edges out with the background color.	SetGadgetFrameEraseColors(window, isColor);		tempRect = *theRect;	InsetRect(&tempRect, -kTingeInset, -kTingeInset);	FrameRect(&tempRect);	if (isColor) {		WctbForeColor(window, wTingeDark);		BackColor(whiteColor);		FrameTopLeftShading(*theRect);				tempRect = *theRect;		tempRect.top++;		tempRect.left++;		WctbForeColor(window, wTingeLight);		FrameRect(&tempRect);		InsetRect(&tempRect, 1, 1);		WctbForeColor(window, wTingeDark);		FrameBottomRightShading(tempRect);		tempRect.right--;		tempRect.bottom--;		AvgWctbForeColor(window, wTitleBarLight, wTitleBarDark, 						 wCloseBoxColor);		PaintRect(&tempRect);			} else {		ColorsNormal();		FrameBox(theRect);	}}// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ////	DrawZoomBox//// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑvoid DrawZoomBox(WindowPeek window, Boolean isColor, const Rect *theRect) {	Rect tempRect;	DrawCloseBox(window, isColor, theRect);	tempRect = *theRect;	tempRect.bottom -= kGadgetSize / 2;	tempRect.right -= kGadgetSize / 2;		// This should handle gadgets of various sizes elegantly.	if (isColor) {		WctbForeColor(window, wTingeDark);		tempRect.left += 2;		// Inset past the tinge.		tempRect.top += 2;		FrameBottomRightShading(tempRect);			} else {		FrameRect(&tempRect);	}}// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ////	DrawXedBox//// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ//		Draw close or zoom box with an X in it (or inverted in B&W).// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑvoid DrawXedBox(WindowPeek window, Boolean isColor, const Rect *theRect) {	if (isColor) {		AvgWctbForeColor(window, wTingeLight, wTingeDark, wXedBoxPct);		PaintRect(theRect);				WctbForeColor(window, wTitleBarDark);		FrameRect(theRect);		#if !qApple75Design		MoveTo(theRect->left,      theRect->top       );	// Draw the ÔXÕ.		LineTo(theRect->right - 1, theRect->bottom - 1);		MoveTo(theRect->right - 1, theRect->top       );		LineTo(theRect->left,      theRect->bottom - 1);#endif	} else {#if qApple75Design		FrameBox(theRect);#else		PaintRect(theRect);#endif	}	#if qApple75Design	MoveTo(theRect->left  + 2,	theRect->top    + 2);		// Draw the ÔXÕ.	Line(1, 1);	Move(2, 2);	Line(1, 1);	MoveTo(theRect->right - 3,	theRect->top    + 2);	Line(-1, 1);	Move(-2, 2);	Line(-1, 1);#endif}// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ////	DrawGrow3DBox//// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑstatic void DrawGrow3DBox(WindowPeek window, Rect *theRect, Boolean isLight) {	Rect tempRect = *theRect;		WctbForeColor(window, wTingeDark);	FrameRect(theRect);		// Add the top light outer border on the top-left edge.	tempRect.left++;	tempRect.top++;	WctbForeColor(window, wTingeLight);	FrameTopLeftShading(tempRect);	// Finally, fill in the center.#if qApple75Design	AvgWctbForeColor(window, wTitleBarLight, wTitleBarDark, 					 wGrowBoxColorLt);#else	AvgWctbForeColor(window, wTitleBarLight, wTitleBarDark, 					 isLight ? wGrowBoxColorLt : wGrowBoxColorDk);#endif	InsetRect(&tempRect, 1, 1);	PaintRect(&tempRect);#if qApple75Design	if (isLight) {		// Done to mimic the appearance of the 7.5 WDEF.		MoveTo(tempRect.right, tempRect.top - 1);		Line(0,0);		MoveTo(tempRect.left - 1, tempRect.bottom);		Line(0,0);	}#endif}// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ////	DrawGrowBox//// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑvoid DrawGrowBox(WindowPeek window, Boolean isColor) {	Rect theRect;	GetGrowBox(window, &theRect);	if (!(WindData.ignoreHilite || window->hilited)) { 		if (isColor) {			WctbForeColor(window, wFrameColor);			WctbBackColor(window, wContentColor);		}		FrameBox(&theRect);			} else {		Rect smallRect; 		Rect largeRect;			// Add the size box chevrons.#if qApple75Design		SetRect(&smallRect, theRect.left + 3, theRect.top + 3,						    theRect.left + 9, theRect.top + 9);		SetRect(&largeRect, smallRect.left + 3, smallRect.top + 3, 						    theRect.right - 2, theRect.bottom - 2);#elif qSmallGrow		SetRect(&smallRect, theRect.left + 2, theRect.top + 2,						    theRect.left + 7, theRect.top + 7);		SetRect(&largeRect, smallRect.left + 1, smallRect.top + 1, 						    theRect.right - 2, theRect.bottom - 2);#else // normal grow box.		SetRect(&smallRect, theRect.left + 3, theRect.top + 3,						    theRect.left + 10, theRect.top + 10);		SetRect(&largeRect, smallRect.left + 2, smallRect.top + 2, 						    theRect.right - 2, theRect.bottom - 2);#endif		if (isColor) {			WctbForeColor(window, wFrameColor);			AvgWctbBackColor(window, wHiliteColorLight, wHiliteColorDark, 							 wGrowBoxBackground);			FrameBox(&theRect);			// Draw the dark border parts for the bottom rectangle.#if !qSmallGrow			OffsetRect(&largeRect, -1, -1);#endif			DrawGrow3DBox(window, &largeRect, false);			// Draw the dark border parts for the top rectangle.#if !qSmallGrow			smallRect.right--;			smallRect.bottom--;#endif			DrawGrow3DBox(window, &smallRect, true);						ColorsNormal();					} else {			ColorsNormal();			FrameBox(&theRect);						FrameRect(&largeRect);			FrameBox(&smallRect);		}	}}// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ////	ToggleCloseBox//// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑvoidToggleCloseBox(WindowPeek window, Boolean isColor){	Rect tempRect;	GetCloseBox(window, &tempRect);		if (WindData.closeToggle)		DrawCloseBox(window, isColor, &tempRect);	else		DrawXedBox(window, isColor, &tempRect);}// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ////	ToggleZoomBox//// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑvoidToggleZoomBox(WindowPeek window, Boolean isColor){	Rect tempRect;	GetZoomBox(window, &tempRect);		if (WindData.zoomToggle)		DrawZoomBox(window, isColor, &tempRect);	else		DrawXedBox(window, isColor, &tempRect);}// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ////	PaintWidePattern//// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ//		Paints the 3-pixel separation pattern that the System 7.5 floating//		window uses.// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ#define kHSpacing		30#define kVSpacing		 9#define kBitmapWidth	30		// These donÕt need the blank space on the sides.#define kBitmapHeight	 9#define kBitmapRowbytes  4// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑstatic voidPaintWidePattern(const Rect *theRect) {	register short yPos = theRect->top;	Rect srcRect;	Rect dstRect;	GrafPtr thePort;	BitMap widePat;	Byte buffer[kBitmapRowbytes * kBitmapHeight];		// Set up the rectangles.	{		short rectWidth  = theRect->right - theRect->left;		short rectHeight = theRect->bottom - theRect->top;			srcRect.top		= srcRect.left = 0;		srcRect.bottom	= (kBitmapHeight < rectHeight) ? kBitmapHeight : rectHeight;		srcRect.right	= (kBitmapWidth  < rectWidth)  ? kBitmapWidth  : rectWidth;				dstRect = srcRect;	}			// Set up the BitMap.	widePat.baseAddr = (QDPtr) &buffer;	widePat.rowBytes = kBitmapRowbytes;	widePat.bounds   = srcRect;		// Set up the BitMapÕs buffer.	{		Byte* bufPtr = buffer;		int i;				for (i = 0; i < kBitmapHeight ; i++) {			if (i % 3 == 2)				*((unsigned long*) bufPtr) = 0x24924924;			else				*((unsigned long*) bufPtr) = 0;						bufPtr += kBitmapRowbytes;		}	}			// We need the port for CopyBits.	GetPort(&thePort);		// Actually loop over the area and draw the dot pattern.	while (yPos < theRect->bottom) {		register short xPos = theRect->left;		// Make sure our CopyBits doesnÕt overflow the rect.		short distPastBottom = yPos + srcRect.bottom - theRect->bottom;		if (distPastBottom > 0) {			srcRect.bottom -= distPastBottom;			dstRect.bottom -= distPastBottom;		}				// Start out with a full-width rectangle.		srcRect.right = srcRect.left + kBitmapWidth;		dstRect.right = dstRect.left + kBitmapWidth;				// Offset the dstRect to the right location.		dstRect.bottom += yPos - dstRect.top;		dstRect.top	 	= yPos;				while (xPos < theRect->right) {			// Make sure our CopyBits doesnÕt overflow the rect.			short distPastRight = xPos + srcRect.right - theRect->right;			if (distPastRight > 0) {				srcRect.right -= distPastRight;				dstRect.right -= distPastRight;			}						// Offset the dstRect to the right location.			dstRect.right += xPos - dstRect.left;			dstRect.left   = xPos;						// Draw a grid of dots.			CopyBits(&widePat, &thePort->portBits, 					 &srcRect, &dstRect, srcCopy, nil);						xPos += kHSpacing;		}		yPos += kVSpacing;	}}// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ////	GetTitlebarPat//// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ//		Choose correct pattern, depending on position of window in global//		coordinates. (Concept of new (2.3) version taken from _Macintosh //		Programming Secrets_, Second Edition, by Scott Knaster and Keith //		Rollin, page 423.)// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑstatic voidGetTitlebarPat(Boolean isActive, Point *corner, Pattern *titlePat) {	long seed = isActive ? 0x00550055 : 0x00000000;	if (IsOdd(corner->h))		seed <<= 1;	if (IsOdd(corner->v))		seed <<= 8;	*((long*) titlePat + 1) = *((long*) titlePat) = seed;}// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ////	SubtractGadgetRect//// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑstatic voidSubtractGadgetRect(RgnHandle theRgn, const Rect *theRect) {	Rect subRect = *theRect;	RgnHandle subRgn = NewRgn();		InsetRect(&subRect, -kTingeInset, -kTingeInset);		// To give the correct visual appearance.		RectRgn(subRgn, &subRect);	DiffRgn(theRgn, subRgn, theRgn);		DisposeRgn(subRgn);}// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ////	DrawTitleString//// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ// 		When this routine is called, the background color will already be set // 		to the color of the background of the titlebar.// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑstatic voidDrawTitleString(WindowPeek window, Boolean isColor, const Rect *titleRect, 				Rect *stringRect) {#if qTitleString	Boolean isActive = WindData.ignoreHilite || window->hilited;	short maxWidth;	short titleWidth;	short inset;	short strAreaLeft;	Rect titleStrBounds;	RGBColor saveFore;		if (window->titleHandle != nil && (*window->titleHandle)[0] != 0		&& WindData.isHoriz) 	{		maxWidth = titleRect->right - titleRect->left - 2 * kGadgetMargin;		strAreaLeft = titleRect->left + kGadgetMargin;		if (window->goAwayFlag || window->spareFlag) {			maxWidth -= 2 * (kGadgetSize + kGadgetMargin);			strAreaLeft += kGadgetSize + kGadgetMargin;		}		#if qApple75Design		maxWidth -= 6;		strAreaLeft += 3;#endif				if (maxWidth > 0) {			char saveTitleHandleState;							// Set up fonts, colors for text drawing.			TextFont(kTitleFont);			TextSize(kTitleSize);			TextFace(kTitleStyle);			TextMode(srcOr);						saveTitleHandleState = HGetState((Handle) window->titleHandle);			HLock((Handle) window->titleHandle);				// StringWidth and DrawString may move memory.						if (isColor)				GetForeColor(&saveFore);			SetWTitleColor(window, isColor);						// Calculate the width of the title string.			titleWidth = StringWidth(*window->titleHandle) + 2 * kTitleMargin;						// Limit its size to maxWidth.#if qApple75Design			// If the title doesnÕt fit, try _not_ centering it over the			// whole titlebar (just the dotted pattern area of it).			if (titleWidth > maxWidth) {				if (window->goAwayFlag && !window->spareFlag) {					maxWidth += kGadgetSize + kGadgetMargin;									} else if (!window->goAwayFlag && window->spareFlag) {					maxWidth += kGadgetSize + kGadgetMargin;					strAreaLeft -= kGadgetSize + kGadgetMargin;				}			}#endif			titleWidth = (titleWidth > maxWidth) ? maxWidth : titleWidth;						// Determine where to position it.			inset = (short) (maxWidth - titleWidth) / 2;			// Make the title appear centered.#if !qApple75Design			if (IsEven(titleWidth))				// We need an odd width or  				titleWidth--;					// the overlap is wrong.			inset -= IsEven(inset);				// This is done so that the title doesnÕt 				// shift as the windowÕs width changes.#endif						// Set up the Rect to enclose the title within the titlebar.			SetRect(&titleStrBounds, strAreaLeft + inset, 									 titleRect->top + 1, 									 strAreaLeft + inset + titleWidth, 									 titleRect->bottom - 1); 						// Inset the bounds so as not to erase part of the tinges.			if (isActive)				InsetRect(&titleStrBounds, 0, kTingeInset);						// Return the title string areaÕs boundry.			*stringRect = titleStrBounds;						// Make sure this area is cleared to the titlebar background color.			EraseRect(&titleStrBounds);						// Inset past the empty sides.			InsetRect(&titleStrBounds, kTitleMargin, 0);			// Outset it so decenders may overwrite the bottom tinge.			if (isActive)				InsetRect(&titleStrBounds, 0, -kTingeInset);			// Clip the drawing to the stringÕs area.			{				RgnHandle saveClip = NewRgn();				RgnHandle clipRgn  = NewRgn();						GetClip(saveClip);								// Get the region the title string should go into.				RectRgn(clipRgn, &titleStrBounds);								// Make sure we donÕt clobber other windows.				SectRgn(saveClip, clipRgn, clipRgn);				if (!EmptyRgn(clipRgn)) {					SetClip(clipRgn);							// Draw the title.					MoveTo(titleStrBounds.left, titleStrBounds.bottom - kTitleVDelta);					DrawString(*window->titleHandle);								// Clean up.					SetClip(saveClip);				}								DisposeRgn(saveClip);				DisposeRgn(clipRgn);			}						if (isColor)				RGBForeColor(&saveFore);						HSetState((Handle) window->titleHandle, saveTitleHandleState);			TextFont(systemFont);			TextSize(0);			TextFace(0);		}	}#endif}// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ////	DrawAndSubtractTitle//// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ//		Draws the title in the titlebar (by calling DrawTitleString) and //		subtracts it from the titlebar region (by making the rect returned//		into a region and using DiffRgn).// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑstatic void DrawAndSubtractTitle(WindowPeek window, const Rect *titleRect, Boolean isColor,			 		 RgnHandle titleRgn) {	Rect strRect;	strRect.top = strRect.left = strRect.bottom = strRect.right = 0;		// Draw the titlebar string (if any).	DrawTitleString(window, isColor, titleRect, &strRect);		// Since the area affected by the title string is returned in		// strRect, we can use itÕs left and right to draw the pattern.		if (!EmptyRect(&strRect)) {		RgnHandle tempRgn = NewRgn();				RectRgn(tempRgn, &strRect);		DiffRgn(titleRgn, tempRgn, titleRgn);				DisposeRgn(tempRgn);	}}// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ////	DrawSystem75TitlebarPattern//// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ#if qApple75Designstatic voidDrawSystem75TitlebarPattern(WindowPeek window, RgnHandle titleRgn) {	Boolean isHoriz = WindData.isHoriz;	Boolean isActive = WindData.ignoreHilite || window->hilited;	Rect titleRect;	Rect insetTitleRect;	Rect patternRect;		GetTitleBarRect(window, &titleRect);	// Get the gray titlebar background area.	insetTitleRect = titleRect;	InsetRect(&insetTitleRect, 1 + (isActive ? kTingeInset : 0), 							   1 + (isActive ? kTingeInset : 0));		patternRect = insetTitleRect;		// Subtract the close box.	if (isActive && window->goAwayFlag) {		Rect tempRect;		GetCloseBox(window, &tempRect);		if (isHoriz)			patternRect.left = tempRect.right + 1;		else			patternRect.top = tempRect.bottom + 1;	}#if qAllowZoom	// Subtract the zoom box.	if (isActive && window->spareFlag) {		Rect tempRect;		GetZoomBox(window, &tempRect);		if (isHoriz)			patternRect.right = tempRect.left;		else			patternRect.bottom = tempRect.top;	}#endif	if (isActive) {		Rect paintingRect = insetTitleRect;		RgnHandle saveClip = NewRgn();		GetClip(saveClip);				SectRgn(saveClip, titleRgn, titleRgn);			// This clobbers titleRgn, so we better not need it later.		SetClip(titleRgn);				// Adjust so the dots donÕt get too close to the edge.		if (isHoriz)			patternRect.right  -= 2;		else			patternRect.bottom -= 2;			// Draw the background behind the close box;		if (window->goAwayFlag) {			if (isHoriz)				paintingRect.right = patternRect.left;			else				paintingRect.bottom = patternRect.top;						EraseRect(&paintingRect);			if (isHoriz)				paintingRect.left = paintingRect.right;			else				paintingRect.top = paintingRect.bottom;		}				if (isHoriz)			paintingRect.right = patternRect.right;		else			paintingRect.bottom = patternRect.bottom;		PaintWidePattern(&paintingRect);		// Draw the background behind the zoom box or at the end.		if (isHoriz) {			paintingRect.left = paintingRect.right;			paintingRect.right = insetTitleRect.right;					} else {			paintingRect.top = paintingRect.bottom;			paintingRect.bottom = insetTitleRect.bottom;		}		EraseRect(&paintingRect);				// Restore the clip.		SetClip(saveClip);		DisposeRgn(saveClip);		} else {		EraseRgn(titleRgn);	}}#endif// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ////	DrawTitleBar//// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ//		This routine actually draws the pattern into the titlebar. Note: it//		takes a Rect as a parameter (not by address) because it goes ahead and//		modifies it. I figured this was no worse than needing to copy it into//		a local variable, so I went ahead and did it this way.// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑvoid DrawTitleBar(WindowPeek window, Boolean isColor) {	Boolean isHoriz = WindData.isHoriz;	Boolean isActive = WindData.ignoreHilite || window->hilited;	RgnHandle titleRgn = NewRgn();		Rect titleRect;	GetTitleBarRect(window, &titleRect);	#if qThinkStyle	if (!WindData.hasTitlebar)		return;#endif	// Draw the frame.	SetWFrameColor(window, isColor);	FrameRect(&titleRect);		// Set up the titleRgn region to be the whole titlebar, 	// parts will then be Ôpunched outÕ of it.	{		Rect insetTitleRect = titleRect;		InsetRect(&insetTitleRect, 1 + (isActive ? kTingeInset : 0), 								   1 + (isActive ? kTingeInset : 0));			// Make room for the tinge, if any (which was already drawn).		RectRgn(titleRgn, &insetTitleRect);	}			// Draw the tinges.	if (isActive) {		Rect tempRect;		DrawTitlebarTinges(window, isColor, &titleRect);			// Draw and subtract the close box.		if (window->goAwayFlag) {			GetCloseBox(window, &tempRect);			DrawCloseBox(window, isColor, &tempRect);			SubtractGadgetRect(titleRgn, &tempRect);		}	#if qAllowZoom		// Draw and subtract the zoom box.		if (window->spareFlag) {			GetZoomBox(window, &tempRect);			DrawZoomBox(window, isColor, &tempRect);			SubtractGadgetRect(titleRgn, &tempRect);		}#endif	}	// Get the colors to draw the rest.	SetWTitleBarColors(window, isColor);	// Draw the title string.	DrawAndSubtractTitle(window, &titleRect, isColor, titleRgn);	// Draw the pattern.#if qApple75Design	DrawSystem75TitlebarPattern(window, titleRgn);#else	{		Pattern pat;		GetTitlebarPat(isActive, (Point*) &titleRect.top, &pat);		FillRgn(titleRgn, &pat);	}#endif	DisposeRgn(titleRgn);}// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ////	DrawWindowFrame//// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑvoidDrawWindowFrame(WindowPeek window, Boolean isColor){	Rect tempRect = (**window->strucRgn).rgnBBox;		// Draw content frame and shadow.	tempRect.bottom--;	tempRect.right--;		SetWFrameColor(window, isColor);	FrameRect(&tempRect);		// Draw Shadow.	if (isColor)		WctbForeColor(window, wFrameColor);		// This got messed up in 2.6.	OffsetRect(&tempRect, 1, 1);	FrameBottomRightShading(tempRect);}// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ