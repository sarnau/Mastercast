// *****************************************************************************////	InfinityWindoid.c//// —————————————————————————————————————————————————————————————————————————————//	Copyright © 1991-95 Infinity Systems.  All rights reserved.// —————————————————————————————————————————————————————————————————————————————//	DESCRIPTION://		This file contains the main source for a WDEF (Window Definition)//		resource. It provides a ‘windoid’ appearance for use on floating windows. //				//		See the file ‘About Infinity Windoid’ for more information and a list//		of features this WDEF supports.// —————————————————————————————————————————————————————————————————————————————//	WRITTEN BY://		Troy Gaul, Infinity Systems////	HOW TO CONTACT THE AUTHOR://		Send e-mail to: tgaul@halcyon.com (preferred)//					or: tgaul@aol.com//					or: tgaul@eworld.com// *****************************************************************************#include "WindoidDefines.h"		// must be included before Apple interfaces#include <Errors.h>#include <Memory.h>#include <Resources.h>#include <ToolUtils.h>#include <Types.h>#include "WindoidDraw.h"#include "WindoidTypes.h"#include "WindoidUtil.h"// —————————————————————————————————————————————————————————————————————————————////	Function Prototypes	for main							 //// —————————————————————————————————————————————————————————————————————————————void DoWInit(WindowPeek window, long param, short varCode);void DoWDispose(WindowPeek window, long param);long DoWHit(WindowPeek window, long param);void DoWDraw(WindowPeek window, long param);void DoWCalcRgns(WindowPeek window, long param);void DoWGrow(WindowPeek window, long param);void DoWDrawGIcon(WindowPeek window, long param);// —————————————————————————————————————————————————————————————————————————————////	Windoid Main Function													 //// —————————————————————————————————————————————————————————————————————————————//		This is the main entry point for all calls to this code resource. It//		dispatches to routines that correspond to the message it is given.// —————————————————————————————————————————————————————————————————————————————pascal long main(short varCode, WindowPeek window, short message, long param) {	long result = 0;	GrafPtr	savePort;	Boolean	needSyncPorts;	// This sets up the appropriate drawing environment, but only for those	// messages for which we actually need to draw.	needSyncPorts = (message == wDraw 				  || message == wHit 				  || message == wGrow				  || message == wDrawGIcon) && HasCQDraw();	if (needSyncPorts) {		GetPort(&savePort);		SyncPorts();	}		switch (message) {		case wNew:			DoWInit(window, param, varCode);							break;				case wDispose:		DoWDispose(window, param);							break;		case wDraw:			DoWDraw(window, param & 0xFFFF);							break;			// There’s a tech note that says that for the draw message, only			// the low-order word of param is set correctly, so we should do			// this (AND with 0xFFFF) to be sure we’re looking at the correct 			// value.					case wHit:			result = DoWHit(window, param);									break;				case wCalcRgns:		DoWCalcRgns(window, param);							break;		#if qAllowGrow		case wGrow:			DoWGrow(window, param);							break;									case wDrawGIcon:	DoWDrawGIcon(window, param);							break;#endif	}		if (needSyncPorts)		SetPort(savePort);		return result;}// —————————————————————————————————————————————————————————————————————————————////	SetZoomRects//// —————————————————————————————————————————————————————————————————————————————//		Fills out the zoom rectangles that are stored in our data record that//		hangs off of the dataHandle of the Window.  These define the normal//		user state (the current position and size that the user has made the //		window) and standard state (the state the application determines is//		the position and size for the window when it is zoomed out to “full//		size”).////		The standard state is initialized to be equal to the initial position//		and size of the window.  The WDEF doesn’t modify this state after that;//		the application should set it to an appropriate rectangle (either after//		making the window or whenever the zoom box is hit, whichever is //		appropriate for the application’s use of the zoom box.// —————————————————————————————————————————————————————————————————————————————static void SetZoomRects(WindowPeek window) {	if (window->spareFlag) {		Rect contRect;		GetGlobalContentRect(window, &contRect);				WindData.wState.stdState = contRect;		WindData.wState.userState = contRect;	}}// —————————————————————————————————————————————————————————————————————————————////	GetZoomHitType//// —————————————————————————————————————————————————————————————————————————————static long GetZoomHitType(WindowPeek window) {	Rect contentRect;	long result;		GetGlobalContentRect(window, &contentRect);#if qStayputZoom	MoveRectTo(&WindData.wState.stdState, contentRect.left, contentRect.top);	MoveRectTo(&WindData.wState.userState, contentRect.left, contentRect.top);#endif		result = EqualRect(&contentRect, &WindData.wState.stdState) 				? wInZoomIn : wInZoomOut;		// Calculate offset for zoom rects (make sure they are up to date).	if (result == wInZoomOut)		WindData.wState.userState = contentRect;		return result;}// *****************************************************************************////	DoWInit -- Windoid initialization.//// *****************************************************************************// —————————————————————————————————————————————————————————————————————————————////	DoWInit//// —————————————————————————————————————————————————————————————————————————————//		This routine initializes the WDEF’s information in the window record//		by allocating a handle that will hang from the WindowRecord’s dataHandle//		field.  This handle contains the zoom rects at the beginning (just like//		Apple’s System WDEFs).  This is followed by a set of flags that the//		Infinity Windoid uses to determine features in use by a window.//		//		The set of variation codes that the Infinity Windoid uses is the same//		set that is used by the new Apple System 7.5 floating window WDEF.  They//		are as follows://			1 - Set to allow the window’s appearance reflect the hilite flag.//			2 - Set to allow drawing of a grow box.//			4 - Set to put a zoom box in the titlebar.//			8 - Set to put the titlebar down the side of the window.//		//		To use a variation code, add the number corresponding to the flag(s) you//		want to the procID that you use when creating the window.  For example,//		to use all of the options, pass NewWindow or give a WIND resource a //		procID of (128 * 16) + 1 + 2 + 4 + 8.////		I suggest you always set the first flag (without it, the WDEF will//		always draw with the pattern in the titlebar and it will never //		dim -- dimming is necessary for the proper appearance when a modal //		window is displayed above a floater, however).// —————————————————————————————————————————————————————————————————————————————void DoWInit(WindowPeek window, long param, short varCode) {	Handle zoomDataHndl = NewHandleClear(sizeof(WindoidData));		window->spareFlag = false;	if (zoomDataHndl) {		WindoidDataPtr wdata = (WindoidDataPtr) *zoomDataHndl;					// Make it easier to access.				wdata->closeToggle 	= 0;		wdata->ignoreHilite	= false;				// Set the hasGrow flag.#if qAllowGrow && qApple75Varcodes		wdata->hasGrow		= (varCode & kSystem75_hasGrow) != 0;#elif qAllowGrow && qMacAppStyle		wdata->hasGrow		= (varCode & kMacApp_hasGrow) != 0;#elif qAllowGrow		wdata->hasGrow		= (varCode & noGrowDocProc) == 0;#endif				// Set the isHoriz flag.#if qAllowVert && qApple75Varcodes		wdata->isHoriz 		= (varCode & kSystem75_vertTBar) == 0;#elif qAllowVert 		wdata->isHoriz 		= !((varCode & 1) || (varCode & 2));#else		wdata->isHoriz 		= true;#endif				// Set the ignoreHilite flag.#if qApple75Varcodes		wdata->ignoreHilite	= (varCode & kSystem75_toggleTBar) == 0;#elif qMacAppStyle		wdata->ignoreHilite	= !(varCode & kMacApp_toggleTBar);#else		wdata->ignoreHilite	= false;#endif		#if qThinkStyle		// Set the hasTitlebar flag.		wdata->hasTitlebar	= (varCode & 7) == 0 || (varCode & 7) == 2;#endif				// Set the window’s data handle to the right value.		window->dataHandle 	= zoomDataHndl;				// Set the Zoom box stuff flag.#if qAllowZoom		wdata->zoomToggle	= 0; #if qApple75Varcodes		window->spareFlag	= (varCode & kSystem75_hasZoom) != 0; #else		window->spareFlag	= (varCode & zoomDocProc) != 0; #endif		SetZoomRects(window);#endif	}}// *****************************************************************************////	DoWDispose -- Windoid disposal.//// *****************************************************************************void DoWDispose(WindowPeek window, long param) {	if (window->dataHandle)		DisposeHandle(window->dataHandle);}// *****************************************************************************////	DoWHit -- Windoid hit routine.//// *****************************************************************************long DoWHit(WindowPeek window, long param) {	Rect theRect;	Point hitPt;	long result = wNoHit;		hitPt.v = HiWord(param);	hitPt.h = LoWord(param);		if (PtInRgn(hitPt, window->strucRgn)) {		result = wInContent;				if (PtInRgn(hitPt, window->contRgn)) {#if qAllowGrow			// Look for a hit in the grow box.			if (WindData.hasGrow) {				GetGrowBox(window, &theRect);				InsetRect(&theRect, -1, -1);				if (PtInRect(hitPt, &theRect))					result = wInGrow; 			}#endif			} else {						// Look for a hit in the titlebar.			Rect titleRect;			GetTitleBarRect(window, &titleRect);						if (#if qThinkStyle				WindData.hasTitlebar && #endif				PtInRect(hitPt, &titleRect)) 			{				result = wInDrag;				if (WindData.ignoreHilite || window->hilited) {					if (window->goAwayFlag) {						GetCloseBox(window, &theRect);						InsetRect(&theRect, -kGadgetHitFudge, -kGadgetHitFudge);						if (PtInRect(hitPt, &theRect))							result = wInGoAway;					}		#if qAllowZoom					if (window->spareFlag) {						GetZoomBox(window, &theRect);						InsetRect(&theRect, -kGadgetHitFudge, -kGadgetHitFudge);						if (PtInRect(hitPt, &theRect))							result = GetZoomHitType(window);					}	#endif				}			}		}	}	return result;}// *****************************************************************************////	DoWDraw -- Windoid drawing routines.//// *****************************************************************************typedef struct {	WindowPeek	wdlWindow;	long		wdlParam;} WDLDataRec;	// This information is used to communicate with DeviceLoop callback routine.// —————————————————————————————————————————————————————————————————————————————////	WindoidDrawLoop//// —————————————————————————————————————————————————————————————————————————————//		This routine actually does the real work of the drawing of stuff into//		the window.// —————————————————————————————————————————————————————————————————————————————static pascal void WindoidDrawLoop(short depth, short deviceFlags, GDHandle targetDevice, 				WDLDataRec *userData) {	WindowPeek window = userData->wdlWindow;	// Make sure our macros work.	Boolean isColor = CheckDisplay(depth, deviceFlags, targetDevice, window);		switch (userData->wdlParam) {		case wNoHit:			DrawTitleBar(window, isColor);			DrawWindowFrame(window, isColor);			break;		case wInGoAway:			ToggleCloseBox(window, isColor);			break;		#if qAllowZoom		case wInZoomIn: 		case wInZoomOut:			if (window->spareFlag)				ToggleZoomBox(window, isColor);			break;#endif	}	ColorsNormal();}// —————————————————————————————————————————————————————————————————————————————////	DoWDraw//// —————————————————————————————————————————————————————————————————————————————void DoWDraw(WindowPeek window, long param) {	WDLDataRec userData;		if (window->visible) {		userData.wdlWindow = window;		userData.wdlParam = param;				{#if USESROUTINEDESCRIPTORS || GENERATINGCFM			RoutineDescriptor drawProcRD					= BUILD_ROUTINE_DESCRIPTOR(uppDeviceLoopDrawingProcInfo, 											   WindoidDrawLoop);			DeviceLoopDrawingUPP uppDrawProc = &drawProcRD;				// This is done to avoid allocating the RoutineDescriptor in				// the heap (with NewDeviceLoopDrawingProc) and then needing				// to dispose of it right away.#else			DeviceLoopDrawingUPP uppDrawProc 					= (DeviceLoopDrawingUPP) &WindoidDrawLoop;#endif			OurDeviceLoop(window->strucRgn, uppDrawProc, 						  (long) &userData, (DeviceLoopFlags) 0);		}				switch (param) {			case wInGoAway:						// Toggle go-away flag.				WindData.closeToggle = !WindData.closeToggle;				break;			#if qAllowZoom			case wInZoomIn: 			case wInZoomOut:				WindData.zoomToggle = !WindData.zoomToggle;				break;#endif		}	}}// *****************************************************************************////	DoWCalcRgns -- Windoid region calculating routine										 //// *****************************************************************************// —————————————————————————————————————————————————————————————————————————————////	DoWCalcRgns											 //// —————————————————————————————————————————————————————————————————————————————void DoWCalcRgns(WindowPeek window, long param) {	Rect theRect;	// Calculate the content Rect in global coordinates.	GetGlobalContentRect(window, &theRect);	RectRgn(window->contRgn, &theRect);	// Start off with the structure equal to the content	// and make it include the window frame and titlebar.	InsetRect(&theRect, -1, -1);#if qThinkStyle	if (WindData.hasTitlebar) {#endif		if (WindData.isHoriz)			theRect.top -= kTitleHeight - 1;		else			theRect.left -= kTitleHeight - 1;#if qThinkStyle	}#endif	RectRgn(window->strucRgn, &theRect);		// Add the shadow to the structure.	{		RgnHandle tempRgn = NewRgn();				OffsetRect(&theRect, 1, 1);		RectRgn(tempRgn, &theRect);		UnionRgn(tempRgn, window->strucRgn, window->strucRgn);			DisposeRgn(tempRgn);	}}// *****************************************************************************////	DoWGrow -- Draw the growing outline.//// *****************************************************************************// —————————————————————————————————————————————————————————————————————————————////	DoWGrow//// —————————————————————————————————————————————————————————————————————————————void DoWGrow(WindowPeek window, long param) {	Rect growingRect = *(Rect*) param;		if (WindData.isHoriz)		growingRect.top  -= kTitleHeight - 1;	// Add room for the titlebar.	else		growingRect.left -= kTitleHeight - 1;	// Add room for the titlebar.	InsetRect(&growingRect, -1, -1);		// Draw the window frame.	FrameRect(&growingRect);		if (WindData.isHoriz)		growingRect.top  += kTitleHeight - 1;	else		growingRect.left += kTitleHeight - 1;		// Now mark the titlebar area.	MoveTo(growingRect.left, growingRect.top);	if (WindData.isHoriz)		LineTo(growingRect.right - 2, growingRect.top);	else		LineTo(growingRect.left, growingRect.bottom - 2);	#if !qApple75Design	// Mark the scroll bars too.	MoveTo(growingRect.right - kScrollBarPixels, growingRect.top + 1);	LineTo(growingRect.right - kScrollBarPixels, growingRect.bottom - 2);		MoveTo(growingRect.left, growingRect.bottom - kScrollBarPixels);	LineTo(growingRect.right - 2, growingRect.bottom - kScrollBarPixels);       #endif}// *****************************************************************************////	DoWDrawGIcon -- Draw the grow icon and scroll frame in the lower right.//// *****************************************************************************// —————————————————————————————————————————————————————————————————————————————////	GrowBoxDrawLoop//// —————————————————————————————————————————————————————————————————————————————static pascal void GrowBoxDrawLoop(short depth, short deviceFlags, GDHandle targetDevice, 				WDLDataRec *userData) {	WindowPeek window = userData->wdlWindow;	Boolean isColor = CheckDisplay(depth, deviceFlags, targetDevice, window);	DrawGrowBox(window, isColor);}// —————————————————————————————————————————————————————————————————————————————////	DoWDrawGIcon//// —————————————————————————————————————————————————————————————————————————————void DoWDrawGIcon(WindowPeek window, long param) {#if qAllowGrow	if (window->visible && WindData.hasGrow) {		WDLDataRec userData;		RgnHandle saveClip = NewRgn();		RgnHandle tempRgn = NewRgn();		Point mappingPoint;				SectRgn(window->port.visRgn, window->port.clipRgn, tempRgn);		GetClip(saveClip);				GetGlobalMappingPoint(window, &mappingPoint);		OffsetRgn(tempRgn, mappingPoint.h, mappingPoint.v);				SetClip(tempRgn);				userData.wdlWindow = window;		{#if USESROUTINEDESCRIPTORS || GENERATINGCFM			RoutineDescriptor drawProcRD					= BUILD_ROUTINE_DESCRIPTOR(uppDeviceLoopDrawingProcInfo, 											   GrowBoxDrawLoop);			DeviceLoopDrawingUPP uppDrawProc = &drawProcRD;				// This is done to avoid allocating the RoutineDescriptor				// in the heap, allocate it on the stack instead.#else			DeviceLoopDrawingUPP uppDrawProc 					= (DeviceLoopDrawingUPP) &GrowBoxDrawLoop;#endif			OurDeviceLoop(window->strucRgn, uppDrawProc, 						  (long) &userData, (DeviceLoopFlags) 0);		}		SetClip(saveClip);		DisposeRgn(saveClip);		DisposeRgn(tempRgn);	}#endif}// —————————————————————————————————————————————————————————————————————————————