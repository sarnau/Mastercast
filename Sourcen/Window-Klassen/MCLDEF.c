/*** *	generelles LDEF-Window mit zwei Scrollbars und Zellen drin (eine eindimensionale Liste, die im Fenster dargestellt wird) * *	©1994 Mastercast, Markus Fritze ***/#include "MCLDEF.h"#include "MenuLib.h"#include "DoEvent.h"#include "GlobalLib.h"#include "DialogBase.h"#include "OffscreenObject.h"#include <Lists.h>#include <LowMem.h>/*** *	Menüpunkt aufgerufen ***/Boolean		MCLDEF::DoCommand(long cmd){	switch(cmd) {	case cSelectAll:	// Alle selektieren (mit Option: alle deselektieren)			Cell		theCell = { 0,0 };			biene();			// Zellen mit dem List Manager selektieren bzw. deselektieren (dabei gleichzeitig updaten)			do {				LSetSelect(!(gTheEvent.modifiers & optionKey), theCell, IList);			} while(LNextCell(true, true, &theCell, IList));			UpdateFlags();			pfeil();			break;	default:			return WindowBase::DoCommand(cmd);	}	return true;}/*** *	Befehle bei Bedarf enablen ***/void		MCLDEF::GetCommandStatus(long cmd, Boolean &enabled, short &markChar, Str255 &name){	switch(cmd) {	case cSelectAll:			GetIndString(name, 4001, ((gTheEvent.modifiers & optionKey) != optionKey) ? 4 : 5);			enabled = true;			break;	default:			WindowBase::GetCommandStatus(cmd, enabled, markChar, name);	}}/*** *	Liste der selektierten Einträge ermitteln ***/Ptr			MCLDEF::GetData(short &count){Cell		theCell;Ptr			listData;	count = 0;	listData = NewPtr(ElementCount * ElementSize);	SetPt(&theCell, 0,0);	do {		short		dataLen = ElementSize;		LGetCell(listData + count * ElementSize, &dataLen, theCell, IList);		if(dataLen != ElementSize) break;	// ein gültiger Eintrag?		count++;	} while(LNextCell(true, true, &theCell, IList));	return listData;}/*** *	Liste der selektierten Einträge ermitteln ***/Ptr			MCLDEF::GetSelectedData(short &count){Cell		theCell;Ptr			listData;	count = 0;	listData = NewPtr(CountSelectedData() * ElementSize);	SetPt(&theCell, 0,0);	while(LGetSelect(true, &theCell, IList)) {	// alle selektierten Zellen zählen		short		dataLen = ElementSize;		LGetCell(listData + count * ElementSize, &dataLen, theCell, IList);		if(dataLen != ElementSize) break;		count++;		if(!LNextCell(true, true, &theCell, IList)) break;	}	return listData;}/*** *	Region mit allen sichtbaren selektierten Daten erzeugen ***/RgnHandle	MCLDEF::SelectedDataRgn(void){RgnHandle		theRgn,tempRgn;Cell			theCell;Rect			cellRect;	theRgn = NewRgn(); tempRgn = NewRgn();	SetPt(&theCell, 0,0);	while(LGetSelect(true, &theCell, IList)) {	// alle selektierten Zellen durchgehen		LRect(&cellRect, theCell, IList);		Rect		tempRect = (*IList)->rView;		if(SectRect(&tempRect, &cellRect, &tempRect)) {	// Schnittfläche mit dem sichtbaren Bereich ermitteln, Zelle sichtbar?			LocalToGlobalRect(&cellRect);		// in ein globales Rechteck wandeln			InsetRect(&cellRect, 2, 2);			// Zellenrechteck verkleinern			RectRgn(tempRgn, &cellRect);		// in eine Region wandeln			UnionRgn(tempRgn, theRgn, theRgn);	// Gesamtregion ermitteln		}		if(!LNextCell(true, true, &theCell, IList)) break;	}	DisposeRgn(tempRgn);	return theRgn;}/*** *	Windowgröße an die Anzahl der Daten anpassen ***/void		MCLDEF::SetWindowSize(void){	Rect		r;	short		tableHeight = TableSize.v;	short		tableWidth = TableSize.h;	SetPt(&SnapSize, CellSize.h, CellSize.v);	SetPt(&ToolbarOffset, 0, InfoLineHeight);	SetPt(&SliderOffset, (ScrollBar_Size - 1), (ScrollBar_Size - 1));	// mögliche Fenstergröße errechnen	r.left = 2 + 36;	r.right = r.left + tableWidth * CellSize.h + (ScrollBar_Size - 1);	// gewünschte Breite	while(r.right > (qd.screenBits.bounds.right - 3)) {				// auf Bildschirmbreite reduzieren		r.right -= CellSize.h;		tableWidth--;	}	r.top = 18 + GetMBarHeight() + 3;	r.bottom = r.top + tableHeight * CellSize.v + InfoLineHeight + (ScrollBar_Size - 1);		// gewünschte Höhe	// minimale Fenstergröße zum Sizen	SetPt(&MinSize, CellSize.h + (ScrollBar_Size - 1), CellSize.v + InfoLineHeight + (ScrollBar_Size - 1));	// nun reduzieren wir die Fenstergröße soweit, daß es komplett auf den Bildschirm paßt	while(r.bottom > (qd.screenBits.bounds.bottom - 3)) {		r.bottom -= CellSize.v;		tableHeight--;	}	// Liste neu skalieren	ElementCount = (*IList)->dataBounds.bottom - 1;	// neue Anzahl der Elemente	Rect		rDataBnds;	SetRect(&rDataBnds, 0,0, 1,1);				// minimales Rechteck	// genügend Zellen für "elemCount" allozieren	if(ElementCount >  tableWidth) {			// Mehr Elemente, als die Wunschbreite?		rDataBnds.right = tableWidth;			// Wunschbreite setzen		rDataBnds.bottom = (ElementCount + tableWidth - 1) / tableWidth;	// und entsprechend Zeilen hinzufügen	} else {		rDataBnds.right = ElementCount;			// Tabelle so breit, wie es Elemente gibt	}	(*IList)->dataBounds = rDataBnds;			// und zurück in die gewünschte Tabelle wandeln	// XXX: Dies ist _totaler_ Schweinkram!!! Verhindert aber, daß Speicher durch Umwandlung in eine 2-dimensionale Liste	// überschrieben wird, falls die letzte Zeile nicht ganz vollständig ist. Saubere Lösung: List Manager ersetzen :-(	SetHandleSize((Handle)IList, sizeof(ListRec) + ((*IList)->dataBounds.right * (*IList)->dataBounds.bottom + 1) * sizeof(short));	// jetzt prüfen wir noch, ob die Liste evtl. kleiner als das Fenster ist. Ggf. reduzieren wir die Fensterhöhe	short	showElem = tableWidth * tableHeight;			// maximale Anzahl der Objekte, die man sehen kann	while(showElem > ((ElementCount + tableWidth - 1) / tableWidth) * tableWidth) {		// auf die Anzahl der vorhandenen Datensätze reduzieren		r.bottom -= CellSize.v;		showElem -= tableWidth;	}	if(tableWidth > ElementCount) {		// Tabelle besteht nur noch aus einer Zeile?		while(showElem > ElementCount) {			r.right -= CellSize.h;				// dann die Breite einschränken			showElem--;		}	}	// maximale Fenstergröße zum Sizen und Zoomen	SetPt(&MaxSize, r.right - r.left + 1, r.bottom - r.top + 1);	static Point	pp = {0,0};	if(EqualPt(topLeft((*((WindowPeek)WindRef)->strucRgn)->rgnBBox), pp))	// Fensterposition noch nie gesetzt?		MoveWindow((WindowPtr)WindRef, r.left, r.top, false);	// dann an Defaultposition setzen	SizeWindow((WindowPtr)WindRef, MaxSize.h - 1, MaxSize.v - 1, true);	// Größe anpassen	Adjust();}/*** *	Daten in die aktuelle (sortierte!) Liste einfügen ***/void		MCLDEF::AddData(short count, Ptr listData){	SetPort((WindowPtr)WindRef);	(*IList)->dataBounds.bottom = ElementCount + 1;	// Tabelle in eine eindimensionale Tabelle wandeln	(*IList)->dataBounds.right = 1;	// Daten in die Liste einfügen	LSetDrawingMode(false, IList);				// kein Redraw! (Beschleunigt die Sache um ein Vielfaches!!!)	biene();	Ptr		dp = NewPtrClear(ElementSize);	Cell	c;	c.h = 0;	for(int i=0; i<count; i++) {		for(c.v=ElementCount-1; c.v>=0; c.v--) {// wir fangen vom maximalen Element an zu suchen, da im langsamen (Init-) Fall												// die Liste leer ist und die übergebene einzufügende Liste lang und sortiert												// ist, d.h. es muß dann nur pro Element _ein_ Vergleich gemacht werden.			short			dataLen = ElementSize;			LGetCell(dp, &dataLen, c, IList);			if(dataLen != ElementSize)			// ein gültiger Eintrag?				continue;						// => nein, weiter			short 	cmp = Compare(dp, listData + i * ElementSize);	// Elemente vergleichen			if(cmp < 0)							// altes Element ist kleiner				break;							// => einfügen!			if(cmp == 0)						// gleiches Element schon vorhanden? (Dupes wollen wir nicht!)				goto nextelem;					// Element skippen		}		// Element hinter der gefundenen Stelle einfügen		c.v = LAddRow(1, ++c.v, IList);		LSetCell(listData + i * ElementSize, ElementSize, c, IList);		ElementCount++;		// und die Anzahl der Elemente hochzählen	nextelem:		{}	// um bei MCW keinen Syntax-Fehler zu erzeugen, hier eine leere Klammer…………	}	DisposePtr(dp);	pfeil();	LSetDrawingMode(true, IList);				// Zellen nun erst updaten	EraseRect(&((WindowPtr)WindRef)->portRect);	// alles löschen (nicht elegant :-()	InvalRect(&((WindowPtr)WindRef)->portRect);	// und updaten…	SetWindowSize();							// Fenstergröße und Defaultposition setzen}/*** *	Daten aus der aktuellen Liste löschen ***/void		MCLDEF::RemoveData(short count, Ptr listData){	SetPort((WindowPtr)WindRef);	(*IList)->dataBounds.bottom = ElementCount + 1;	// Tabelle in eine eindimensionale Tabelle wandeln	(*IList)->dataBounds.right = 1;	// Daten in die Liste einfügen	LSetDrawingMode(false, IList);				// kein Redraw (Liste ist ja nun zeitweise eindimensional)	biene();	Ptr		dp = NewPtr(ElementSize);	Cell	c;	c.h = 0;	for(int i=0; i<count; i++) {		for(c.v=0; c.v<ElementCount; c.v++) {			short			dataLen = ElementSize;			LGetCell(dp, &dataLen, c, IList);			if(dataLen != ElementSize)			// ein gültiger Eintrag?				continue;			if(Compare(dp, listData + i * ElementSize) != 0)	// Elemente identisch?				continue;						// ungleich! => weiter suchen			LDelRow(1, c.v, IList);			ElementCount--;			break;		}	}	DisposePtr(dp);	pfeil();	LSetDrawingMode(true, IList);				// Zellen nun erst updaten	if(ElementCount == 0) {						// keine Elemente mehr übrig?		delete this;							// => Fehler löschen		return;	}	EraseRect(&((WindowPtr)WindRef)->portRect);	// alles löschen (nicht elegant :-()	InvalRect(&((WindowPtr)WindRef)->portRect);	// und updaten…	SetWindowSize();							// Fenstergröße und Defaultposition setzen}/*** *	Selected-Flags gemäß List Manager updaten ***/void		MCLDEF::UpdateFlags(void){	if(!IList) return;	// Anzahl der selektierten Zellen zählen	Cell		theCell;	short		selCount;	Ptr		dp = NewPtr(ElementSize);	selCount = 0;	SetPt(&theCell, 0,0);	while(LGetSelect(true, &theCell, IList)) {	// alle selektierten Zellen zählen		short		dataLen = ElementSize;		LGetCell(dp, &dataLen, theCell, IList);		if(dataLen != ElementSize) break;		selCount++;		if(!LNextCell(true, true, &theCell, IList)) break;	}	DisposePtr(dp);	SelectedCells = selCount;	DrawInfoline(false);	// evtl. aktives Menü freischalten, Toolbar updaten	AdjustMenu(this);}/*** *	LDEF Callback-Funktion ***/pascal void		MCLDEF::MCLDEFCallback(short lMessage, Boolean lSelect, Rect *lRect, Cell lCell, short lDataOffset, short lDataLen, ListHandle lHandle){MCLDEF		*lp = ((refConStructType*)(*lHandle)->refCon)->thisPtr;	if(lMessage != lCloseMsg &&		// die Klasse existiert beim Destruktor-Aufruf eh nicht mehr		lMessage != lInitMsg) {		// lInitMsg filtere ich nur der Vollständigkeit halber (damit									// gar nicht erst was alloziert wird, das man bei lCloseMsg									// nicht mehr aufgerufen bekommt		if(((lCell.h + lCell.v * (*lHandle)->dataBounds.right) < lp->ElementCount) && (lDataLen == lp->ElementSize))	// Zelle überhaupt gültig?			lp->LDEFCallback(lMessage, lSelect, lRect, lCell, lDataOffset, lDataLen, lHandle);	}}/*** *	LDEF öffnen ***/void		MCLDEF::Open(short cellHeight, short cellWidth, short tableHeight, short tableWidth, short resid,						StringPtr windName, short elemCount, short elemSize, Ptr listData,						ListSearchProcPtr ldefSProc, WindowScrapAttributes scrpattr, short infoheight){Str255			wname;	IList = nil;						// Variablen der Klasse setzen	InfoLineHeight = infoheight;		// normale Höhe der Infozeile = 20 Pixel	SelectedCells = 0;	STRResId = resid;	SearchProcPtr = ldefSProc;	ElementCount = 0;	ElementSize = elemSize;	SetPt(&TableSize, tableWidth, tableHeight);	SetPt(&CellSize, cellWidth, cellHeight);	GetIndString(wname, resid, 7);		// Default-Windownamen holen	if(windName)		ConcatPString(wname, windName);	// ggf. übergebenen Namen anhängen	// Fenster öffnen	Rect		r;	SetRect(&r, 0,0, 255, 255);	WindowBase::Open(&r, wname, false, kHasCloseBoxMask|kHasZoomBoxMask|kHasGrowBoxMask|kHasDocumentTitlebarMask, scrpattr, (WindowRefX)-1L);	// Listmanager anmelden	Rect		rView, rDataBnds;	rView = ((WindowPtr)WindRef)->portRect;	rView.top += InfoLineHeight;	rView.right -= (ScrollBar_Size - 1);	rView.bottom -= (ScrollBar_Size - 1);	SetRect(&rDataBnds, 0,0, 1,1);			// eine leere Liste (ohne Elemente)	IList = LNew(&rView, &rDataBnds, CellSize, 128, (WindowPtr)WindRef, true, true, true, true);	refConStruct.CallbackUPP = NewListDefProc(MCLDEFCallback);	refConStruct.thisPtr = this;	(*IList)->refCon = (long)&refConStruct;	// LDEF-Callback installieren	if(elemCount)		AddData(elemCount, listData);	else		SetWindowSize();					// Fenstergröße und Defaultposition setzen	ShowReferencedWindow(WindRef);}/*** *	LDEF schließen ***/				MCLDEF::~MCLDEF(){	if(IList) {		LDispose(IList);		IList = nil;	}	DisposeRoutineDescriptor(refConStruct.CallbackUPP);	refConStruct.CallbackUPP = nil;}/*** *	Infozeile zeichnen ***/void			MCLDEF::DrawInfoline(Boolean forceRedraw){static short	saveCount = -1;static short	saveSelCount = -1;	if(!IList) return;	short		selCount = CountSelectedData();	short		width = (*IList)->rView.right + (ScrollBar_Size - 1);	// Redraw nötig?	if(!forceRedraw && saveSelCount == selCount && saveCount == ElementCount)		return;									// Nein => raus	saveSelCount = selCount;	saveCount = ElementCount;	Rect			r;	SetRect(&r, 0,0, width,InfoLineHeight);	OffscreenObject	ob((*IList)->port, &r);		// Offscreen zeichnen (das Kopieren auf den Bildschirm macht der Destructor!)	if(r.bottom > 20) {							// "Über"höhe?		PenPat(&qd.gray);		MoveTo(5, 17); Line(width - 10, 0);		// dann eine graue Trennlinie		PenNormal();	}	MoveTo(0, r.bottom - 1); Line(width, 0);	MoveTo(0, r.bottom - 3); Line(width, 0);	FontInfo		fInfo;	short			lineHeight;	SetFont(5001);	GetFontInfo(&fInfo);	lineHeight = fInfo.ascent + fInfo.leading;	// Höhe einer Textzeile ermitteln	Str255			theString,theStr2;	if(ElementCount < 2) {		GetIndString(theString, STRResId, (ElementCount == 0)?1:2);	} else {		NumToString(ElementCount, theString);		GetIndString(theStr2, STRResId, 3);		ConcatPString(theString, theStr2);	}	MoveTo(9, 2 + lineHeight);	short		slen = StringWidth(theString) + 8 + 9;	// Offset des Strings, an dem der rechte String minimal anfangen darf (damit es keine Überlappung gibt)	DrawString(theString);	if(selCount < 2) {		GetIndString(theString, STRResId, (selCount == 0)?4:5);	} else {		NumToString(selCount, theString);		GetIndString(theStr2, STRResId, 6);		ConcatPString(theString, theStr2);	}	short		spos = width - StringWidth(theString) - 4;	// Wunschposition errechnen	if(spos < slen)								// zu weit links?		spos = slen;							// dann etwas nach rechts rücken (der Text wird somit nicht mehr ganz dargestellt)	MoveTo(spos, 2 + lineHeight);	DrawString(theString);}/*** *	LDEF updaten ***/void			MCLDEF::Draw(void){	if(!IList) return;							// Liste angemeldet (sollte immer sein)	WindowBase::DrawGrowIcon(WindRef);			// damit der Sizer zuerst mal dargestellt wird (der Redraw kann ja ein Weilchen dauern)	if((*IList)->lActive)						// Busy Bee, nur wenn die Liste aktiv ist		biene();	DrawInfoline(true);	if(ElementCount > 0)		LUpdate((*IList)->port->visRgn, IList);		// Liste durch den List Manager updaten lassen	if((*IList)->lActive)		pfeil();}/*** *	LDEF-Window ist aktiv bzw. inaktiv geworden ***/void			MCLDEF::EventActivate(Boolean flag){	if(!IList) return;							// Liste angemeldet (sollte immer sein)	WindowBase::EventActivate(flag);	if(ElementCount > 0)		LActivate(flag, IList);}/*** *	LDEF-Window Größe anpassen ***/void			MCLDEF::Adjust(void){	if(!IList) return;							// Liste angemeldet (sollte immer sein)	WindowBase::Adjust();	DrawInfoline(true);	Rect		*wr = &((WindowPtr)WindRef)->portRect;	short		maxw = wr->right - wr->left + 1;	short		maxh = wr->bottom - wr->top + 1;	// Window so skalieren, daß nur ganze Zellen sichtbar sind!	maxh -= (*IList)->rView.top + (ScrollBar_Size - 1);	maxw -= (ScrollBar_Size - 1);	maxw = ((maxw + (((*IList)->cellSize.h * 2) / 3)) / (*IList)->cellSize.h) * (*IList)->cellSize.h;	// wenn 1/3 einer Zelle sichtbar ist => Zelle ganz darstellen	maxh = ((maxh + (((*IList)->cellSize.v * 2) / 3)) / (*IList)->cellSize.v) * (*IList)->cellSize.v;	if(ElementCount > 0)		LSize(maxw, maxh, IList);				// Größe der Liste anpassen (+ Redraw)	WindowBase::DrawGrowIcon(WindRef);			// Sizer darstellen}/*** *	einige Routinen aus dem NIM "List Manager" zur Listen Verwaltung ***/static Boolean		MyGetFirstSelectedCell(ListHandle theList, Cell &theCell);static void			MyGetLastSelectedCell(ListHandle theList, Cell &theCell);static void			MySelectOneCell(ListHandle theList, Cell theCell);static void			MyMakeCellVisible(ListHandle theList, Cell theCell);static void			MyResetTypeSelection(void);static void			MyFindNewCellLoc(ListHandle theList, Cell oldCellLoc, Cell &newCellLoc, char keyHit, Boolean moveToExtreme);static void			MyArrowKeyMoveSelection(ListHandle theList, char keyHit, Boolean moveToExtreme);static void			MyArrowKeyExtendSelection(ListHandle theList, char keyHit, Boolean moveToExtreme);// erste selektierte Zelle in der Liste ermittelnstatic Boolean		MyGetFirstSelectedCell(ListHandle theList, Cell &theCell){	SetPt(&theCell, 0, 0);	return LGetSelect(true, &theCell, theList);}// letzte selektierte Zelle in der Liste ermittelnstatic void			MyGetLastSelectedCell(ListHandle theList, Cell &theCell){Cell			aCell;Boolean			moreCellsInList;	if(MyGetFirstSelectedCell(theList, aCell)) {		do {			theCell = aCell;			moreCellsInList = LNextCell(true, true, &aCell, theList);		} while(LGetSelect(true, &aCell, theList));	}}// eine Zelle selektieren, andere Zellen deselektierenstatic void			MySelectOneCell(ListHandle theList, Cell theCell){Cell			nextSelectedCell;	if(MyGetFirstSelectedCell(theList, nextSelectedCell)) {		while(LGetSelect(true, &nextSelectedCell, theList)) {			if(nextSelectedCell.h != theCell.h || nextSelectedCell.v != theCell.v)				LSetSelect(false, nextSelectedCell, theList);			else				LNextCell(true, true, &nextSelectedCell, theList);		}	}	LSetSelect(true, theCell, theList);}// Liste so scrollen, daß eine bestimmte Zelle sichtbar iststatic void			MyMakeCellVisible(ListHandle theList, Cell theCell){Rect			visibleRect;short			dCols, dRows;	visibleRect = (*theList)->visible;	if(!PtInRect(theCell, &visibleRect)) {		dCols = 0;		if(theCell.h > visibleRect.right - 1)			dCols = theCell.h - visibleRect.right + 1;		// move to left		else if(theCell.h < visibleRect.left)			dCols = theCell.h - visibleRect.left;			// move to right		dRows = 0;		if(theCell.v > visibleRect.bottom - 1)			dRows = theCell.v - visibleRect.bottom + 1;		// move up		else			dRows = theCell.v - visibleRect.top;			// move down		biene();		LScroll(dCols, dRows, theList);		pfeil();	}}static Str255			gListNavigateString;		// Aktueller Suchstringstatic short			gTSThresh;					// Ticks bis die Selektion zurückgesetzt wirdstatic long				gLastKeyTime;				// Wann wurde zuletzt was eingebenstatic ListHandle		gLastListHit;				// aktuelle Liste// Variablen zurücksetzenstatic void		MyResetTypeSelection(void){#define kMaxKeyThresh		120		// 120 Ticks = 2 Sekunden	gListNavigateString[0] = 0;				// Navigations String zurücksetzen	gLastListHit = nil;						// keine Liste aktiv	gLastKeyTime = 0;						// bis jetzt wurde keine Taste gedrückt	gTSThresh = 2 * LMGetKeyThresh();		// max. Verzögerung bei der Eingabe	if(gTSThresh > kMaxKeyThresh)		gTSThresh = kMaxKeyThresh;			// max. Verzögerung festsetzen}// Position einer neuen Zelle auf Grund der Cursortasten ermittelnstatic void		MyFindNewCellLoc(ListHandle theList, Cell oldCellLoc, Cell &newCellLoc, char keyHit, Boolean moveToExtreme){short			listRows, listColumns;	listRows = (*theList)->dataBounds.bottom - (*theList)->dataBounds.top - 1;	listColumns = (*theList)->dataBounds.right - (*theList)->dataBounds.left - 1;	newCellLoc = oldCellLoc;	if(moveToExtreme) {		switch(keyHit) {		case chUp:		newCellLoc.v = 0; break;		case chDown:	newCellLoc.v = listRows; break;		case chLeft:	newCellLoc.h = 0; break;		case chRight:	newCellLoc.h = listColumns; break;		}	} else {		switch(keyHit) {		case chUp:		if(oldCellLoc.v != 0) newCellLoc.v = oldCellLoc.v - 1; break;		case chDown:	if(oldCellLoc.v != listRows) newCellLoc.v = oldCellLoc.v + 1; break;		case chLeft:	if(oldCellLoc.h != 0) newCellLoc.h = oldCellLoc.h - 1; break;		case chRight:	if(oldCellLoc.h != listColumns) newCellLoc.h = oldCellLoc.h + 1; break;		}	}}// Selektion mit Cursortasten verschiebenstatic void		MyArrowKeyMoveSelection(ListHandle theList, char keyHit, Boolean moveToExtreme){Cell			currentSelection, newSelection;	if(MyGetFirstSelectedCell(theList, currentSelection)) {		if(keyHit == chRight || keyHit == chDown)			MyGetLastSelectedCell(theList, currentSelection);		MyFindNewCellLoc(theList, currentSelection, newSelection, keyHit, moveToExtreme);	} else {		if(keyHit == chLeft || keyHit == chUp)			return;		if(moveToExtreme)			SetPt(&newSelection, (*theList)->dataBounds.right - (*theList)->dataBounds.left - 1, (*theList)->dataBounds.bottom - (*theList)->dataBounds.top - 1);		else			SetPt(&newSelection, 0,0);	}	MySelectOneCell(theList, newSelection);	MyMakeCellVisible(theList, newSelection);}// Selektion mit Cursortasten erweiternstatic void		MyArrowKeyExtendSelection(ListHandle theList, char keyHit, Boolean moveToExtreme){Cell			currentSelection, newSelection;	if(MyGetFirstSelectedCell(theList, currentSelection)) {		if(keyHit == chRight || keyHit == chDown)			MyGetLastSelectedCell(theList, currentSelection);		while(1) {			MyFindNewCellLoc(theList, currentSelection, newSelection, keyHit, false);			if(!LGetSelect(false, &newSelection, theList))				LSetSelect(true, newSelection, theList);			if(!moveToExtreme) break;				// keine Shift-Command-Selektion => raus			if(currentSelection.h == newSelection.h && currentSelection.v == newSelection.v) break;			currentSelection = newSelection;		}		MyMakeCellVisible(theList, newSelection);	}}/*** *	Taste wurde bei aktivem LDEF-Window gedrückt ***/Boolean			MCLDEF::EventKey(char key, short modifiers){Cell			theCell;Boolean			extreme;	WindowBase::EventKey(key, modifiers);	if(!IList) return false;					// Liste angemeldet (sollte immer sein)	if(modifiers & cmdKey) return false;		// Command-Keys nie behandeln	if(gLastListHit != IList ||		(gTheEvent.when - gLastKeyTime) > gTSThresh ||		(gListNavigateString[0] == (sizeof(gListNavigateString) - 1)))		MyResetTypeSelection();	switch(key) {	case chHome:			extreme = true;			key = chUp;			goto docursor;	case chEnd:			extreme = true;			key = chDown;			goto docursor;	case chUp:	case chDown:	case chLeft:	case chRight:			extreme = (gTheEvent.modifiers & cmdKey) == cmdKey;		docursor:			if(gTheEvent.modifiers & shiftKey)				MyArrowKeyExtendSelection(IList, key, extreme);			else				MyArrowKeyMoveSelection(IList, key, extreme);			break;	case chReturn:	// Return	case chEnter:			SetPt(&theCell, 0, 0);			if(LGetSelect(true, &theCell, IList))	// zumindest eine Zelle selektiert?				OpenObject(theCell);			break;	default:			if(!SearchProcPtr) break;				// keine Suchfunktion für Buchstaben? => raus			gLastListHit = IList;			gLastKeyTime = gTheEvent.when;			gListNavigateString[0]++;			gListNavigateString[gListNavigateString[0]] = key;			SetPt(&theCell, 0, 0);			ListSearchUPP	lsupp = NewListSearchProc(SearchProcPtr);			if(LSearch(gListNavigateString + 1, gListNavigateString[0], lsupp, &theCell, IList)) {				MySelectOneCell(IList, theCell);				MyMakeCellVisible(IList, theCell);			}			DisposeRoutineDescriptor(lsupp);			break;	}	UpdateFlags();	return false;}/*** *	Mausklick in die Liste abfragen ***/void			MCLDEF::Klick(Point p, short clicks, Boolean &onItem){	UNUSED(clicks);	if(!IList) return;	// Drag & Drop Manager Zusatzfunktionen	if(gDrapAndDrop && PtInRect(p, &(*IList)->rView)) {	// Klick in das List-Rechteck?		Cell	theCell = { 0,0 };		Rect	cellRect;		do {			LRect(&cellRect, theCell, IList);	// Rechteck der Zelle ermitteln			if(PtInRect(p, &cellRect)) {		// Klick in eine Zelle?				if(LGetSelect(false, &theCell, IList)) {	// Ist die Zelle selektiert?					if(WaitMouseMoved(gTheEvent.where)) {	// Draggen anfangen?						onItem = true;			// das Draggen geht los!						return;					// und ab…					}				}				break;			}		} while(LNextCell(true, true, &theCell, IList));	// nächste Zelle suchen	}	// List Manager normal aufrufen	if(LClick(p, gTheEvent.modifiers, IList))		OpenObject(LLastClick(IList));	// Infozeile updaten	UpdateFlags();}