/*** *	generelles Window mit zwei Scrollbars * *	©1994 Mastercast, Markus Fritze ***/#include "WindowScroll.h"#include "DialogBase.h"#include <ToolUtils.h>#include <ControlDefinitions.h>/*** *	Window šffnen ***/void			WindowScroll::Open(Rect &r, StringPtr theName, long width, long height, long xscroll, long yscroll){	viewWidth = width;	viewHeight = height;	viewXScroll = xscroll;	viewYScroll = yscroll;	// Fenster šffnen	WindowBase::Open(&r, theName, false, kHasCloseBoxMask|kHasZoomBoxMask|kHasGrowBoxMask|kHasDocumentTitlebarMask, 0L,(WindowRefX)-1L);	SetPt(&MaxSize, viewWidth + 16, viewHeight + 16);	vScroller = oNewControl((WindowPtr)WindRef, &r, "\p", true, 0, 0, height - (r.bottom - r.top), kControlScrollBarProc, (long)this);	hScroller = oNewControl((WindowPtr)WindRef, &r, "\p", true, 0, 0, width - (r.right - r.left), kControlScrollBarProc, (long)this);	Adjust();}/*** *	Window wird geschlossen, Daten freigeben ***/				WindowScroll::~WindowScroll(){	if(vScroller)		oDisposeControl(vScroller);	if(hScroller)		oDisposeControl(hScroller);}/*** *	sichtbarer Windowbereich ***/void			WindowScroll::GetVisRect(Rect &r){	r = ((WindowPtr)WindRef)->portRect;			// Window-Rechteck kopieren	r.right -= (ScrollBar_Size - 1);	r.bottom -= (ScrollBar_Size - 1);}/*** *	Window updaten ***/void			WindowScroll::Draw(void){	oDrawControls((WindowPtr)WindRef);			// Slider zeichnen	WindowBase::DrawGrowIcon(WindRef);			// damit der Sizer zuerst mal dargestellt wird (der Redraw kann ja ein Weilchen dauern)	Rect		visRect;	GetVisRect(visRect);	RgnHandle	curClip = NewRgn();	GetClip(curClip);	::ClipRect(&visRect);	Draw(oGetControlValue(hScroller), oGetControlValue(vScroller), visRect);	SetClip(curClip);}/*** * ***/void			WindowScroll::Draw(long xOffset, long yOffset, Rect visRect){	UNUSED(xOffset); UNUSED(yOffset); UNUSED(visRect);}/*** *	Window soll vergrš§ert/verkleinert werden ***/#include "DoEvent.h"void			WindowScroll::EventGrow(void){long		newSize;Rect		size;	SetPort((GrafPtr)WindRef);	topLeft(size) = MinSize;	botRight(size) = MaxSize;	if((newSize = GrowWindow((WindowPtr)WindRef, gTheEvent.where, &size)) != 0L) {	// Grš§e verŠndert?		InvalRect(&(((WindowPtr)WindRef)->portRect));						// Window KOMPLETT neuzeichnen		SetSize(LoWord(newSize), HiWord(newSize));	}}/*** *	Klick in die Zoom-Box ***/#include "ZoomCode.h"void			WindowScroll::EventZoom(short partCode){	Rect	saveRect = (*((WindowPeek)WindRef)->strucRgn)->rgnBBox;			// aktuelle Windowgrš§e merken	ZoomTheWindow((WindowPeek)WindRef, partCode, CalcIdealDocumentSizeProc);// Window zoomen	if(!EqualRect(&saveRect, &(*((WindowPeek)WindRef)->strucRgn)->rgnBBox)) {// hat sich die Grš§e verŠndert?		InvalRect(&(((WindowPtr)WindRef)->portRect));						// Window KOMPLETT neuzeichnen		Adjust();															// dann Adjust() aufrufen	}}/*** *	Window ist aktiv bzw. inaktiv geworden ***/void			WindowScroll::EventActivate(Boolean flag){	WindowBase::EventActivate(flag);	oHiliteControl(hScroller, flag ? kCntlActive : kCntlInactive);	oHiliteControl(vScroller, flag ? kCntlActive : kCntlInactive);	// Sizer updaten	WindowBase::DrawGrowIcon(WindRef);}/*** *	Window Grš§e anpassen ***/void			WindowScroll::Adjust(void){long		newmax;	WindowBase::Adjust();	Rect		r = ((WindowPtr)WindRef)->portRect;	// Window-Rechteck kopieren	// vertikalen Scrollbar anpassen	oHideControl(vScroller);	oMoveControl(vScroller, r.right - (ScrollBar_Size - 1), -1);	oSizeControl(vScroller, ScrollBar_Size, (r.bottom - r.top) - 13);	newmax = viewHeight - (r.bottom - r.top) + (ScrollBar_Size - 1);	if(newmax <= 0)		newmax = 0L;	oSetControlMaximum(vScroller, newmax);	oShowControl(vScroller);	// horizontalen Scrollbar anpassen	oHideControl(hScroller);	oMoveControl(hScroller, -1, r.bottom - (ScrollBar_Size - 1));	oSizeControl(hScroller, (r.right - r.left) - 13, ScrollBar_Size);	newmax = viewWidth - (r.right - r.left) + (ScrollBar_Size - 1);	if(newmax <= 0)		newmax = 0L;	oSetControlMaximum(hScroller, newmax);	oShowControl(hScroller);	// Sizer updaten	WindowBase::DrawGrowIcon(WindRef);}/*** *	beide Slider versetzen. Window-Redraw sofort machen. ***/void		WindowScroll::SetDeltaSlider(long xd, long yd){ControlHandle	ch = hScroller;ControlHandle	cv = vScroller;long			x = oGetControlValue(ch);	// temp.Sliderwertlong			y = oGetControlValue(cv);	oSetControlValue(ch,x + xd);		// neuen H-Sliderwert setzen	oSetControlValue(cv,y + yd);		// neuen V-Sliderwert setzen	x = oGetControlValue(ch) - x; y = oGetControlValue(cv) - y;	if(x == 0L && y == 0L)				// Slider nicht verŠndert => raus		return;	RgnHandle	theRgn = NewRgn();	Rect		r;	GetVisRect(r);	ScrollRect(&r, -x, -y, theRgn);		// Window scrollen	InvalRgn(theRgn);					// Windowregion neu zeichnen	DisposeRgn(theRgn);	Draw();}/*** *	Slider wurde bewegt (Funktion wird von TrackControl aufgerufen) ***/pascal void	WindowScroll::ScrollProc(ControlHandle c, short thePart){WindowScroll	*thisWindow = (WindowScroll*)oGetControlReference(c);Boolean			flag = thisWindow->hScroller == c;	// true, wenn horizontaler Sliderlong			offset	= 0;		// Scrolloffset = 0 (nicht gescrollt)long			xd,yd;Rect			r;	switch(thePart) {		// angeklicktes Control-Element	case	kControlPageDownPart:	case	kControlPageUpPart:			thisWindow->GetVisRect(r);			if (flag)				offset = r.right - r.left;			else				offset = r.bottom - r.top;			if (thePart == kControlPageUpPart) offset = - offset;			break;	case	kControlDownButtonPart:	case	kControlUpButtonPart:			offset = (flag)?thisWindow->viewXScroll:thisWindow->viewYScroll;			if (thePart == kControlUpButtonPart) offset = - offset;			break;	}	if (flag) {							// Horizontaler Slider:		xd = offset;		yd = 0;	} else {							// Vertikaler Slider:		xd = 0;		yd = offset;	}	thisWindow->SetDeltaSlider(xd, yd);	// Slider versetzen}/*** *	Mausklick in das Window abfragen ***/void			WindowScroll::Klick(Point thePoint, short clicks, Boolean &onItem){short			thePart;ControlHandle	c;	UNUSED(clicks); UNUSED(onItem);	thePart = oFindControl(thePoint, (WindowPtr)WindRef, &c);	if((c != hScroller && c != vScroller) || !c)		// kein Control vom Window?		return;											// => raus	if(thePart == 0) return;							// nix im Control angeklickt => raus	if(oGetControlMaximum(c) == 0) return;				// Control nicht aktiv (Maximaler Wert = 0) => raus	if(thePart == kControlIndicatorPart) {							// Slider direkt bewegen?		long	offset = TrackThumb(thePoint, c, nil);	// Thumb bewegen		long	xd,yd;		if (offset) {					// Thumb bewegt?			if (hScroller == c) {		// Horizontaler Slider:				xd = offset;				yd = 0;			} else {					// Vertikaler Slider:				xd = 0;				yd = offset;			}			SetDeltaSlider(xd, yd);		// Slider versetzen		}	} else {		ControlActionUPP	cap = NewControlActionProc(ScrollProc);		oTrackControl(c, thePoint, cap);		DisposeRoutineDescriptor(cap);	}}