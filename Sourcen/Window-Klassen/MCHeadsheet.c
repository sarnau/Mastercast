/*** *	Headsheet ***/#include "MCHeadsheet.h"#include "mc_db.h"#include "MCWindTools.h"#include "MCInfo.h"#include "MCLayout.h"#include "DoEvent.h"#include "GlobalLib.h"#include "ScrapBase.h"#include "PrintSedcard.h"#include "PrintPict.h"#include <string.h>#include <LFileStream.h>#include <Folders.h>#include <StandardFile.h>#include <LowMem.h>/*** *	Headsheet Fenster für beliebige Modelle erzeugen ***/void			MCHeadsheet::Create(short count, const LDEFHeadsheetStruct *hsp){extern short		PLayoutWidth;			// Gesamtbreite und -höhe eines Bildesextern short		PLayoutHeight;	MCHeadsheet		*mh = new MCHeadsheet;	mh->Open(PLayoutHeight,PLayoutWidth, 100,100, 4004, nil, count, sizeof(LDEFHeadsheetStruct), (Ptr)hsp, SearchFunk, wcTracking|wcReceiveDrop);}/*** *	Ordner ermitteln, in dem das Item gedroppt wurde ***/OSErr GetDropLocationDirectory(AEDesc *dropLocation, long *directoryID, short *volumeID){	OSErr			result;	AEDesc			targetDescriptor;	/* 'fss ' descriptor for target directory */	FSSpec			targetLocation;		/* FSSpec for target directory */	CInfoPBRec		getTargetInfo;		/* paramBlock to get targetDirID */		/* Coerce the 'alis' descriptor to a 'fss ' descriptor */	result = AECoerceDesc(dropLocation, typeFSS, &targetDescriptor);	if (result != noErr)		return result; 		/* Extract the FSSpec from targetDescriptor */	BlockMove((Ptr)(*targetDescriptor.dataHandle), (Ptr)&targetLocation, sizeof(FSSpec));		result = AEDisposeDesc(&targetDescriptor);	if (result != noErr)		return result;		/* Use PBGetCatInfo to get the directoryID of the target directory */	/* from the FSSpec */		getTargetInfo.dirInfo.ioNamePtr = targetLocation.name;	getTargetInfo.dirInfo.ioVRefNum = targetLocation.vRefNum;	getTargetInfo.dirInfo.ioFDirIndex = 0;	getTargetInfo.dirInfo.ioDrDirID = targetLocation.parID;		result = PBGetCatInfoSync(&getTargetInfo);	if (result != noErr)		return result;		/* return directory ID and volume reference number */		*directoryID = getTargetInfo.dirInfo.ioDrDirID;	*volumeID = targetLocation.vRefNum;		return result;}/* *	DropLocationIsFinderTrash * *	Returns true if the given dropLocation AEDesc is a descriptor of the Finder's Trash. */Boolean DropLocationIsFinderTrash(AEDesc *dropLocation){	OSErr			result;	AEDesc			dropSpec;	FSSpec			*theSpec;	CInfoPBRec		thePB;	short			trashVRefNum;	long			trashDirID;	//	//	Coerce the dropLocation descriptor to an FSSpec. If there's no dropLocation or	//	it can't be coerced into an FSSpec, then it couldn't have been the Trash.	//	if ((dropLocation->descriptorType != typeNull) &&		(AECoerceDesc(dropLocation, typeFSS, &dropSpec) == noErr)) {		HLock(dropSpec.dataHandle);		theSpec = (FSSpec *) *dropSpec.dataHandle;		//		//	Get the directory ID of the given dropLocation object.		//		thePB.dirInfo.ioCompletion = 0L;		thePB.dirInfo.ioNamePtr = (StringPtr) &theSpec->name;		thePB.dirInfo.ioVRefNum = theSpec->vRefNum;		thePB.dirInfo.ioFDirIndex = 0;		thePB.dirInfo.ioDrDirID = theSpec->parID;		result = PBGetCatInfo(&thePB, false);		HUnlock(dropSpec.dataHandle);		AEDisposeDesc(&dropSpec);		if (result != noErr)			return(false);		//		//	If the result is not a directory, it must not be the Trash.		//		if (!(thePB.dirInfo.ioFlAttrib & (1 << 4)))			return(false);		//		//	Get information about the Trash folder.		//		FindFolder(theSpec->vRefNum, kTrashFolderType, kCreateFolder, &trashVRefNum, &trashDirID);		//		//	If the directory ID of the dropLocation object is the same as the directory ID		//	returned by FindFolder, then the drop must have occurred into the Trash.		//		if (thePB.dirInfo.ioDrDirID == trashDirID)			return(true);	}	return(false);}/*** *	Ist die aktuelle Mausposition in der content Region des Windows? ***/Boolean			MouseIsInContentRgn(DragReference theDrag, WindowPtr theWindow){Point			mousePt;	GetDragMouse(theDrag, &mousePt, nil);	return PtInRgn(mousePt, ((WindowPeek)theWindow)->contRgn);}/*** *	Kann das Item akzeptiert werden? ***/Boolean			DragItemsAreAcceptable(DragReference theDrag){OSErr			iErr;unsigned short	totalItems;ItemReference	itemRef;Boolean			acceptableFlag = false;	iErr = CountDragItems(theDrag, &totalItems);	// Wieviele Items wurden gedraggt?	if(iErr == noErr) {		for(int i=1; i<=totalItems; i++) {			iErr = GetDragItemReferenceNumber(theDrag, i, &itemRef);			if(iErr) break;							// hat nicht geklappt => raus				// wir können nur unsere eigenen Drags empfangen: (Flavor = Creator)			FlavorFlags	currFlavorFlags;			iErr = GetFlavorFlags(theDrag, itemRef, 'intr', &currFlavorFlags);			if(iErr) break;							// hat nicht geklappt => raus				acceptableFlag = true;		}	}	return acceptableFlag;}/*** *	Befindet sich der Drag im Source-Window? Ein Drag ist in mastercast dann sinnlos. ***/Boolean			DragIsNotInSourceWindow(DragReference theDrag){DragAttributes	currDragFlags;	GetDragAttributes(theDrag, &currDragFlags);	return ((currDragFlags & kDragInsideSenderWindow) == 0);}/*** *	Tracking-Feedback beim Draggen ***/OSErr			MCHeadsheet::STracking(short theMessage, DragReference theDrag){Boolean			mouseInContentFlag;OSErr			iErr = noErr;static Boolean	acceptableDragFlag;static Boolean	windowIsHilightedFlag;	switch(theMessage) {	case kDragTrackingEnterHandler:			acceptableDragFlag = DragItemsAreAcceptable(theDrag);			windowIsHilightedFlag = false;			if(!acceptableDragFlag)				// Drag wird nicht akzeptiert?				iErr = dragNotAcceptedErr;		// das wird gemeldet (Petze, Petze :-)			break;	case kDragTrackingEnterWindow:	case kDragTrackingInWindow:	case kDragTrackingLeaveWindow:			if(acceptableDragFlag && DragIsNotInSourceWindow(theDrag)) {	// Drag ist i.O.?				if(theMessage == kDragTrackingLeaveWindow)					mouseInContentFlag = false;				else					mouseInContentFlag = MouseIsInContentRgn(theDrag, (WindowPtr)GetWindow());				if(mouseInContentFlag && !windowIsHilightedFlag) {					ClipRect(&((WindowPtr)GetWindow())->portRect);					RgnHandle	tempRgn = NewRgn();					Rect		tempRect = ((WindowPtr)GetWindow())->portRect;					tempRect.top += InfoLineHeight;					// Infozeile berücksichtigen					tempRect.right -= (ScrollBar_Size - 1); tempRect.bottom -= (ScrollBar_Size - 1);	// Scrollbars abziehen					RectRgn(tempRgn, &tempRect);					if(ShowDragHilite(theDrag, tempRgn, true) == noErr)						windowIsHilightedFlag = true;					DisposeRgn(tempRgn);				} else if(!mouseInContentFlag && windowIsHilightedFlag) {					ClipRect(&((WindowPtr)GetWindow())->portRect);					if(HideDragHilite(theDrag) == noErr)						windowIsHilightedFlag = true;				}			}	case kDragTrackingLeaveHandler:			break;	default:			iErr = paramErr;	}	return iErr;}/*** *	gedraggte Items empfangen ***/OSErr			MCHeadsheet::SReceiveDrop(DragReference theDrag){OSErr			iErr = noErr;	if(!DragItemsAreAcceptable(theDrag) ||			// Items zu akzeptieren?		!MouseIsInContentRgn(theDrag, (WindowPtr)GetWindow()) ||	// Maus innerhalb des Fensters?		!DragIsNotInSourceWindow(theDrag))			// und nicht im Startfenster (der Drag wäre sinnlos)		return dragNotAcceptedErr;	unsigned short	totalItems;	iErr = CountDragItems(theDrag, &totalItems);	// Wieviele Items wurden gedraggt?	if(iErr != noErr) return iErr;	LDEFHeadsheetStruct	*hsp = (LDEFHeadsheetStruct*)NewPtrClear(sizeof(LDEFHeadsheetStruct) * totalItems);	for(int i=1; i<=totalItems; i++) {		ItemReference	itemRef;		iErr = GetDragItemReferenceNumber(theDrag, i, &itemRef);		if(iErr) continue;							// hat nicht geklappt => weiter		// Drag-Item holen		Size	dataSize = sizeof(LDEFHeadsheetStruct);		iErr = GetFlavorData(theDrag, itemRef, 'intr', hsp + (i -1), &dataSize, 0L);		if(iErr) continue;							// hat nicht geklappt => weiter	}	AddData(totalItems, (Ptr)hsp);					// Daten dem Fenster zufügen	DisposePtr((Ptr)hsp);	return iErr;}/*** *	Headsheet-Daten dem Finder zur Verfügung stellen ***/OSErr			MCHeadsheet::SSendData(FlavorType theFlavor, ItemReference theItem, DragReference theDrag){OSErr			iErr;	if(theFlavor != gSignature)			// die eigene Signatur?		return badDragFlavorErr;	// Zielort des Drags ermitteln	AEDesc		dropLocation;	iErr = GetDropLocation(theDrag, &dropLocation);	if(iErr) return iErr;	// ein null-Descriptor? Dat war wohl nix…	if(dropLocation.descriptorType == typeNull) {		AEDisposeDesc(&dropLocation);		return noErr;	}	FSSpec		locationSpec;	long		dirID;	short		vRefNum;	iErr = GetDropLocationDirectory(&dropLocation, &dirID, &vRefNum);	if(iErr) return iErr;			// einen Filenamen ermitteln, der noch nicht benutzt wurde	// 1. Versuch: Defaultfilename aus der Resource	// 2. Versuch: Defaultfilename + " " + 1	// 3. Versuch: Defaultfilename + " " + 2	// n. Versuch: Defaultfilename + " " + n-1	long		l = 1;	Str15		tempStr;	tempStr[0] = 0;	do {		Str255		fileName;		GetIndString(fileName, 900, 1);	// Filenamen lesen		if(tempStr[0]) {			ConcatPString(fileName, "\p ");			ConcatPString(fileName, tempStr);		}		iErr = FSMakeFSSpec(vRefNum, dirID, fileName, &locationSpec);	// Testen, ob die Datei bereits existiert		NumToString(l++, tempStr);	} while(iErr == noErr);	// Datei erzeugen	short		count;	LDEFHeadsheetStruct	*data = (LDEFHeadsheetStruct*)GetSelectedData(count);		// Daten im Headsheet Window holen	iErr = noErr;	if(count) {		// Ptr auf ModellStruct in Modell-IDs wandeln		for(int i=0; i<count; i++)			data[i].ms = (ModellStruct*)data[i].ms->Id;		try {			LFileStream		theFile(locationSpec);			try {				theFile.CreateNewDataFile(gSignature, gSignature, smSystemScript);			}			catch(PP_PowerPlant::ExceptionCode inErr) {			} 			theFile.OpenDataFork(fsCurPerm);			theFile.WriteDataFork(data, count * sizeof(LDEFHeadsheetStruct));			iErr = noErr;		}		catch(PP_PowerPlant::ExceptionCode inErr) {			iErr = inErr;		}	}	DisposePtr((Ptr)data);	if(iErr) return iErr;	iErr = SetDragItemFlavorData(theDrag, theItem, gSignature, (Ptr)&locationSpec, sizeof(locationSpec), nil);	return iErr;}/*** *	Draggen eines (oder mehrerer) Objekte starten ***/OSErr			MCHeadsheet::SStartDrag(EventRecord *theEvent){DragReference		theDrag;RgnHandle			dragRegion;	ThrowIfOSErr_(NewDrag(&theDrag));		// Drag starten	// Flavor hinzufügen	LDEFHeadsheetStruct	*ms;	short		index, count;	ms = (LDEFHeadsheetStruct*)GetSelectedData(count);	for(index = 1; count-- > 0; index++, ms++) {		// Items innerhalb von Mastercast		ThrowIfOSErr_(AddDragItemFlavor(theDrag, index, 'intr', ms, sizeof(LDEFHeadsheetStruct), flavorSenderOnly));	}	DisposePtr((Ptr)ms);	// _ein_ mastercast Headsheet-File	PromiseHFSFlavor	hfsFlavor;	hfsFlavor.fileType = gSignature;	hfsFlavor.fileCreator = gSignature;	hfsFlavor.fdFlags = 0;	hfsFlavor.promisedFlavor = gSignature;	ThrowIfOSErr_(AddDragItemFlavor(theDrag, 1, flavorTypePromiseHFS, &hfsFlavor, sizeof(hfsFlavor), flavorNotSaved));	ThrowIfOSErr_(AddDragItemFlavor(theDrag, 1, gSignature, nil, 0L, 0));	DragSendDataUPP	dsd = NewDragSendDataProc(MySendDataProc);	SetDragSendProc(theDrag, dsd, this);	// Region für alle selektierten Daten erzeugen	dragRegion = SelectedDataRgn();	// Region in umrahmte Rechtecke wandeln	RgnHandle	theRgn = NewRgn();	CopyRgn(dragRegion, theRgn);	InsetRgn(theRgn, 1, 1);	DiffRgn(dragRegion, theRgn, dragRegion);	DisposeRgn(theRgn);	SetDragItemBounds(theDrag, 1, &(*dragRegion)->rgnBBox);	// alle Objekte werden umschlossen	// Drag durchführen	OSErr	iErr = TrackDrag(theDrag, theEvent, dragRegion);	// Drag beenden	DisposeRgn(dragRegion);		if(iErr == noErr) {				// Drag hat geklappt		DragAttributes	currDragFlags;		GetDragAttributes(theDrag, &currDragFlags);		short			mouseUpModifiers;		GetDragModifiers(theDrag, nil, nil, &mouseUpModifiers);		if((currDragFlags & kDragInsideSenderApplication) != 0) {// im gleichen Programm?			if((mouseUpModifiers & optionKey) == 0) {			// wurde Option beim Beenden des Drag gedrückt, so werden die Daten verschoben				Ptr		pp = GetSelectedData(count);				RemoveData(count, pp);		// Löschen der Daten				DisposePtr((Ptr)pp);			}		} else {	// außerhalb des eigenen Programms			AEDesc		dropLocation;			GetDropLocation(theDrag, &dropLocation);			if(DropLocationIsFinderTrash(&dropLocation)) {		// in den Papierkorb?				Ptr		pp = GetSelectedData(count);				RemoveData(count, pp);		// Löschen der Daten				DisposePtr((Ptr)pp);			}			AEDisposeDesc(&dropLocation);		}	}		DisposeRoutineDescriptor(dsd);		ThrowIfOSErr_(DisposeDrag(theDrag));	return noErr;}/*** *	Liste der selektierten Modelle öffnen ***/void		MCHeadsheet::OpenList(Boolean infoFlag){LDEFHeadsheetStruct	*ms;short		index, count;	ms = (LDEFHeadsheetStruct*)GetSelectedData(count);	if(!ms) return;			// keine Modelle selektiert => raus	for(index = 0; index < count; index++) {		if(infoFlag)			MCLayout::Create(ms[index].ms->Id);		else			MCInfo::Create(ms[index].ms->Id);	}	DisposePtr((Ptr)ms);}/*** *	Menüpunkt aufgerufen ***/Boolean		MCHeadsheet::DoCommand(long cmd){short		count;	switch(cmd) {	case cPrint:			LDEFHeadsheetStruct	*psp = (LDEFHeadsheetStruct*)GetSelectedData(count);			Boolean		cancel = false;			Boolean		psedcard = DialogBase::Do(141) == 1;			for(int i=0; count > 0 && !cancel; count--, i++) {				if(psedcard) {					PrintPict	ppict(psp[i].ms->Id, psp[i].pic, i == 0, cancel);				} else {					PrintSedcard	psed(psp[i].ms->Id, i == 0, cancel);				}			}			DisposePtr((Ptr)psp);			break;	case cOpenHeadsheet:			LDEFHeadsheetStruct	*hsp = (LDEFHeadsheetStruct*)GetSelectedData(count);			MCHeadsheet::Create(count, hsp);			DisposePtr((Ptr)hsp);			break;	case cOpenPLayout:			OpenList(true);			break;	case cOpenwtPInfo:			OpenList(false);			break;	case cSaveAs:			Str255				prompt;			StandardFileReply	reply;			::GetIndString(prompt, 4000, 10);	// "Speichern unter:"			::GetIndString(reply.sfFile.name, 4000, 12);	// "Ohne Titel"			Point	p = { -1, -1 };				// Defaultposition			::StandardPutFile(prompt, reply.sfFile.name, &reply);			if(!reply.sfGood) break;			// User will nicht speichern =>			LDEFHeadsheetStruct	*data = (LDEFHeadsheetStruct*)GetData(count);		// Daten im Headsheet Window holen			if(count) {				// Ptr auf ModellStruct in Modell-IDs wandeln				for(int i=0; i<count; i++)					data[i].ms = (ModellStruct*)data[i].ms->Id;				LFileStream		theFile(reply.sfFile);				if(!reply.sfReplacing)			// Datei nicht ersetzen (d.h. Datei neu erzeugen)					theFile.CreateNewDataFile(gSignature, gSignature, smSystemScript);				theFile.OpenDataFork(fsWrPerm);				theFile.WriteDataFork(data, count * sizeof(LDEFHeadsheetStruct));			}			DisposePtr((Ptr)data);			break;	case cCut:	case cCopy:			{			theScrap.ClrScrap();			LDEFHeadsheetStruct	*bs = (LDEFHeadsheetStruct*)GetSelectedData(count);			for(int i=0; count > 0; count--, i++)				theScrap.AddScrap(bs[i].ms, bs[i].pic);			DisposePtr((Ptr)bs);			}			if(cmd == cCopy) break;	// Copy löscht nicht => raus	case cClear:			{			Ptr		bs = GetSelectedData(count);			RemoveData(count, bs);			DisposePtr(bs);			break;			}	case cPaste:			{			ScrapStruct		**sd = theScrap.GetScrap();			HLock((Handle)sd);			AddData(theScrap.GetScrapSize(), (Ptr)*sd);			HUnlock((Handle)sd);			break;			}	default:			return MCLDEF::DoCommand(cmd);	}	return true;}/*** *	Befehle bei Bedarf enablen ***/void		MCHeadsheet::GetCommandStatus(long cmd, Boolean &enabled, short &markChar, Str255 &name){	switch(cmd) {	case cPrint:			if(CountSelectedData() > 0)				enabled = true;			break;	case cSaveAs:			enabled = CountData() >= 1;			break;	case cOpenHeadsheet:	case cOpenPLayout:	case cOpenwtPInfo:	// nur enablen, wenn mindestens ein Modell selektiert ist	case cCut:	case cCopy:	case cClear:			enabled = CountSelectedData() >= 1;			break;	case cPaste:			enabled = theScrap.GetScrapSize() > 0;			break;	default:			MCLDEF::GetCommandStatus(cmd, enabled, markChar, name);	}}/*** *	LDEF Funktion für den Browser ***/void			MCHeadsheet::LDEFCallback(short lMessage, Boolean lSelect, Rect *lRect, Cell lCell, short lDataOffset, short lDataLen, ListHandle lHandle){Rect			iRect;#define BrowseFrame			3		// Rahmenbreite#define BrowseTextHeight	12#define BrowseText2Height	12short			x, y;RgnHandle		theRgn1, theRgn2;	UNUSED(lCell); UNUSED(lDataLen);	// Daten des aktuellen Modells	LDEFHeadsheetStruct	dp = *(LDEFHeadsheetStruct*)((*(*lHandle)->cells) + lDataOffset);	// iRect enthält nach den folgenden Zeilen das maßstabsgetreu verkleinerte Bild, daß genau in das	// vorgegebene Rechteck paßt und zudem dortdrin zentriert ist.	x = CellSize.h - 2*BrowseFrame;				// max. Bildbreite abzgl. Rahmen um das Bild	y = CellSize.v - 2*BrowseFrame - BrowseText2Height - BrowseTextHeight;	// max. Bildhöhe	SetRect(&iRect, 0,0,x,y);	GetPictRect(dp.ms->Id, dp.pic, iRect, false, true);	// Bild auf den Rahmen skalieren	iRect.left = (x - iRect.right) >> 1;			// Bild zentrieren	iRect.top = BrowseTextHeight + ((y - iRect.bottom) >> 1);	iRect.right += iRect.left;	iRect.bottom += iRect.top;	OffsetRect(&iRect, /*h +*/ BrowseFrame, /*v +*/ BrowseFrame);	// um den Rahmen verschieben	OffsetRect(&iRect, lRect->left, lRect->top);	// und um den Zellen-Offset	if(lMessage == lDrawMsg) {		theRgn1 = NewRgn(); RectRgn(theRgn1, lRect);		InsetRect(&iRect, -1, -1);		theRgn2 = NewRgn(); RectRgn(theRgn2, &iRect);		InsetRect(&iRect, 1, 1);		DiffRgn(theRgn1, theRgn2, theRgn1);		DisposeRgn(theRgn2);		EraseRgn(theRgn1);									// Hiermit löschen wir _nur_ das Rechteck UM das Bild herum		DisposeRgn(theRgn1);								// => es flackert nicht!		// Namen des Modells über dem Bild ausgeben		short	fh = SetFont(4000);		Rect		tRect;		SetRect(&tRect, 0,0, CellSize.h - BrowseFrame, BrowseTextHeight);		OffsetRect(&tRect, lRect->left, lRect->top);		TETextBox(dp.ms->Modellname, strlen(dp.ms->Modellname), &tRect, teJustCenter);		// Die Agentur des Modells unter dem Bild ausgeben		const char	*s = AList?AList->FindId(dp.ms->Agentur)->GetName():"";		if(s) {			SetRect(&tRect, 0,CellSize.v - BrowseFrame - BrowseText2Height + 2, CellSize.h - BrowseFrame,CellSize.v - BrowseFrame);			OffsetRect(&tRect, lRect->left, lRect->top);			SetFont(4001);			TETextBox(s, strlen(s), &tRect, teJustCenter);		}		ForeColor(blackColor);		DrawPic(dp.ms->Id, dp.pic, iRect, true, false);		// Bild zentriert zeichnen		if(!lSelect) return;	}	theRgn1 = NewRgn(); RectRgn(theRgn1, lRect);	theRgn2 = NewRgn(); RectRgn(theRgn2, &iRect);	DiffRgn(theRgn1, theRgn2, theRgn1);	DisposeRgn(theRgn2);	LMSetHiliteMode(~(1<<hiliteBit) & LMGetHiliteMode());	// hiermit wird unter Color QuickDraw bei InvertRect() nicht invertiert, sondern mit der Hilite Color (Kontrollfeld) selektiert	InvertRgn(theRgn1);										// Rechteck um das Bild herum hiliten	DisposeRgn(theRgn1);}/*** *	Suchfunktion in ModellStruct* Liste ***/pascal short	MCHeadsheet::SearchFunk(Ptr cellDataPtr, Ptr searchDataPtr, short cellDataLen, short searchDataLen){	if(cellDataLen != sizeof(LDEFHeadsheetStruct)) return false;	// Liste fehlerhaft!	LDEFHeadsheetStruct	ms = *(LDEFHeadsheetStruct*)cellDataPtr;	if(IUMagIDString(ms.ms->Modellname, searchDataPtr, strlen(ms.ms->Modellname), searchDataLen) == 0)		return false;						// Einträge sind gleich!	if(IUMagString(ms.ms->Modellname, searchDataPtr, strlen(ms.ms->Modellname), searchDataLen) == 1)		return false;						// gesuchter Eintrag liegt hinter dem aktuellen Eintrag	return true;}/*** *	gewählte Objekte öffnen ***/void		MCHeadsheet::OpenObject(Cell theCell){	UNUSED(theCell);	OpenList((gTheEvent.modifiers & optionKey) == optionKey);}/*** *	Zwei Elemente miteinander vergleichen * *	-1 = a < b *	 0 = a = b *	+1 = a > b ***/short		MCHeadsheet::Compare(Ptr a, Ptr b){LDEFHeadsheetStruct	*ma, *mb;	ma = (LDEFHeadsheetStruct*)a;	mb = (LDEFHeadsheetStruct*)b;	if(ma->ms != mb->ms) {		short	cmpFlag = strcmp(ma->ms->Modellname, mb->ms->Modellname);		if(cmpFlag) return cmpFlag;		// Namen sind ungleich => Vergleich ist eindeutig		return ma->ms->Id - mb->ms->Id;	// ansonsten: nach IDs vergleichen	} else		return ma->pic - mb->pic;}