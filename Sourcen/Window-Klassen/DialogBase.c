/*** *	Dialogbox-Klasse * *	©1994 Dekotec Info-Sys, Markus Fritze ***/#include "DialogBase.h"#include "GlobalLib.h"#include "DoEvent.h"#include <Dialogs.h>#include <Sound.h>/*** *	Aus einem DialogPtr den Ptr auf die DialogBase-Klasse ermitteln ***/DialogBase		*DialogBase::Class(DialogPtr theDialog){	return (DialogBase*)WindowBase::Class((WindowPtr)theDialog);}/*** *	ein Item aus der ObjectInfo suchen ***/DialogItem		*DialogBase::GetObject(short item){	if(!ObjectInfo) return nil;	// Mit dieser Schleife klappern wir alle Objekte ab…	DObjItemPtr	op = (*ObjectInfo)->items;	for(int count = (*ObjectInfo)->count; count > 0; count--, op++) {		if(op->item != item)					// Objekt gefunden?			continue;							// nein => weitersuchen		DItems[op->type]->itemObject = op;		return DItems[op->type];				// Adresse der Klasse zurückgeben	}	return nil;}/*** *	Item-Redraw durchführen ***/void			DialogBase::RedrawItem(short item, Boolean erase){Rect		r;GrafPtr		savePort;RgnHandle	rgn;	GetPort(&savePort);	SetGraphicPort();	rgn = NewRgn();	GetItemRect(item, &r);	if(erase)		EraseRect(&r);	GetClip(rgn);					// Clipping retten	ClipRect(&r);					// und nur auf das Objekt clippen	InvalRect(&r);					// und Update…#if 1	Handle		iHandle = GetCH(item);	switch(GetItemType(item) & ~itemDisable) {	case ctrlItem+btnCtrl:	case ctrlItem+chkCtrl:	// Button-Controls?	case ctrlItem+radCtrl:	case ctrlItem+resCtrl:			Draw1Control((ControlHandle)iHandle);			break;	case statText:	case editText:			Str255		textStr;			GetDialogItemText(iHandle, textStr);			SetDialogItemText(iHandle, textStr);	// SetDialogItemText() zeichnet den Text gleich neu			break;	case iconItem:	case picItem:			DrawDialog(GetDialogPtr());	// gesamten Dialog zeichnen			break;	case userItem:			if(ObjectInfo) {	// Objekte in DObj Resource deklariert?				// Mit dieser Schleife klappern wir alle Objekte ab und zeichnen sie…				DObjItemPtr	op = (*ObjectInfo)->items;				int count;				for(count = (*ObjectInfo)->count; count > 0; count--, op++) {					if(op->item != item)						continue;					DItems[op->type]->itemObject = op;					DItems[op->type]->Draw();	// Objekt gefunden => neu zeichnen					break;				}				if(count == 0)					DrawDialog(GetDialogPtr());	// gesamten Dialog zeichnen			} else				DrawDialog(GetDialogPtr());	// gesamten Dialog zeichnen			break;	}#else	DrawDialog(GetDialogPtr());		// und zeichnen#endif	ValidRect(&r);					// und weitere Update verhindern	SetClip(rgn);	DisposeRgn(rgn);	SetPort(savePort);}/*	*//*** *	Item sichtbar bzw. unsichtbar machen ***/void			DialogBase::HideItem(short item){	HideDialogItem(GetDialogPtr(), item);}/*** *	Item sichtbar bzw. unsichtbar machen ***/void			DialogBase::ShowItem(short item){	ShowDialogItem(GetDialogPtr(), item);}/*** *	String in einem Textfeld setzen ***/void			DialogBase::SetDialogText(short item, ConstStr255Param s){	SetDialogItemText(GetCH(item),s);}/*** *	String aus einem Textfeld holen ***/void			DialogBase::GetDialogText(short item, StringPtr s){	GetDialogItemText(GetCH(item), s);}/*** *	Integerzahl in einem Objekt setzen ***/void			DialogBase::SetInteger(short object, long count){Str15		s;	NumToString(count,s);	SetDialogText(object, s);}/*** *	Integerzahl aus einem Objekt holen ***/long			DialogBase::GetInteger(short object){Str255		s;long		count;	GetDialogText(object, s);	StringToNum(s,&count);	return count;}/*** *	Button hiliten ***/void			DialogBase::HiliteButton(short item, short flag){	if((GetItemType(item) & ctrlItem) != ctrlItem)	// evtl. gar kein Control?		return;										// => raus	HiliteControl((ControlHandle)GetCH(item), flag);}/*** *	Radio-Button aus einer Gruppe drücken, selektierten deselektieren ***/void			DialogBase::PushRadioButton(short item, short first, short last){	for(;first<=last;first++)		if (first != item)			SetButton(first,0);		// alle Buttons deselektieren	SetButton(item,1);				// und den neuen selektieren}/*** *	Checkbox toggeln ***/void			DialogBase::ToggleButton(short item){	SetButton(item,GetButton(item)?0:1);}/*** *	Button setzen ***/void			DialogBase::SetButton(short item, short flag){	if((GetItemType(item) & ctrlItem) != ctrlItem)		// evtl. gar kein Control?		return;											// => raus	if(GetButton(item) != flag)							// Wert geändert?		SetControlValue((ControlHandle)GetCH(item),flag);	// dann neu setzen}/*** *	Button holen ***/short			DialogBase::GetButton(short item){	if((GetItemType(item) & ctrlItem) != ctrlItem)		// evtl. gar kein Control?		return 0;										// => raus	return GetControlValue((ControlHandle)GetCH(item));}/*** *	Routine für ein UserItem setzen ***/void			DialogBase::SetUserItem(short item, UserItemUPP routine){short	type;Rect	r;Handle	c;	GetDialogItem(GetDialogPtr(), item, &type, &c, &r);	if ((type & ~itemDisable) == userItem)	// auch wirklich ein Useritem?		SetDialogItem(GetDialogPtr(), item, (type & itemDisable) + userItem, (Handle)routine, &r);}/*** *	Typ eines Items ermitteln ***/short			DialogBase::GetItemType(short item){Handle	h;Rect	r;short	type;	GetDialogItem(GetDialogPtr(), item, &type, &h, &r);	return type;}/*** *	Rechteck eines Items ermitteln ***/void			DialogBase::GetItemRect(short item, Rect *r){short	type;Handle	h;	GetDialogItem(GetDialogPtr(), item, &type, &h, r);}/*** *	Rechteck eines Items setzen ***/void			DialogBase::SetItemRect(short item, Rect *r){short	type;Handle	h;Rect	tempr;	GetDialogItem(GetDialogPtr(), item, &type, &h, &tempr);	SetDialogItem(GetDialogPtr(), item, type, h, r);}/*** *	Item enablen bzw. disablen ***/void			DialogBase::EnDisableItem(short item, Boolean flag){short	type;Handle	h;Rect	r;	HiliteButton(item, flag ? kCntlActive : kCntlInactive);	GetDialogItem(GetDialogPtr(), item, &type, &h, &r);	type &= ~itemDisable;	if(!flag)		type |= itemDisable;	SetDialogItem(GetDialogPtr(), item, type, h, &r);}/*** *	ControlHandle eines Items in einer Dialogbox ermitteln ***/Handle			DialogBase::GetCH(short item){Rect		r;short		type;Handle		h;	GetDialogItem(GetDialogPtr(), item, &type, &h, &r);	return h;}/*** *	Diese Routine zeichnet einen “Default”-Rahmen um ein Control. Bei inaktiven *	Controls wird der Rahmen in hell dargestellt. * *	Der Radius des Default-Rahmens ist im Gegensatz zu IM I-407 NICHT 16,16, *	sondern wird aus der halben Höhe des Buttons errechnet; dies sieht auch bei *	größeren Buttons noch gut aus. * *	ACHTUNG: Der GrafPort wird auf das Control-Window umgeschaltet. ***/void			DialogBase::OutlineControl(ControlHandle button){Rect			theRect;PenState		curPen;short			buttonOval;GrafPtr			savePort;AuxCtlHandle	auxCtlHndl = nil;RGBColor		newRGB;RGBColor		oldRGB;	if (!button) return;	GetPort(&savePort);	SetPort((*button)->contrlOwner);	GetPenState(&curPen);	if (gQDVersion) {		if (!GetAuxiliaryControlRecord(button,&auxCtlHndl))			GetAuxiliaryControlRecord(0,&auxCtlHndl);		newRGB = (*(*auxCtlHndl)->acCTable)->ctTable[cFrameColor].rgb;		GetForeColor(&oldRGB);		RGBForeColor(&newRGB);	}	PenNormal();	theRect = (*button)->contrlRect;	InsetRect(&theRect,kButtonFrameInset,kButtonFrameInset);	buttonOval = (theRect.bottom-theRect.top)/2+2;	PenPat(((*button)->contrlHilite==kCntlActive)?&qd.black:&qd.gray);	PenSize(kButtonFrameSize,kButtonFrameSize);	FrameRoundRect(&theRect,buttonOval,buttonOval);	SetPenState(&curPen);	if (gQDVersion) {		RGBForeColor(&oldRGB);	}	SetPort(savePort);}/*** *	“Default”-Rahmen um ein Objekt in einem Dialog zeichnen ***/void		DialogBase::OutlineDialogItem(short item){	if((GetItemType(item) & ctrlItem) != ctrlItem + btnCtrl)	// evtl. gar kein Button?		return;										// => raus	OutlineControl((ControlHandle)GetCH(item));}/*** *	“Default”-Rahmen um ein Objekt in einem Dialog zeichnen ***/void		DialogBase::FlashControl(short item){UInt32		finalTick;	HiliteButton(item, kSelect);	Delay(kDelayTime, &finalTick);	HiliteButton(item, kDeselect);}/*** *	Dialog erstellen ***/			DialogBase::DialogBase(){	inModalDialog = false;	modalItem = nil;				// spez. Wert für den Closer}/*** *	Window erstellen ***/void		DialogBase::Open(short windResourceID, WindowRefX behind){	WindowBase::Open(windResourceID, 0L, behind);	ObjectInfo = (DObjHandle)GetResource(DObj_ResType, windResourceID);	if(ObjectInfo) {	// Objekte in DObj Resource deklariert?		DetachResource((Handle)ObjectInfo);		HLockHi((Handle)ObjectInfo);		// Mit dieser Schleife klappern wir alle Objekte ab und initialsieren sie…		DObjItemPtr	op = (*ObjectInfo)->items;		for(int count = (*ObjectInfo)->count; count > 0; count--, op++) {			op->dBasePtr = this;			// ganz wichtig! Damit weiß das Control wozu es gehört!			DItems[op->type]->itemObject = op;			DItems[op->type]->Init();		// Wir melden uns bei allen an…		}	}}/*** *	Dialog killen ***/			DialogBase::~DialogBase(){	if(ObjectInfo) {				// Objekte in DObj Resource deklariert?		// Mit dieser Schleife klappern wir alle Objekte ab und deinitialisieren sie…		DObjItemPtr	op = (*ObjectInfo)->items;		for(int count = (*ObjectInfo)->count; count > 0; count--, op++) {			DItems[op->type]->itemObject = op;			DItems[op->type]->Exit();		}		DisposeHandle((Handle)ObjectInfo);	// Objektinfo freigeben		ObjectInfo = nil;			// Wichtig, da bei "Inactivate" (Schließen des Windows) die Liste nicht mehr existiert!	}}/*** *	TextEdit-Handle eines Dialogs ermitteln (wenn vorhanden) ***/short		DialogBase::GetTE(TEHandle *hTE){short		field;DialogPeek	d = (DialogPeek)GetDialogPtr();	*hTE = d->textH;					// evtl. TextEdit-Handle	if(!*hTE)							// kein TextEdit-Item vorhanden?		return 0;						// dann raus =>	field = d->editField + 1;			// Item # - 1 des aktiven TextEdit-Items	if(field > 0)						// ein gültiges Feld gesetzt?		return field;					// das geben wir dann zurück	// So, beim Init haben wir evtl. den Sonderfall, daß ein TextEdit-Feld zwar angemeldet ist, aber	// nicht aktiv ist (d->editField < 0), das müssen wir nun ändern…	int	count = CountItems();			// Anzahl der Items im Dialog	for(field = 1; field <= count; field++) {		if(GetItemType(field) != editText)			continue;		SelectInputItem(field);			// das Item selektieren (dabei wird auch editField initialisiert)		return field;	}	// kein passendes TextEdit Feld gefunden (alle disabled?)	*hTE = nil;	return 0;}/*** *	Items in einem Dialog zählen ***/short		DialogBase::CountItems(void){	return CountDITL(GetDialogPtr());}/*** *	Dialog nach Update Event neu zeichnen ***/void		DialogBase::Idle(void){TEHandle	hTE;	if(GetTE(&hTE) == 0) return;			// kein TextEdit Item vorhanden? => raus	TEIdle(hTE);}/*** *	Item für Tastatursteuerung aktivieren (in TextEdit z.B. komplett selektieren) ***/void		DialogBase::SelectInputItem(short item){	switch(GetItemType(item)) {	case editText:			SelectDialogItemText(GetDialogPtr(), item, 0, 32767);			break;	}}/*** *	Dialog nach Update Event neu zeichnen ***/Boolean		DialogBase::EventKey(char key, short modifiers){	WindowBase::EventKey(key, modifiers);	// Default-Button abfragen	if(key == 13 || key == 3) {			// Return oder Enter gedrückt?		if((GetItemType(ok) & ctrlItem) == ctrlItem + btnCtrl) {	// evtl. gar kein Button?			FlashControl(ok);			Button(ok);					// entsprechende Callback-Funktion aufrufen			return true;		}	}	// Abbruch-Button abfragen	if(key == 27 || CmdPeriod(&gTheEvent)) {	// ESC oder Command-. gedrückt?		if((GetItemType(cancel) & ctrlItem) == ctrlItem + btnCtrl) {	// evtl. gar kein Button?			FlashControl(cancel);			Button(cancel);				// entsprechende Callback-Funktion aufrufen			return true;		}	}	if(ObjectInfo) {					// Objekte in DObj Resource deklariert?		// Mit dieser Schleife klappern wir alle Objekte ab und zeichnen sie…		DObjItemPtr	op = (*ObjectInfo)->items;		for(int count = (*ObjectInfo)->count; count > 0; count--, op++) {			if((op->modifierflags & 0x4000) == 0x4000) {	// Command abtesten?				if((modifiers & cmdKey) == cmdKey) {		// Command gedrückt?					if((op->modifierflags & 0x8000) == 0)	// soll aber nicht gedrückt sein?						continue;							// => weitersuchen				} else {									// Command nicht gedrückt?					if((op->modifierflags & 0x8000) == 0x8000)	// soll aber gedrückt sein?						continue;							// => weitersuchen				}			}			if((op->modifierflags & 0x1000) == 0x1000) {	// Control abtesten?				if((modifiers & controlKey) == controlKey) {// Control gedrückt?					if((op->modifierflags & 0x2000) == 0)	// soll aber nicht gedrückt sein?						continue;							// => weitersuchen				} else {									// Control nicht gedrückt?					if((op->modifierflags & 0x2000) == 0x2000)	// soll aber gedrückt sein?						continue;							// => weitersuchen				}			}			if(op->key != key) {			// Taste nicht erkannt, weiter suchen				char		k = key;				UpperText(&k, sizeof(char));	// Großbuchstaben abtesten				if(op->key != k) {					LowerText(&k, sizeof(char));// Kleinbuchstaben abtesten					if(op->key != k)						continue;				}			}			if((GetItemType(op->item) & itemDisable) == itemDisable)				continue;					// Item ist disabled! => weitersuchen			FlashControl(op->item);			Button(op->item);				// entsprechende Callback-Funktion aufrufen			return true;		}	}	// nun testen wir noch mal auf TextEdit…	TEHandle	hTE;	int			activeItem = GetTE(&hTE);	if(activeItem == 0) return false;			// kein TextEdit Item vorhanden? => Objektliste durchsehen	// TextItem zum aktuellen TextEdit-Objekt ermitteln (nil = keins)	DObjItemPtr	op = nil;	if(ObjectInfo) {							// angemeldete Useritems vorhanden?		// Mit dieser Schleife klappern wir alle Objekte ab und suchen das angeklickte…		op = (*ObjectInfo)->items;		int count;		for(count = (*ObjectInfo)->count; count > 0; count--, op++) {			if(op->item != activeItem)				// Objekt gefunden?				continue;							// nein => weitersuchen			if(op->type != TextEdit)				// Objekt = TextEdit?				continue;							// ja => weitersuchen			break;		}		if(count == 0)			op = nil;	}	if(modifiers & cmdKey) {		switch(key) {		case 'X':	// Cut		case 'x':				TECut(hTE);				break;		case 'C':	// Copy		case 'c':				TECopy(hTE);				break;		case 'V':	// Paste		case 'v':				if(op) {	// Längenbeschränkung?					if(((*hTE)->teLength + TEGetScrapLength()						- ((*hTE)->selEnd - (*hTE)->selStart)) > op->textedit.maxlen) {						SysBeep(1);		// Text würde zu lang werden!						break;					}					Handle	hScrap = TEScrapHandle();					if(op->textedit.onlyNumbers) {			// sind nur Ziffern erlaubt?						int	size = GetHandleSize(hScrap);						Ptr	p = *hScrap;						for(; size > 0; p++, size--) {							if(*p < '0' || *p > '9')		// eine Nicht-Ziffer gefunden?								break;						// dann raus!						}						if(size) {							SysBeep(1);			// Scrap enthält nicht nur Ziffern!!!							break;						}					}				}				TEPaste(hTE);				break;		default:	// unbekannte Command-Taste => durch den Event-Handler erledigen				return false;		}	} else {		switch(key) {		default:			if(op) {		// Längenbeschränkung?				if((*hTE)->teLength >= op->textedit.maxlen &&	// max. Länge bereits erreicht?					(*hTE)->selStart == (*hTE)->selEnd &&		// und keine Selektion?					key >= 32) {								// und kein Steuerzeichen (Backspace o.ä.)?					SysBeep(1);			// Text würde zu lang werden!					break;				}				if(op->textedit.onlyNumbers) {			// sind nur Ziffern erlaubt?					if(key >= 32 && (key < '0' || key > '9')) {	// keine Ziffer gedrückt?						SysBeep(1);			// Text würde zu lang werden!						break;					}				}			}			TEKey(key, hTE);			break;		case 9:		// Tab (bzw. Shift-Tab für den Sprung zum vorherigen Item)			Boolean isShiftPressed = (modifiers & shiftKey) == shiftKey;			int	numItems = CountItems();	// Anzahl der Items im Dialog			int queryItem = activeItem + (isShiftPressed ? -1 : 1);			while(queryItem != activeItem) {			// check to see if we're back where we started				if(queryItem == 0)						// handle rollover					queryItem = numItems;				else if(queryItem > numItems)					queryItem = 1;				if(GetItemType(queryItem) == editText)	// if editText, we're finished					break;				isShiftPressed ? queryItem-- : queryItem++;	// get next item to query			}			if(queryItem != activeItem)					// found a new one?				SelectInputItem(queryItem);		}	}	return true;}/*** *	Klick ins Window, ggf. Mehrfachklick ***/void		DialogBase::Klick(Point p, short clicks, Boolean &onItem){	 UNUSED(onItem);	int item = FindDialogItem(GetDialogPtr(), p) + 1;	// ItemNo ermitteln	if(item <= 0) return;							// kein Item gefunden =>	int type = GetItemType(item);					// Typ vom Item ermitteln	switch(type & ~resCtrl) {						// die unteren 2 Bits (genaues Spezifikation rausfiltern)	case ctrlItem:	// ein Macintosh OS Control		ControlHandle	c;		if(!FindControl(p, (WindowPtr)GetDialogPtr(), &c))	// ein Control an der Stelle?			break;									// nein =>		if(!TrackControl(c, p, nil))				// Mausaktion mit dem Control			break;									// nix tun =>		Button(item);								// entsprechende Callback-Funktion aufrufen		break;	case editText:	// ein Textfeld		TEHandle	hTE;		int			aktitem = GetTE(&hTE);		if(aktitem != item)							// Klick in ein nicht aktives TextEdit Feld?			SelectDialogItemText(GetDialogPtr(), item, 0, 0);	// dann dieses Feld aktivieren		GetTE(&hTE);								// TEHandle vom neuen aktiven TextEdit Feld holen		TEClick(p, gTheEvent.modifiers & shiftKey, hTE);	// Mausklick abfragen		break;	default:		// ein beliebiges User-Item bzw. ein Text-Item, Icon, o.ä.		if((GetItemType(item) & itemDisable) == itemDisable)			break;									// Item ist disabled! => nix tun		int count = 0;		if(ObjectInfo) {							// angemeldete Useritems vorhanden?			// Mit dieser Schleife klappern wir alle Objekte ab und suchen das angeklickte…			DObjItemPtr	op = (*ObjectInfo)->items;			for(count = (*ObjectInfo)->count; count > 0; count--, op++) {				if(op->item != item)					// Objekt gefunden?					continue;							// nein => weitersuchen				if(op->type == NothingSpecial)			// Objekt = 08/15					continue;							// ja => weitersuchen				DItems[op->type]->itemObject = op;				DItems[op->type]->Klick(p, clicks);		// Klick an das Control melden				break;			}		}		if(count == 0)			Button(item);							// entsprechende Callback-Funktion aufrufen		break;	}}/*** *	Dialog nach Update Event neu zeichnen ***/void		DialogBase::Draw(void){	DrawDialog(GetDialogPtr());	OutlineDialogItem(ok);	if(ObjectInfo) {	// Objekte in DObj Resource deklariert?		// Mit dieser Schleife klappern wir alle Objekte ab und zeichnen sie…		DObjItemPtr	op = (*ObjectInfo)->items;		for(int count = (*ObjectInfo)->count; count > 0; count--, op++) {			DItems[op->type]->itemObject = op;			DItems[op->type]->Draw();		}	}}/*** *	Window wurde aktiviert bzw. deaktiviert ***/void		DialogBase::EventActivate(Boolean flag){TEHandle	hTE;	WindowBase::EventActivate(flag);	if(ObjectInfo) {	// Objekte in DObj Resource deklariert?		// Mit dieser Schleife klappern wir alle Objekte ab und updaten sie ggf.…		DObjItemPtr	op = (*ObjectInfo)->items;		for(int count = (*ObjectInfo)->count; count > 0; count--, op++) {			DItems[op->type]->itemObject = op;			DItems[op->type]->Activate(flag);		}	}	if(GetTE(&hTE) == 0) return;			// kein TextEdit Item vorhanden? => raus	if(flag)		TEActivate(hTE);					// Cursor an	else		TEDeactivate(hTE);					// Cursor abschalten}/*** *	einen einfachen Dialog komplett erledigen (inkl. Konstruktor & Destruktor, da eine statische Funktion) ***/short		DialogBase::Do(short resid, ModalFilterProcPtr modalFilter){short		item;DialogBase	*dp;	dp = new DialogBase;	dp->Open(resid);				// Dialog laden	dp->ModalDialog(modalFilter, &item);	// Dialog abarbeiten	delete dp;						// und killen	return item;					// angeklicktes Objekt zurückgeben}/*** *	Ändert den Mauszeiger auf TextEdit-Zeiger, wenn er auf dem aktuellen TextEdit- *	Feld steht und auf einen Pfeil, wenn nicht ***/void			DialogBase::IBeamIt(void){Point		mouseAt;short		itemtype;Handle		itemhandle;Rect		r;short		item;	item = ((DialogPeek)WindRef)->editField + 1;	if (!item)						// keine TextEdit-Felder vorhanden?		return;						// => raus	GetDialogItem(GetDialogPtr(), item, &itemtype, &itemhandle, &r);	GetMouse(&mouseAt);	if (PtInRect(mouseAt,&r)) {		// Pfeil im TextEdit-Rechteck?		textmaus();	} else {		pfeil();	}}/*** *	ein Button wurde angeklickt ***/long			DialogBase::SleepTicks(void){	if(inModalDialog)			// in der Dialogverwaltung?		return 0L;				// stets sofort zurückkommen (wg. der Idle Events)	TEHandle	hTE;	if(GetTE(&hTE) > 0)			// TextEdit Feld aktiv?		return GetCaretTime();	// dann für das Cursorblinken häufiger melden	return WindowBase::SleepTicks();	// ansonsten den Default nehmen}/*** *	Edit-Menüpunkt aufgerufen ***/Boolean			DialogBase::DoCommand(long cmd){TEHandle	hTE;	int		item = GetTE(&hTE);	if(item == 0) return false;	// kein TextEdit Item vorhanden? => raus	// bei TextEdit rufen wir normalerweise die Tastaturshortcuts auf	switch(cmd) {	case cCut:			EventKey('X', cmdKey);			break;	case cCopy:			EventKey('C', cmdKey);			break;	case cPaste:			EventKey('V', cmdKey);			break;	case cClear:			TEDelete(hTE);			break;	case cSelectAll:			SelectInputItem(item);			break;	default:			return false;	}	return true;}/*** *	Befehle bei Bedarf enablen ***/void			DialogBase::GetCommandStatus(long cmd, Boolean &enabled, short &markChar, Str255 &name){	UNUSED(markChar); UNUSED(name);	if(IsModal())	// modaler Dialog?		enabled = false;					// alle Menüpunkte disablen	TEHandle	hTE;	if(GetTE(&hTE) == 0) return;			// kein TextEdit Item vorhanden? => raus	// bei TextEdit schalten wir einiges im “Bearbeiten” Menü frei.	switch(cmd) {	case cPaste:			if(TEGetScrapLength() == 0L)				break;			enabled = true;			break;	case cCut:	case cCopy:	case cClear:			if((*hTE)->selEnd == (*hTE)->selStart)	// keine Selektierung?				break;						// dann auch kein Cut/Copy/Paste	case cSelectAll:			if((*hTE)->teLength == 0)		// keine Zeichen im Eingabefeld?				break;			enabled = true;			break;	}}/*** *	ein Button wurde angeklickt ***/void			DialogBase::Button(short button){	*modalItem = button;}/*** *	Closer vom Dialog wurde angeklickt ***/void			DialogBase::EventGoAway(void){	if(!inModalDialog) {			// nicht in der Dialogverwaltung?		WindowBase::EventGoAway();	// dann den Closer normal aufrufen		return;	}	*modalItem = -1;				// spez. Wert für den Closer}/*** *	Einen modalen Dialog simulieren ***/short			DialogBase::ModalDialog(ModalFilterProcPtr modalFilter, short *itemHit){	*itemHit = 0;	modalItem = itemHit;			// Ptr auf den Item-Rückgabewert merken	Boolean		oldModalFlag = inModalDialog;	inModalDialog = true;			// nun sind wir innerhalb der Modal-Dialog Verwaltung	Select();						// toppen	Show();							// …und darstellen	pfeil();						// Mauszeiger auf einen Pfeil umschalten	while(!*itemHit) {		GetEvent(everyEvent & ~highLevelEventMask);	// ein Event vorhanden?		if(modalFilter)			if((*modalFilter)(GetDialogPtr(), &gTheEvent, modalItem))				break;				// Der Dialogfilter will abbrechen =>		DoIdleTasks();				// erstmal Idle auswerten		DoEvent();					// dann diesen auswerten	}	inModalDialog = oldModalFlag;	return *itemHit;}