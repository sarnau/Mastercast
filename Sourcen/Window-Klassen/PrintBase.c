/*** *	Klasse zum Ausdrucken von Fenstern o.Š. * *	©1994 Dekotec Abt. Info-Sys, Markus Fritze ***/#include "PrintBase.h"#include "GlobalLib.h"short		AktPage;			// aktuelle DruckseiteStr31		PrDocName;PrintBase	*AktPrinter;/*** *	Eine Seite ausdrucken ***/void		PrintBase::PrintPage(TPPrPort printPort, THPrint printP){	UNUSED(printPort); UNUSED(printP);}/*** *	Init-Aufruf vor dem Ausdruck ***/void		PrintBase::InitPrint(TPPrPort printPort, THPrint printP){	UNUSED(printPort); UNUSED(printP);}/*** *	IsLandscapeSet will determine if the user has selected landscape orientation *	from the Style dialog. If the user has selected landscape orientation, we will *	return "true" to the calling function. Otherwise, return "false". ***/Boolean		PrintBase::IsLandscapeSet(void){TGetRotnBlk	GetRotRec;Boolean		ShowLandscapeResults = false;THPrint		hPrtRec;OSErr		err;	::PrOpen();	err = ::PrError();	if(err == fnfErr|| err == -8172) err = -8150;	if(!err) {		hPrtRec = (THPrint)::NewHandle(sizeof(TPrint)); // neue Struktur allozieren		ThrowIfMemFail_(hPrtRec);		**hPrtRec = PrStruct;					// Dokumentendaten Ÿbertragen		if(!PrStructValid)						// War die Struktur gŸltig?			::PrintDefault(hPrtRec);			// Nein, erstmal initialisieren		else			::PrValidate(hPrtRec);				// oder nur abtesten		if(!(err = PrError())) {			GetRotRec.iOpCode = getRotnOp;			GetRotRec.hPrint = hPrtRec;		 	::PrGeneral((Ptr)&GetRotRec);			//	We now have the result from our call to PrGeneral, but we check all			//	known errors to make sure that PrGeneral was successful and there			//	have not been any errors encountered from printing land.			if(GetRotRec.iError == noErr && PrError() == noErr && GetRotRec.fLandscape)				ShowLandscapeResults = true;		}		::DisposeHandle((Handle)hPrtRec);	}	::PrClose();	return ShowLandscapeResults;}/*** *	Page Setup Dialog darstellen und ausfŸhren ***/void		PrintBase::PageSetup(void){OSErr		err;THPrint		hPrtRec;	hPrtRec = (THPrint)::NewHandle(sizeof(TPrint));	// neue Struktur allozieren	ThrowIfMemFail_(hPrtRec);	::PrOpen();	err = ::PrError();	if(err == fnfErr || err == -8172) err = -8150;	**hPrtRec = PrStruct;						// Dokumentendaten Ÿbertragen	if(!PrStructValid)							// War die Struktur gŸltig?		::PrintDefault(hPrtRec);				// Nein, erstmal initialisieren	else		::PrValidate(hPrtRec);					// oder nur abtesten	err = ::PrError();	if(err == noErr) {		if(PrStlDialog(hPrtRec)) {			PrStruct = **hPrtRec;				// in Dokumenten-Struktur kopieren			PrStructValid = true;				// Dokumentendaten nun gŸltig!		} else				err = userCanceledErr;			// Abbruch!		::DisposeHandle((Handle)hPrtRec);		// Handle wieder verwerfen	}	::PrClose();	if(err != userCanceledErr)		ThrowIfOSErr_(err);}/*** *	Ein Dokument ausdrucken * *	dispose = true   : Ende, interne Strukturen freigeben *	jobDlg  = true   : Dialogbox fŸr das Einstellen der Seitennummern, etc. darstellen *	firstJob = true  : erster Aufruf beim Ausdruck einer Serie von Dokumenten ***/void		PrintBase::Print(Boolean dispose,Boolean jobDlg,Boolean firstJob){OSErr				err;THPrint				hPrtRec;TPPrPort			printPort;GrafPtr				oldPort;short				i,keepResFile,fstPage,lstPage,copies;TPrStatus			status;Str63				s;static THPrint		prMergeHndl = nil;PrIdleUPP			myIdleRD;	AktPrinter = this;	if (dispose) {								// abmelden?		if (prMergeHndl) {						// Handle noch vorhanden?			::DisposeHandle((Handle)prMergeHndl);	// dann freigeben			prMergeHndl = nil;		}		return;									// alles ok!	}	PrintingStatusDialog = nil;	hPrtRec = (THPrint)::NewHandle(sizeof(TPrint));	// neue Struktur allozieren	ThrowIfMemFail_(hPrtRec);	**hPrtRec = PrStruct;						// Struktur fŸllen!	::GetPort(&oldPort);	::PrOpen();	err = ::PrError();	if(err == fnfErr || err == -8172) err = -8150;	if(!err) {		keepResFile = ::CurResFile();		if (!PrStructValid) {			::PrintDefault(hPrtRec);			// The document print record was never			err = ::PrError();					// initialized. Now is is.		}		if (!err) {			::PrValidate(hPrtRec);				// Do this just 'cause Apple says so.			err = ::PrError();		}		if (!err) {			if (jobDlg) {						// User gets to click some buttons.				if(!::PrJobDialog(hPrtRec))					::PrSetError(err = userCanceledErr);				else					err = ::PrError();			}		}		if (!err) {			if (!firstJob) {				::PrJobMerge(prMergeHndl, hPrtRec);				err = ::PrError();			}		}		if (!err) {			// Put the defaulted/validated/jobDlg'ed print record in the doc.			fstPage	= (*hPrtRec)->prJob.iFstPage;			if (fstPage == 0) fstPage = iPrPgFst;			lstPage	= (*hPrtRec)->prJob.iLstPage;			if (lstPage == 0) lstPage = iPrPgMax;			copies	= (*hPrtRec)->prJob.iCopies;			if (copies == 0) copies = 1;			PrStruct = **hPrtRec;			PrStructValid = true;			(*hPrtRec)->prJob.iFstPage = iPrPgFst;	// ÒalleÓ Seiten ausdrucken (LaserWriter LC!)			(*hPrtRec)->prJob.iLstPage = iPrPgMax;			PrintingStatusDialog = new DialogBase;			PrintingStatusDialog->Open(dPrStatusDlg);			PrintingStatusDialog->Show();			PrintingStatusDialog->Select();			::SetWTitle(PrintingStatusDialog->GetDialogPtr(), PrDocName);			::PrValidate(hPrtRec);					// Do this just 'cause Apple says so.			::NumToString(fstPage,s);			::ParamText(PrDocName,s,nil,nil);	// Dokumentname + Seitennummer			PrintingStatusDialog->RedrawItem(1);			myIdleRD = NewPrIdleProc(PrintIdleProc);			for (i=1; i<=copies && !err; ++i) {				Boolean		openFlag = false;				// Dialogbox-Hook eintragen (Apple machts auch an dieser StelleÉ)				(*hPrtRec)->prJob.pIdleProc = myIdleRD;				// Restore the reource file to the printer driver«s				::UseResFile(keepResFile);				for(AktPage = fstPage; AktPage <= lstPage; AktPage++) {					if ((AktPage - fstPage) % iPFMaxPgs == 0) {	// max. 128 Seiten!						if (AktPage != fstPage) {			// erster Durchgang?							::PrCloseDoc(printPort);		// sonst das Dokument schlie§en!							::PrPicFile(hPrtRec,nil,nil,nil,&status);							err = PrError();						}						if (err) break;						// Fehler => Abbruch						printPort = ::PrOpenDoc(hPrtRec,nil,nil);						openFlag = true;					// PrOpen aufgetreten						err = ::PrError();						if (err) break;						// Fehler => Abbruch						if (AktPage == fstPage) {			// erster Durchgang?							GrafPtr	savePort;							::GetPort(&savePort);							::SetPort(&printPort->gPort);							InitPrint(printPort, hPrtRec);	// Init-Aufruf							AktPage = fstPage;							::SetPort(savePort);						}					}					::NumToString(AktPage,s);					::ParamText(PrDocName,s,nil,nil);		// Dokumentname + Seitennummer					PrintingStatusDialog->RedrawItem(1);					::PrOpenPage(printPort,nil);					err = ::PrError();					if (err == noErr) {						GrafPtr	savePort;						::GetPort(&savePort);						::SetPort(&printPort->gPort);						PrintPage(printPort, hPrtRec);			// Init-Aufruf						::SetPort(savePort);					}					::PrClosePage(printPort);					if(!AktPage ||						// Seitennummer = 0 => Ende						((err = ::PrError()) != noErr)) break;		// oder ein Fehler?				}				AktPage = 0;				if (openFlag)							// PrOpen aufgetreten?					::PrCloseDoc(printPort);			}			DisposeRoutineDescriptor(myIdleRD);		}		if (			(!err) &&			((*hPrtRec)->prJob.bJDocLoop == bSpoolLoop) &&			(!(err = ::PrError()))		) {			::PrPicFile(hPrtRec,nil,nil,nil,&status);			err = ::PrError();		}	}	if (firstJob)	prMergeHndl = hPrtRec;	else			::DisposeHandle((Handle)hPrtRec);	if (PrintingStatusDialog) {		delete PrintingStatusDialog;		PrintingStatusDialog = nil;	}	::PrClose();	::SetPort(oldPort);	if(err != userCanceledErr)		ThrowIfOSErr_(err);}/*** *	Idle Routine fŸr den Status Dialog beim Drucken, Command-. abfragen, Seitenzahl updaten ***/pascal void		PrintBase::PrintIdleProc(void){static short	lastPage = -1;PrintBase		*pb = PrintBase::GetPrinter();	if (AbortInQueue()) {		::PrSetError(iPrAbort);          			// Drucken abbrechen		pb->SetPageNo(0);							// abbrechen!		return;	}	if (lastPage != pb->GetPageNo()) {				// Seitennummer updaten		pb->PrintingStatusDialog->RedrawItem(1);		lastPage = pb->GetPageNo();	}}