/*** *	Dieser Source ersetzt _sämtliche_ Control Manager Aufrufe durch eigene! *	Die eigenen unterscheiden sich lediglich durch ein "o" als ersten Buchstaben *	von den Originalaufrufen. * *	Ausnahme von der Regel: GetNewControl() (da der Resource-Template eh auf Wortbreite *											 ausgelegt ist…) * *	Sinn der Sache: Slider haben nun einen Langwort-Bereich! * *	©1992 ∑-Soft, Markus Fritze ***/#include "LongControl.h"#include <MacWindows.h>#include <LowMem.h>// Diese Struktur wird in refCon vom Control eingeklinkt:typedef struct	OwnControlStruct {	long	refCon;					// refCon vom “Anwender”	long	value;					// Langwort-Wert vom aktuellen Slider	long	min;					// Langwort-Wert vom minimalen Sliderwert	long	max;					// Langwort-Wert vom maximalen Sliderwert} OwnControlStruct,*OwnControlPtr,**OwnControlHndl;// Folgende Funktion sind _nur_ innerhalt der Library erlaubt:// Handle auf die eigene Struktur aus der ControlHandle ermittelnOwnControlHndl	ooGetOwnCtrl(ControlHandle c);// Control-Funktion aufrufenlong			ooCallControl(ControlHandle c,ControlDefProcMessage message,SInt32 param);// Control neu ausgeben (param = 0), bzw. Slider updaten (param = InThumb)void			ooUpdateControl(ControlHandle c,short param);// Value vom Control Manager-Slider gemäß des Langwort-Values setzen (im Verhältnis)// und Slider updaten (wenn nötig)void			ooUpdateControlValue(ControlHandle c);/*** *	Control anmelden ***/ControlHandle	oNewControl(WindowPtr w,Rect *r,Str255 title,Boolean visible,long value,long min,long max,short ctrlType,long refCon){ControlHandle	c;OwnControlHndl	o;	o = (OwnControlHndl)NewHandleClear(sizeof(OwnControlStruct));	// eigene Handle allozieren	if (MemError()) return 0;				// Fehler => raus	c = NewControl(w,r,title,visible,0,0,32767,ctrlType,(long)o);	// Control anmelden	if (!c) {		DisposeHandle((Handle)o);			// eigene Struktur wieder freigeben		return 0;							// Fehler => raus	}	(*o)->min	= min;						// Sliderwerte merken	(*o)->max	= max;	(*o)->value	= value;	oSetControlReference(c,refCon);	ooUpdateControlValue(c);				// Slider updaten	return c;}/*** *	Control abmelden ***/void			oDisposeControl(ControlHandle c){OwnControlHndl	o;	if (!c) return;							// Control angegeben? Nein => raus	o = (OwnControlHndl)GetControlReference(c);		// Handle auf eigene Struktur holen	if (!o) DisposeHandle((Handle)o);		// freigeben, wenn vorhanden	DisposeControl(c);						// und das Control auch freigeben}/*** *	alle Controls des Windows abmelden ***/void			oKillControls(WindowPtr w){ControlHandle	c = (ControlHandle)((WindowPeek)w)->controlList;ControlHandle	last;	while(c) {								// keine weiteren Controls?		last = (*c)->nextControl;			// Handle auf den Folgecontrol merken		oDisposeControl(c);					// Control freigeben		c = last;							// und Pointer wieder setzen	}}/*** *	Control-Funktion aufrufen * *	(interne Funktion) ***/long			ooCallControl(ControlHandle theControl,ControlDefProcMessage message,SInt32 param){GrafPtr		oldPort;Handle		userRoutine;long		ret;	GetPort(&oldPort);	SetPort((*theControl)->contrlOwner);	// Grafport auf das Control	userRoutine = (Handle)StripAddress((*theControl)->contrlDefProc);	// Handle auf die CDEF-Funktion	if(!*userRoutine) {		LMSetROMMapInsert(0xFF);			// Resource aus dem ROM holen		LoadResource(userRoutine);			// und laden		if(!*userRoutine) SysError(88);		// Resource nicht (im ROM…) gefunden	}	HLock(userRoutine);	ret = CallControlDefProc((ControlDefUPP)*userRoutine, GetControlVariant(theControl), theControl, message, param);	HUnlock(userRoutine);	SetPort(oldPort);						// alten Grafport wieder setzen	return ret;								// Rückgabewert der Control-Funktion}/*** *	Control-Element neu zeichnen * *	(interne Funktion) ***/void			ooUpdateControl(ControlHandle theControl,short param){	if (!(*theControl)->contrlVis) return;			// Control unsichtbar? dann raus =>	ooCallControl(theControl,drawCntl,param);}/*** *	Handle auf interne Control-Struktur zurückgeben * *	(interne Funktion) ***/OwnControlHndl	ooGetOwnCtrl(ControlHandle c){OwnControlHndl	o;	if (!c) return 0;	o = (OwnControlHndl)GetControlReference(c);		// Handle auf eigene Struktur holen	return o;}/*** *	“echten” Sliderwert gemäß des Langwort-Wertes setzen * *	(interne Funktion) ***/void			ooUpdateControlValue(ControlHandle c){OwnControlHndl	o = ooGetOwnCtrl(c);long			valL,minL,maxL,valS;short			minS,maxS;	if (!o) return;	minL = (*o)->min; maxL = (*o)->max; valL = (*o)->value;	if (valL < minL) valL = minL;			// Value zu klein?	if (valL > maxL) valL = maxL;			// Value zu groß?	(*o)->value = valL;						// aktuellen (evtl. korrigierten) Wert setzen	minS = GetControlMinimum(c); maxS = GetControlMaximum(c);	if (valL == minL)						// Slider genau auf Minimum?		valS = minS;						// dann gar nicht erst rechnen…	else {		if (valL == maxL)					// Slider genau auf Maximum?			valS = maxS;					// dann gar nicht erst rechnen…		else {			valS = ((float)(valL - minL) * (float)(maxS - minS + 1L)) / (float)(maxL - minL + 1) + minS;		}	}	SetControlValue(c,valS);	ooUpdateControl(c,kControlIndicatorPart);				// Control bei Bedarf neu zeichnen}/*** *	Minimalen Control-Wert zurückgeben ***/long			oGetControlMinimum(ControlHandle c){OwnControlHndl	o = ooGetOwnCtrl(c);	if (!o) return 0;	return (*o)->min;}/*** *	Minimalen Control-Wert setzen ***/void			oSetControlMinimum(ControlHandle c,long value){OwnControlHndl	o = ooGetOwnCtrl(c);	if (!o) return;	(*o)->min = value;	ooUpdateControlValue(c);}/*** *	Maximalen Control-Wert zurückgeben ***/long			oGetControlMaximum(ControlHandle c){OwnControlHndl	o = ooGetOwnCtrl(c);	if (!o) return 0;	return (*o)->max;}/*** *	Maximalen Control-Wert setzen ***/void			oSetControlMaximum(ControlHandle c,long value){OwnControlHndl	o = ooGetOwnCtrl(c);	if (!o) return;	(*o)->max = value;	if (value)	SetControlMaximum(c,32767);	else		SetControlMaximum(c,0);	ooUpdateControlValue(c);}/*** *	Aktuellen Control-Wert zurückgeben ***/long			oGetControlValue(ControlHandle c){OwnControlHndl	o = ooGetOwnCtrl(c);	if (!o) return 0;	return (*o)->value;}/*** *	Aktuellen Control-Wert setzen ***/void			oSetControlValue(ControlHandle c,long value){OwnControlHndl	o = ooGetOwnCtrl(c);	if (!o) return;	(*o)->value = value;	ooUpdateControlValue(c);}/*** *	refCon-Wert setzen ***/long			oGetControlReference(ControlHandle c){OwnControlHndl	o = ooGetOwnCtrl(c);	if (!o) return 0;	return (*o)->refCon;}/*** *	Aktuellen refCon-Wert setzen ***/void			oSetControlReference(ControlHandle c,long value){OwnControlHndl	o = ooGetOwnCtrl(c);	if (!o) return;	(*o)->refCon = value;}/*** *	angeklicktes Control-Element finden * *	Besonderheit zum Original: auch ein nicht “hilited” Control wird erkannt! ***/short			oTestControl(ControlHandle c,Point localPt){short		ret = 0;	if((*c)->contrlVis)			// Control sichtbar?		ret = ooCallControl(c,testCntl,*(long*)&localPt);	return ret;}/*** *	angeklicktes Control in einem Window finden * *	Besonderheit zum Original: auch ein nicht “hilited” Control wird erkannt! *	(Vorteil: inaktive Controls im Window erzeugen keine Mausklick-Messages) ***/short			oFindControl(Point localPt,WindowPtr w,ControlHandle *c){short			ret = 0;			// nix gefundenshort			temp;GrafPtr			savePort;ControlHandle	cl;					// Control-Liste	*c = 0;							// kein Control	if (!((WindowPeek)w)->visible) return 0;	// Window sichtbar? Nein => nichts gefunden	GetPort(&savePort);	SetPort(w);									// Windowport aktivieren	if (PtInRect(localPt,&(w->portRect))) {		// Punkt im Window-Rechteck?		cl = (ControlHandle)((WindowPeek)w)->controlList;		// erstes Control holen		while(cl) {			if (PtInRect(localPt,&(*cl)->contrlRect))	// Punkt im Control?				*c = cl;			temp = oTestControl(cl,localPt);	// Punkt im Control?			if (temp) {							// Control angeklickt?				ret = temp;						// angeklicktes Item				*c = cl;						// gefunden? Control merken			}			cl = (*cl)->nextControl;			// sonst zum nächsten Control		}	}	SetPort(savePort);	return ret;}/*** *	Errechnet aus dem "kleinene" echten Sliderwert den richtigen "großen" Wert ***/long			ThumbPosCalc(ControlHandle c,short val){long	offset	= (float)((val - GetControlMinimum(c)) * (float)(oGetControlMaximum(c) - oGetControlMinimum(c) + 1)) /					(float)(GetControlMaximum(c) - GetControlMinimum(c) + 1L) + oGetControlMinimum(c);	if (GetControlValue(c) >= GetControlMaximum(c))		offset = oGetControlMaximum(c);	if (GetControlValue(c) <= GetControlMinimum(c))		offset = oGetControlMinimum(c);	return offset;}/*** *	Thumb wurde angeklickt. Nun wird er bewegt… ***/long			TrackThumb(Point thePoint,ControlHandle c,ControlActionUPP proc){long	offset = 0;short	old = GetControlValue(c);	// alten (kleinen) Sliderwert merken	if (oTrackControl(c,thePoint,proc)) {	// Slider verschieben		short	val = GetControlValue(c);	// neuen (kleinen) Sliderwert holen		if (val != old)			offset = ThumbPosCalc(c,val) - oGetControlValue(c);	}	return offset;}