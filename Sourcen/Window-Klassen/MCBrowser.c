/*** *	Browser * *	©1994 Mastercast, Markus Fritze ***/#include "MCBrowser.h"#include "Geos.h"#include "MenuLib.h"#include "MCWindTools.h"#include "MCInfo.h"#include "MCLayout.h"#include "MCHeadsheet.h"#include "DoEvent.h"#include "GlobalLib.h"#include "ScrapBase.h"#include "PrintSedcard.h"#include "PrintPict.h"#include <string.h>#include <LFileStream.h>#include <LowMem.h>MCBrowser		*WWBrowser;/*** *	Selections-Fenster öffnen bzw. toppen ***/void		MCBrowser::Create(void){	if(!WWBrowser) {			// Selektion ist schon offen		LDEFBrowserStruct	*dp;		int					i,elcount;		// Modell-Strukturen in eine Liste wandeln		for(i=0; ModellList[i]; i++) {}		elcount = i;		dp = (LDEFBrowserStruct*)NewPtr(i * sizeof(LDEFBrowserStruct));		ThrowIfMemFail_(dp);		for(i=0; ModellList[i]; i++) {			dp[i].ms = ModellList[i];			dp[i].pic = 1;		}		WWBrowser = new MCBrowser;		WWBrowser->Open(16,500, 200,1, 4003, nil, elcount, sizeof(LDEFBrowserStruct), (Ptr)dp, LDEFBrowserSearchFunk, 0L, 38);		DisposePtr((Ptr)dp);	} else {		WWBrowser->Select();	}}/*** *	beim Löschen der Selektion, die Variable ebenfalls löschen ***/			MCBrowser::~MCBrowser(){	WWBrowser = nil;}/*** *	gewählte Objekte öffnen ***/void		MCBrowser::OpenList(Boolean infoFlag){LDEFBrowserStruct	*ms;short		index, count;	ms = (LDEFBrowserStruct*)GetSelectedData(count);	if(!ms) return;			// keine Modelle selektiert => raus	for(index = 0; index < count; index++) {		if(infoFlag)			MCLayout::Create(ms[index].ms->Id);		else			MCInfo::Create(ms[index].ms->Id);	}	DisposePtr((Ptr)ms);}/*** *	Headsheet-Daten dem Finder zur Verfügung stellen ***/OSErr			MCBrowser::SSendData(FlavorType theFlavor, ItemReference theItem, DragReference theDrag){OSErr			iErr;	if(theFlavor != gSignature)			// die eigene Signatur?		return badDragFlavorErr;	// Zielort des Drags ermitteln	AEDesc		dropLocation;	iErr = GetDropLocation(theDrag, &dropLocation);	if(iErr) return iErr;	// ein null-Descriptor? Dat war wohl nix…	if(dropLocation.descriptorType == typeNull) {		AEDisposeDesc(&dropLocation);		return noErr;	}	// wir wollen einen FSSpec bekommen…	AEDesc			dropSpec;	iErr = AECoerceDesc(&dropLocation, typeFSS, &dropSpec);	AEDisposeDesc(&dropLocation);	if(iErr != noErr) return iErr;				// …hat nicht geklappt => raus	FSSpec		target = *(FSSpec *)*dropSpec.dataHandle;	// FSSpec des Zielverzeichnisses	AEDisposeDesc(&dropSpec);	// dirID des Ordners ermitteln	CInfoPBRec		thePB;	thePB.dirInfo.ioNamePtr = (StringPtr) &target.name;	thePB.dirInfo.ioVRefNum = target.vRefNum;	thePB.dirInfo.ioFDirIndex = 0;	thePB.dirInfo.ioDrDirID = target.parID;	iErr = PBGetCatInfoSync(&thePB);	target.parID = thePB.dirInfo.ioDrDirID;	// einen Filenamen ermitteln, der noch nicht benutzt wurde	// 1. Versuch: Defaultfilename aus der Resource	// 2. Versuch: Defaultfilename + " " + 1	// 3. Versuch: Defaultfilename + " " + 2	// n. Versuch: Defaultfilename + " " + n-1	short		refNum;	long		l = 1;	Str15		tempStr;	tempStr[0] = 0;	do {		GetIndString(target.name, 900, 1);	// Filenamen lesen		if(tempStr[0]) {			ConcatPString(target.name, "\p ");			ConcatPString(target.name, tempStr);		}		iErr = FSpOpenDF(&target, fsCurPerm, &refNum);		if(iErr == noErr)			FSClose(refNum);		NumToString(l++, tempStr);	} while(iErr == noErr);	// Datei erzeugen	short		count;	LDEFHeadsheetStruct	*data = (LDEFHeadsheetStruct*)GetSelectedData(count);		// Daten im Headsheet Window holen	iErr = noErr;	if(count) {		// Ptr auf ModellStruct in Modell-IDs wandeln		for(int i=0; i<count; i++)			data[i].ms = (ModellStruct*)data[i].ms->Id;		try {			LFileStream		theFile(target);			try {				theFile.CreateNewDataFile(gSignature, gSignature, smSystemScript);			}			catch(PP_PowerPlant::ExceptionCode inErr) {			} 			theFile.OpenDataFork(fsCurPerm);			theFile.WriteDataFork(data, count * sizeof(LDEFHeadsheetStruct));			iErr = noErr;		}		catch(PP_PowerPlant::ExceptionCode inErr) {			iErr = inErr;		}	}	DisposePtr((Ptr)data);	if(iErr) return iErr;	iErr = SetDragItemFlavorData(theDrag, theItem, gSignature, (Ptr)&target, sizeof(target), nil);	return iErr;}/*** *	Draggen eines (oder mehrerer) Objekte starten ***/OSErr			MCBrowser::SStartDrag(EventRecord *theEvent){DragReference		theDrag;RgnHandle			dragRegion;	ThrowIfOSErr_(NewDrag(&theDrag));		// Drag starten	// Flavor hinzufügen	LDEFHeadsheetStruct	*ms;	short		index, count;	ms = (LDEFHeadsheetStruct*)GetSelectedData(count);	for(index = 1; count-- > 0; index++, ms++) {		// Items innerhalb von Mastercast		ThrowIfOSErr_(AddDragItemFlavor(theDrag, index, 'intr', ms, sizeof(LDEFHeadsheetStruct), flavorSenderOnly));	}	DisposePtr((Ptr)ms);	// _ein_ mastercast Headsheet-File	PromiseHFSFlavor	hfsFlavor;	hfsFlavor.fileType = gSignature;	hfsFlavor.fileCreator = gSignature;	hfsFlavor.fdFlags = 0;	hfsFlavor.promisedFlavor = gSignature;	ThrowIfOSErr_(AddDragItemFlavor(theDrag, 1, flavorTypePromiseHFS, &hfsFlavor, sizeof(hfsFlavor), flavorNotSaved));	ThrowIfOSErr_(AddDragItemFlavor(theDrag, 1, gSignature, nil, 0L, 0));	DragSendDataUPP	dsd = NewDragSendDataProc(MySendDataProc);	SetDragSendProc(theDrag, dsd, this);	// Region für alle selektierten Daten erzeugen	dragRegion = SelectedDataRgn();	// Region in umrahmte Rechtecke wandeln	RgnHandle	theRgn = NewRgn();	CopyRgn(dragRegion, theRgn);	InsetRgn(theRgn, 1, 1);	DiffRgn(dragRegion, theRgn, dragRegion);	DisposeRgn(theRgn);	SetDragItemBounds(theDrag, 1, &(*dragRegion)->rgnBBox);	// alle Objekte werden umschlossen	// Drag durchführen	TrackDrag(theDrag, theEvent, dragRegion);	// Drag beenden	DisposeRgn(dragRegion);		ThrowIfOSErr_(DisposeDrag(theDrag));	return noErr;}/*** *	Befehle bei Bedarf enablen ***/void		MCBrowser::GetCommandStatus(long cmd, Boolean &enabled, short &markChar, Str255 &name){	switch(cmd) {	case cPrint:			if(CountSelectedData() > 0)				enabled = true;			break;	case cOpenHeadsheet:	case cOpenPLayout:	case cOpenwtPInfo:	// nur enablen, wenn mindestens ein Modell selektiert ist	case cCopy:			enabled = CountSelectedData() >= 1;			break;	default:			MCLDEF::GetCommandStatus(cmd, enabled, markChar, name);	}}/*** *	Menüpunkt aufgerufen ***/Boolean		MCBrowser::DoCommand(long cmd){short		count;int			i;	switch(cmd) {	case cPrint:			LDEFHeadsheetStruct	*psp = (LDEFHeadsheetStruct*)GetSelectedData(count);			Boolean		cancel = false;			Boolean		psedcard = DialogBase::Do(141) == 1;			for(i=0; count > 0 && !cancel; count--, i++) {				if(psedcard) {					PrintPict	ppict(psp[i].ms->Id, psp[i].pic, i == 0, cancel);				} else {					PrintSedcard	psed(psp[i].ms->Id, i == 0, cancel);				}			}			DisposePtr((Ptr)psp);			break;	case cOpenHeadsheet:			LDEFHeadsheetStruct	*ms;			ms = (LDEFHeadsheetStruct*)GetSelectedData(count);			if(!ms) break;			MCHeadsheet::Create(count, ms);			DisposePtr((Ptr)ms);			break;	case cOpenPLayout:			OpenList(true);			break;	case cOpenwtPInfo:			OpenList(false);			break;	case cCopy:			theScrap.ClrScrap();			LDEFBrowserStruct	*bs = (LDEFBrowserStruct*)GetSelectedData(count);			for(i=0; count > 0; count--, i++)				theScrap.AddScrap(bs[i].ms, bs[i].pic);			DisposePtr((Ptr)bs);			break;	default:			return MCLDEF::DoCommand(cmd);	}	return true;}/*** *	LDEF Funktion für den Browser ***/static void		PrintString(char *theString, short offset, short width);static void		PrintString(char *theString, short offset, short width){Point		savePen = qd.thePort->pnLoc;			// Cursorposition merken	Move(offset, 0);								// horizontaler Offset	C2PStr(theString);	TruncString(width, (StringPtr)theString, smTruncEnd);	// auf maximale Länge trimmen	DrawString((StringPtr)theString);				// und ausgeben	P2CStr((StringPtr)theString);	MoveTo(savePen.h, savePen.v);					// Cursor wieder zurücksetzen (wird durch DrawString versetzt)}void			MCBrowser::LDEFCallback(short lMessage, Boolean lSelect, Rect *lRect, Cell lCell, short lDataOffset, short lDataLen, ListHandle lHandle){	UNUSED(lCell); UNUSED(lDataLen);	// Ptr auf aktuelles Modell	LDEFBrowserStruct	dp = *(LDEFBrowserStruct*)((*(*lHandle)->cells) + lDataOffset);	Rect	r = *lRect;	r.bottom = r.top + CellSize.v;	if(lMessage == lDrawMsg) {		EraseRect(&r);										// Bereich rechts vom Bild löschen		SetFont(5000);		FontInfo		fInfo;		GetFontInfo(&fInfo);		MoveTo(r.left, r.top + fInfo.ascent + 2);			// Cursor setzen		PrintString(dp.ms->Modellname, 5, 90);		if(AList) PrintString(AList->FindId(dp.ms->Agentur)->GetName(), 100, 95);		Str255		s, scm;		GetIndString(scm, 4000, 4);							// " cm"		s[0] = 1; s[1] = '?';		if(dp.ms->Groesse) NumToString(dp.ms->Groesse, s);		ConcatPString(s, scm); P2CStr(s);		PrintString((char*)s, 200, 40);		if(!lSelect) return;								// Zelle nicht selektiert? => raus	}	LMSetHiliteMode(~(1<<hiliteBit) & LMGetHiliteMode());	// hiermit wird unter Color QuickDraw bei InvertRect() nicht invertiert, sondern mit der Hilite Color (Kontrollfeld) selektiert	InvertRect(&r);											// Zelle ist selektiert}/*** *	Suchfunktion in ModellStruct* Liste ***/pascal short			LDEFBrowserSearchFunk(Ptr cellDataPtr, Ptr searchDataPtr, short cellDataLen, short searchDataLen){	if(cellDataLen != sizeof(LDEFBrowserStruct)) DebugStr("\pListe fehlerhaft");	// Liste fehlerhaft!	LDEFBrowserStruct	ms = *(LDEFBrowserStruct*)cellDataPtr;	if(IUMagIDString(ms.ms->Modellname, searchDataPtr, strlen(ms.ms->Modellname), searchDataLen) == 0)		return false;						// Einträge sind gleich!	if(IUMagString(ms.ms->Modellname, searchDataPtr, strlen(ms.ms->Modellname), searchDataLen) == 1)		return false;						// gesuchter Eintrag liegt hinter dem aktuellen Eintrag	return true;}/*** *	gewählte Objekte öffnen ***/void		MCBrowser::OpenObject(Cell theCell){	UNUSED(theCell);	OpenList((gTheEvent.modifiers & optionKey) == optionKey);}/*** *	Zwei Elemente miteinander vergleichen * *	-1 = a < b *	 0 = a = b *	+1 = a > b ***/short		MCBrowser::Compare(Ptr a, Ptr b){LDEFBrowserStruct	*ma, *mb;	ma = (LDEFBrowserStruct*)a;	mb = (LDEFBrowserStruct*)b;	if(ma->ms != mb->ms)		return strcmp(ma->ms->Modellname, mb->ms->Modellname);	else		return ma->pic - mb->pic;}