/*** *	Portfolio Layout ***/#include "MCLayout.h"#include "MCWindTools.h"#include "Utilities.h"#include "MCInfo.h"#include "MCView.h"#include "MCHeadsheet.h"#include "ScrapBase.h"#include "PrintSedcard.h"#include "PrintPict.h"#include "GlobalLib.h"#include <string.h>#include <LFileStream.h>#include <LowMem.h>/*** *	Portfolio-Layout Fenster fŸr ein Modell erzeugen ***/void			MCLayout::Create(long mid){LDEFLayoutStruct	*dp;extern short		PLayoutWidth;			// Gesamtbreite und -hšhe eines Bildesextern short		PLayoutHeight;ModellStruct		*ms = DB_MGet(mid);		// Modell suchenint					i;Str255				name, s;	if(!ms) return;						// kein Modell mit der ID gefunden => raus	// Struktur-Array fŸr die LDEF-Klasse vorbereiten	dp = (LDEFLayoutStruct*)NewPtr(ms->PicAnz * sizeof(LDEFLayoutStruct));	ThrowIfMemFail_(dp);	for(i=0; i<ms->PicAnz; i++) {		dp[i].ms = ms;					// Ptr auf das Modell (daran kommen wir wŠhrend der LDEF sonst nicht ran)		dp[i].pic = i + 1;				// Bild-Nummer	}	strcpy((char*)name, ms->Modellname); C2PStr((char*)name);	// Namen des Modells an den Fenstertitel hŠngen	GetIndString(s, 4005, 8);	ConcatPString(name, s);				// String zwischen Modell und Agentur (z.B. " (")	if(AList) {		strcpy((char*)s, AList->FindId(ms->Agentur)->GetName()); C2PStr((char*)s);			// Namen der Agentur		ConcatPString(name, s);	}	GetIndString(s, 4005, 9);	ConcatPString(name, s);				// String nach der Agentur (z.B. ")")	// Window erstellen	MCLayout		*ml = new MCLayout;	ml->Open(PLayoutHeight,PLayoutWidth, 100,5, 4005, name, ms->PicAnz, sizeof(LDEFLayoutStruct), (Ptr)dp, nil, 0L);	DisposePtr((Ptr)dp);}/*** *	Headsheet-Daten dem Finder zur VerfŸgung stellen ***/OSErr			MCLayout::SSendData(FlavorType theFlavor, ItemReference theItem, DragReference theDrag){OSErr			iErr;	if(theFlavor != gSignature)			// die eigene Signatur?		return badDragFlavorErr;	// Zielort des Drags ermitteln	AEDesc		dropLocation;	iErr = GetDropLocation(theDrag, &dropLocation);	if(iErr) return iErr;	// ein null-Descriptor? Dat war wohl nixÉ	if(dropLocation.descriptorType == typeNull) {		AEDisposeDesc(&dropLocation);		return noErr;	}	// wir wollen einen FSSpec bekommenÉ	AEDesc			dropSpec;	iErr = AECoerceDesc(&dropLocation, typeFSS, &dropSpec);	AEDisposeDesc(&dropLocation);	if(iErr != noErr) return iErr;				// Éhat nicht geklappt => raus	FSSpec		target = *(FSSpec *)*dropSpec.dataHandle;	// FSSpec des Zielverzeichnisses	AEDisposeDesc(&dropSpec);	// dirID des Ordners ermitteln	CInfoPBRec		thePB;	thePB.dirInfo.ioNamePtr = (StringPtr) &target.name;	thePB.dirInfo.ioVRefNum = target.vRefNum;	thePB.dirInfo.ioFDirIndex = 0;	thePB.dirInfo.ioDrDirID = target.parID;	iErr = PBGetCatInfoSync(&thePB);	target.parID = thePB.dirInfo.ioDrDirID;	// einen Filenamen ermitteln, der noch nicht benutzt wurde	// 1. Versuch: Defaultfilename aus der Resource	// 2. Versuch: Defaultfilename + " " + 1	// 3. Versuch: Defaultfilename + " " + 2	// n. Versuch: Defaultfilename + " " + n-1	short		refNum;	long		l = 1;	Str15		tempStr;	tempStr[0] = 0;	do {		GetIndString(target.name, 900, 1);	// Filenamen lesen		if(tempStr[0]) {			ConcatPString(target.name, "\p ");			ConcatPString(target.name, tempStr);		}		iErr = FSpOpenDF(&target, fsCurPerm, &refNum);		if(iErr == noErr)			FSClose(refNum);		NumToString(l++, tempStr);	} while(iErr == noErr);	// Datei erzeugen	short		count;	LDEFHeadsheetStruct	*data = (LDEFHeadsheetStruct*)GetSelectedData(count);		// Daten im Headsheet Window holen	iErr = noErr;	if(count) {		// Ptr auf ModellStruct in Modell-IDs wandeln		for(int i=0; i<count; i++)			data[i].ms = (ModellStruct*)data[i].ms->Id;		try {			LFileStream		theFile(target);			try {				theFile.CreateNewDataFile(gSignature, gSignature, smSystemScript);			}			catch(PP_PowerPlant::ExceptionCode inErr) {			} 			theFile.OpenDataFork(fsCurPerm);			theFile.WriteDataFork(data, count * sizeof(LDEFHeadsheetStruct));			iErr = noErr;		}		catch(PP_PowerPlant::ExceptionCode inErr) {			iErr = inErr;		}	}	DisposePtr((Ptr)data);	if(iErr) return iErr;	iErr = SetDragItemFlavorData(theDrag, theItem, gSignature, (Ptr)&target, sizeof(target), nil);	return iErr;}/*** *	Draggen eines (oder mehrerer) Objekte starten ***/OSErr			MCLayout::SStartDrag(EventRecord *theEvent){DragReference		theDrag;RgnHandle			dragRegion;	ThrowIfOSErr_(NewDrag(&theDrag));		// Drag starten	// Flavor hinzufŸgen	LDEFHeadsheetStruct	*ms;	short		index, count;	ms = (LDEFHeadsheetStruct*)GetSelectedData(count);	for(index = 1; count-- > 0; index++, ms++) {		// Items innerhalb von Mastercast		ThrowIfOSErr_(AddDragItemFlavor(theDrag, index, 'intr', ms, sizeof(LDEFHeadsheetStruct), flavorSenderOnly));	}	DisposePtr((Ptr)ms);	// _ein_ mastercast Headsheet-File	PromiseHFSFlavor	hfsFlavor;	hfsFlavor.fileType = gSignature;	hfsFlavor.fileCreator = gSignature;	hfsFlavor.fdFlags = 0;	hfsFlavor.promisedFlavor = gSignature;	ThrowIfOSErr_(AddDragItemFlavor(theDrag, 1, flavorTypePromiseHFS, &hfsFlavor, sizeof(hfsFlavor), flavorNotSaved));	ThrowIfOSErr_(AddDragItemFlavor(theDrag, 1, gSignature, nil, 0L, 0));	DragSendDataUPP	dsd = NewDragSendDataProc(MySendDataProc);	SetDragSendProc(theDrag, dsd, this);	// Region fŸr alle selektierten Daten erzeugen	dragRegion = SelectedDataRgn();	// Region in umrahmte Rechtecke wandeln	RgnHandle	theRgn = NewRgn();	CopyRgn(dragRegion, theRgn);	InsetRgn(theRgn, 1, 1);	DiffRgn(dragRegion, theRgn, dragRegion);	DisposeRgn(theRgn);	SetDragItemBounds(theDrag, 1, &(*dragRegion)->rgnBBox);	// alle Objekte werden umschlossen	// Drag durchfŸhren	TrackDrag(theDrag, theEvent, dragRegion);	// Drag beenden	DisposeRgn(dragRegion);		ThrowIfOSErr_(DisposeDrag(theDrag));	return noErr;}/*** *	MenŸpunkt aufgerufen ***/Boolean			MCLayout::DoCommand(long cmd){short		count;int			i;	switch(cmd) {	case cPrint:			LDEFLayoutStruct	*psp = (LDEFLayoutStruct*)GetSelectedData(count);			Boolean		cancel = false;			Boolean		psedcard = DialogBase::Do(141) == 1;			if(psedcard) {		// nur eine Sedcard drucken				PrintSedcard	psed(psp[0].ms->Id, true, cancel);			} else {			// aber ggf. mehrere Bilder vom ModellÉ				for(i=0; count > 0 && !cancel; count--, i++) {					PrintPict	ppict(psp[i].ms->Id, psp[i].pic, i == 0, cancel);				}			}			DisposePtr((Ptr)psp);			break;	case cOpenwtPInfo:			LDEFHeadsheetStruct	*isp = (LDEFHeadsheetStruct*)GetData(count);			MCInfo::Create(isp->ms->Id);			DisposePtr((Ptr)isp);			break;	case cOpenHeadsheet:			LDEFHeadsheetStruct	*hsp = (LDEFHeadsheetStruct*)GetSelectedData(count);			MCHeadsheet::Create(count, hsp);			DisposePtr((Ptr)hsp);			break;	case cCopy:			theScrap.ClrScrap();			LDEFLayoutStruct	*bs = (LDEFLayoutStruct*)GetSelectedData(count);			for(i=0; count > 0; count--, i++)				theScrap.AddScrap(bs[i].ms, bs[i].pic);			DisposePtr((Ptr)bs);			break;	default:			return MCLDEF::DoCommand(cmd);	}	return true;}/*** *	Befehle bei Bedarf enablen ***/void			MCLayout::GetCommandStatus(long cmd, Boolean &enabled, short &markChar, Str255 &name){	switch(cmd) {	case cPrint:			if(CountSelectedData() > 0)				enabled = true;			break;	case cOpenwtPInfo:			enabled = true;			break;	case cOpenHeadsheet:	case cCopy:			enabled = CountSelectedData() >= 1;			break;	default:			MCLDEF::GetCommandStatus(cmd, enabled, markChar, name);	}}/*** *	LDEF Funktion fŸr den Browser ***/void			MCLayout::LDEFCallback(short lMessage, Boolean lSelect, Rect *lRect, Cell lCell, short lDataOffset, short lDataLen, ListHandle lHandle){Rect			iRect;#define BrowseFrame			3		// Rahmenbreiteshort			x, y;RgnHandle		theRgn1, theRgn2;	UNUSED(lCell); UNUSED(lDataLen);	// Daten des aktuellen Modells	LDEFLayoutStruct	dp = *(LDEFLayoutStruct*)((*(*lHandle)->cells) + lDataOffset);	// iRect enthŠlt nach den folgenden Zeilen das ma§stabsgetreu verkleinerte Bild, da§ genau in das	// vorgegebene Rechteck pa§t und zudem dortdrin zentriert ist.	x = CellSize.h - 2 * BrowseFrame;						// max. Bildbreite abzgl. Rahmen um das Bild	y = CellSize.v - 2 * BrowseFrame;						// max. Bildhšhe	SetRect(&iRect, 0,0,x,y);	GetPictRect(dp.ms->Id, dp.pic, iRect, false, true);		// Bild auf den Rahmen skalieren	iRect.left = (x - iRect.right) >> 1;					// Bild zentrieren	iRect.top = ((y - iRect.bottom) >> 1);	iRect.right += iRect.left;	iRect.bottom += iRect.top;	OffsetRect(&iRect, /*h +*/ BrowseFrame, /*v +*/ BrowseFrame);	// um den Rahmen verschieben	OffsetRect(&iRect, lRect->left, lRect->top);			// und um den Zellen-Offset	if(lMessage == lDrawMsg) {		theRgn1 = NewRgn(); RectRgn(theRgn1, lRect);		InsetRect(&iRect, -1, -1);		theRgn2 = NewRgn(); RectRgn(theRgn2, &iRect);		InsetRect(&iRect, 1, 1);		DiffRgn(theRgn1, theRgn2, theRgn1);		DisposeRgn(theRgn2);		EraseRgn(theRgn1);									// Hiermit lšschen wir _nur_ das Rechteck UM das Bild herum		DisposeRgn(theRgn1);								// => es flackert nicht!		DrawPic(dp.ms->Id, dp.pic, iRect, true, false);		// Bild zentriert zeichnen		if(!lSelect) return;	}	theRgn1 = NewRgn(); RectRgn(theRgn1, lRect);	theRgn2 = NewRgn(); RectRgn(theRgn2, &iRect);	DiffRgn(theRgn1, theRgn2, theRgn1);	DisposeRgn(theRgn2);	LMSetHiliteMode(~(1<<hiliteBit) & LMGetHiliteMode());	// hiermit wird unter Color QuickDraw bei InvertRect() nicht invertiert, sondern mit der Hilite Color (Kontrollfeld) selektiert	InvertRgn(theRgn1);										// Rechteck um das Bild herum hiliten	DisposeRgn(theRgn1);}/*** *	gewŠhlte Objekte šffnen ***/void		MCLayout::OpenObject(Cell theCell){LDEFLayoutStruct	*ms;short				index, count;	UNUSED(theCell);	ms = (LDEFLayoutStruct*)GetSelectedData(count);	for(index = 0; index < count; index++) {		MCView		*ww = new MCView;		ww->Open(ms->ms->Id, ms->pic);	}	DisposePtr((Ptr)ms);}/*** *	Zwei Elemente miteinander vergleichen * *	-1 = a < b *	 0 = a = b *	+1 = a > b ***/short		MCLayout::Compare(Ptr a, Ptr b){LDEFLayoutStruct	*ma, *mb;	ma = (LDEFLayoutStruct*)a;	mb = (LDEFLayoutStruct*)b;	if(ma->ms != mb->ms)		return strcmp(ma->ms->Modellname, mb->ms->Modellname);	else		return ma->pic - mb->pic;}