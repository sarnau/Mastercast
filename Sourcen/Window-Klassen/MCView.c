/*** *	View eines einzelnen Bildes * *	©1994 Dekotec Abt. Info-Sys, Markus Fritze ***/#include "MCView.h"#include "mc_db.h"#include "MCWindTools.h"#include "Utilities.h"#include "DialogBase.h"#include "DoEvent.h"#include "GlobalLib.h"#include "PrintSedcard.h"#include "PrintPict.h"#include <FixMath.h>#include <string.h>#include <Scrap.h>/*** *	MenŸpunkt aufgerufen ***/Boolean		MCView::DoCommand(long cmd){	switch(cmd) {	case cCopy:			PicHandle		thePict;			OSErr	iErr = GetPictHandle(ModellId, Pict, true, &thePict);			if(iErr) break;			ZeroScrap();		// Clipboard lšschen			HLock((Handle)thePict);			PutScrap(GetHandleSize((Handle)thePict),'PICT',*(Handle)thePict);			HUnlock((Handle)thePict);			KillPicture(thePict);			break;	case cPrint:			Boolean		cancel;			if(DialogBase::Do(141) == 1) {				PrintPict	ppict(ModellId, Pict, true, cancel);			} else {				PrintSedcard	psed(ModellId, true, cancel);			}			break;	default:			return WindowBase::DoCommand(cmd);	}	return true;}/*** *	Befehle bei Bedarf enablen ***/void		MCView::GetCommandStatus(long cmd, Boolean &enabled, short &markChar, Str255 &name){	switch(cmd) {	case cCopy:	case cPrint:			enabled = true;			break;	default:			WindowBase::GetCommandStatus(cmd, enabled, markChar, name);	}}/*** *	Windowtitel setzen ***/void		MCView::SetTitle(void){ModellStruct	*ms;Str15			numStr;Str255			newTitle;	if(!WindRef) return;	ms = DB_MGet(ModellId);			// Modell suchen	strcpy((char*)newTitle, ms->Modellname);	C2PStr((char*)newTitle);	ConcatPString(newTitle, "\p #");	NumToString(Pict, numStr);	ConcatPString(newTitle, numStr);	if(Zoom < 0) {		ConcatPString(newTitle, "\p  1:");		NumToString(-Zoom + 1, numStr);		ConcatPString(newTitle, numStr);	} else {		ConcatPString(newTitle, "\p  ");		NumToString(Zoom + 1, numStr);		ConcatPString(newTitle, numStr);		ConcatPString(newTitle, "\p:1");	}	SetWTitle((WindowPtr)WindRef, newTitle);}/*** *	Bild-Rechteck an die Zoom-Stufe anpassen ***/void		MCView::WindToZoom(void){	PictRect = PictDefaultRect;	if(Zoom < 0) {			// Verkleinern		PictRect.right = (PictDefaultRect.right - PictDefaultRect.left) / (-Zoom + 1) + PictDefaultRect.left;		PictRect.bottom = (PictDefaultRect.bottom - PictDefaultRect.top) / (-Zoom + 1) + PictDefaultRect.top;	} else if(Zoom > 0) {	// Vergrš§ern		PictRect.right = (PictDefaultRect.right - PictDefaultRect.left) * (Zoom + 1) + PictDefaultRect.left;		PictRect.bottom = (PictDefaultRect.bottom - PictDefaultRect.top) * (Zoom + 1) + PictDefaultRect.top;	}	SetTitle();}/*** *	View šffnen ***/void		MCView::Open(long mid, short pic){	PictGWorld = nil;	ModellId = mid;	Pict = pic;	GetPictRect(mid, pic, PictDefaultRect, true, false);		// Bildgrš§e ermitteln	Rect	r;	int		h, v;	h = qd.screenBits.bounds.right - qd.screenBits.bounds.left;	// Ausma§e des Hauptbildschirms holen	v = qd.screenBits.bounds.bottom - qd.screenBits.bounds.top;	r.top=18+ GetMBarHeight() + 3; r.left=2 + 36; r.bottom=v - 3 - (ScrollBar_Size - 1); r.right=h - 3 - (ScrollBar_Size - 1);	Zoom = 1;		// mit 2fachem Zoom anfangen!	WindToZoom();	while((PictRect.right-PictRect.left-1) > (r.right-r.left-1) ||			(PictRect.bottom-PictRect.top-1) > (r.bottom-r.top-1)) {		Zoom--;					// verkleinern, bis das Bild ganz auf den Screen pa§t!		WindToZoom();	}	v = PictRect.bottom - PictRect.top;	h = PictRect.right - PictRect.left;	r.right = r.left + h + (ScrollBar_Size - 1);	r.bottom = r.top + v + (ScrollBar_Size - 1);	// Fenster šffnen	WindowScroll::Open(r, "\p", h, v, 10, 10);	SetTitle();	Show();	Select();	SetupGWorld();}/*** *	Bild - wenn mšglich - in eine GWorld entpacken ***/#include "GlobalLib.h"void			MCView::SetupGWorld(void){	if(PictGWorld) {		DisposeGWorld(PictGWorld);		PictGWorld = nil;	}	// Beim PowerMac kann man die Offscreen Bitmap auch weglassen - bringt kaum noch wasÉ	// Bild in optimaler Grš§e in eine Offscreen-Pixmap	CGrafPtr		port;	GDHandle		gdh;	PixMapHandle	pixBase;	// eine extrem Ÿble Zeile, die aber nichts anderes tut, als die maximale Bittiefe aller Bildschirme zu ermitteln	// die AufschlŸsselung:	// 1. GetGrayRgn() => Region aller Bildschirme	// 2. GetMaxDevice() => Bildschirm mit der grš§ten Tiefe ermitteln	// 3. É => aus der PixMap des Devices die Tiefe holen	short			pixelSize = (*(*GetMaxDevice(&(*GetGrayRgn())->rgnBBox))->gdPMap)->pixelSize;	GetGWorld(&port, &gdh);	if(NewGWorld(&PictGWorld, pixelSize, &PictRect, nil, nil, 0L) == noErr) {		SetGWorld(PictGWorld, nil);		pixBase = GetGWorldPixMap(PictGWorld);		LockPixels(pixBase);		EraseRect(&PictRect);			// Hintergrund komplett lšschen		biene();		DrawPic(ModellId, Pict, PictRect, true, true);		pfeil();		UnlockPixels(pixBase);	}	SetGWorld(port, gdh);}/*** *	evtl. GWorld freigeben ***/				MCView::~MCView(){	if(PictGWorld) {					// noch eine GWorld offen?		DisposeGWorld(PictGWorld);		// diese dann schlie§en		PictGWorld = nil;	}}/*** *	View-Window zeichnen ***/void			MCView::Draw(long xOffset, long yOffset, Rect visRect){	UNUSED(visRect);	Rect	r = PictRect;	::OffsetRect(&r, -xOffset, -yOffset);	if(PictGWorld) {		ForeColor(blackColor);		BackColor(whiteColor);		PixMapHandle	pixBase = GetGWorldPixMap(PictGWorld);		LockPixels(pixBase);		CopyBits((BitMap*)*pixBase, &((WindowPtr)WindRef)->portBits, &PictRect, &r, srcCopy, nil);		UnlockPixels(pixBase);	} else {		DrawPic(ModellId, Pict, r, true, true);	}}/*** *	Klick ins View-Window (Zoom In\Out) * *	Dabei wird die Position des Mausklicks beachtet und zur entsprechenden Position gezoomt ***/void			MCView::Klick(Point thePoint, short clicks, Boolean &onItem){Rect			theRect;	GetVisRect(theRect);	if(PtInRect(thePoint, &theRect)) {		Fixed	xx = FixDiv(Long2Fix(thePoint.h + oGetControlValue(hScroller)), Long2Fix(PictRect.right - PictRect.left - 1));		Fixed	yy = FixDiv(Long2Fix(thePoint.v + oGetControlValue(vScroller)), Long2Fix(PictRect.bottom - PictRect.top - 1));		// Zoomstufe neu setzen		if(gTheEvent.modifiers & optionKey)		// Option gedrŸckt?			Zoom--;		else			Zoom++;		WindToZoom();			// Variable ÒPictRectÓ updaten, Fenstertitel ebenfalls		// Windowgrš§e intern neu setzen		viewWidth = PictRect.right - PictRect.left;		viewHeight = PictRect.bottom - PictRect.top;		SetPt(&MaxSize, viewWidth + 16, viewHeight + 16);		Adjust();		SetupGWorld();		// Sliderpositionen neu setzen		oSetControlValue(hScroller, Fix2Long(FixMul(xx, Long2Fix(viewWidth))) - ((theRect.right - theRect.left) >> 1));		oSetControlValue(vScroller, Fix2Long(FixMul(yy, Long2Fix(viewHeight))) - ((theRect.bottom - theRect.top) >> 1));		// Gesamtes Window neu ausgeben		EraseRect(&theRect);		InvalRect(&theRect);	} else {		WindowScroll::Klick(thePoint, clicks, onItem);	}}/*** *	Default-Mauszeiger fŸr die Fenster setzen ***/void		MCView::MausMoved(Point thePoint, RgnHandle *mouseRgn){Rect		theRect;	UNUSED(mouseRgn);	theRect = (*((WindowPeek)WindRef)->contRgn)->rgnBBox;	// Rechteck des Windowinhaltes	theRect.right -= (ScrollBar_Size - 1); theRect.bottom -= (ScrollBar_Size - 1)	;	// Slider abziehen	if(PtInRect(thePoint, &theRect)) {		if(gTheEvent.modifiers & optionKey)		// mit Option wird herausgezoomt			FetchCursor(129);		// Lupe -		else			FetchCursor(128);		// Lupe +	} else {		pfeil();	}}