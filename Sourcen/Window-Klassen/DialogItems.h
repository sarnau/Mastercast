/*** *	Dialogbox-Klasse * *	©1994 Dekotec Info-Sys, Markus Fritze ***/#pragma once#include "GlobalDefines.h"#ifndef __LISTS__	#include <Lists.h>#endifclass DialogBase;// Beschreibung der DObj-Resource, die zusätzliche Infos zur Dialogbox enthält#define DObj_ResType		'DObj'enum {	NothingSpecial = 0,	RadioGroup,	ProgressBar,	List,	TextEdit,	DialogFont};#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endiftypedef struct {	short		item;			// Item-Index	char		key;			// Tastatur-Shortcut	char		filler;			// Füllbyte - ohne Funktion	short		modifierflags;	// Bit 15: Command Flag - Bit 14: Command testen?								// Bit 13: Control Flag - Bit 12: Control testen?	long		data;			// Handle o.ä. während des Programmlaufes	DialogBase	*dBasePtr;		// *this der DialogBase	short		type;			// Typ des Items (0 = kein besonderes Item)	union {		// Radiobutton Gruppe (zur automatischen Deselektierung)		struct {			short	id;				// zu welcher Radio-Button-Gruppe gehört das Item?		} radio;		// Progress-Bar		struct {			short	maxval;			// maximaler Wert für den Progress Bar		} progress;		// ListManager Liste		struct {			short	resid;			// STR# ID von Objekten die eingefügt werden sollen (0 = keine)			short	flags;			// Bit 15 : true, wenn Items anwählbar sind									// Bit 14 : true, wenn V-Slider vorhanden ist									// Bit 13 : true, wenn H-Slider vorhanden ist			short	procId;			// ProcId der LDEF			short	selflags;		// Flags für Mehrfachselektierung, etc. => (*ListHandle)->selFlags			long	selected;		// vorselektierte Items			long	mask;			// ausgewählte Items		} list;		// TextEdit Feld		struct {			short	maxlen;			// maximale Länge des Feldes			char	onlyNumbers;	// true, wenn nur Ziffern eingegeben werden dürfen		} textedit;		// Dialog-Font setzen		struct {			short	fondId;			// maximaler Wert für den Progress Bar		} dialogfont;		// Dummy-Eintrag um den Union größer zu machen (für spätere Erweiterungen)		struct {			short	dummy[16];		} dummy;	};} DObjItem, *DObjItemPtr;typedef struct {	short		count;				// Anzahl der Items in der folgenden Liste	DObjItem	items[1];			// Liste der Items} DObj, *DObjPtr, **DObjHandle;#if defined(powerc) || defined(__powerc)#pragma options align=reset#endif// Beschreibung eines Dialog-Itemsclass DialogItem {public:	DObjItemPtr		itemObject;	// aktuelles Objekt - wird ständig angepaßt// der Destruktor ist überflüssig, da die Klassen nie gelöscht werden. Von jedem Item gibt es// nur genau _ein_ statisches Objekt (und das auch ohne Konstruktor)//	virtual			~DialogItem() {};	virtual void	Init(void) {};	virtual void	Draw(void) {};	virtual void	Klick(Point p, short clicks) { UNUSED(p); UNUSED(clicks); };	virtual void	Exit(void) {};	virtual void	Activate(Boolean flag) { UNUSED(flag); };};/*** *	Beschreibung eines List-Items ***/class DialogListItem : public DialogItem {public:	void			Init(void);	void			Draw(void);	void			Klick(Point p, short clicks);	void			Exit(void);	void			Activate(Boolean flag);	void			StrToList(short strListID, unsigned long bitmask);	unsigned long	GetSelList(void);	void			SetSelList(unsigned long bitm);	short			AddList(StringPtr s);	short			SortToList(StringPtr s);	ListHandle		GetList(void);};/*** *	Beschreibung eines Progress-Bar-Items ***/class ProgressBarItem : public DialogItem {public:	void			Init(void);	void			Draw(void);	void			SetValue(short val);	short			GetValue(void);	void			SetMaxValue(short val);	short			GetMaxValue(void);};/*** *	Beschreibung eines Progress-Bar-Items ***/class DialogFontItem : public DialogItem {public:	void			Init(void);};// Array mit Ptr auf die Item-Klassenextern DialogItem		*DItems[];