/*** *	Selektions-Fenster ***/#include "MCSelection.h"#include "DoEvent.h"#include "Geos.h"#include "GlobalLib.h"#include "mc_db.h"#include "MCWindTools.h"#include "OffscreenObject.h"#include <string.h>#include <packages.h>#include <balloons.h>MCSelection		*WWSelection;/*** *	Selections-Fenster öffnen bzw. toppen ***/void			MCSelection::Create(void){	if(!WWSelection) {			// Selektion ist schon offen		WWSelection = new MCSelection;		WWSelection->Open();	} else {		WWSelection->Select();	}}/*** *	beim Löschen der Selektion, die Variable ebenfalls löschen ***/				MCSelection::~MCSelection(){	if(ModFoundList) {			// Liste der gefundenen Modelle freigeben		DisposePtr((Ptr)ModFoundList);		ModFoundList = nil;	}	if(InfoUI) {				// UPP des Infozeilen-UserItems		DisposeRoutineDescriptor(InfoUI);		InfoUI = nil;	}	WWSelection = nil;}/*** *	Menüpunkt aufgerufen ***/Boolean			MCSelection::DoCommand(long cmd){	switch(cmd) {	case cOpenHeadsheet:			MCHeadsheet::Create(ModFound, ModFoundList);			break;	default:			return DialogBase::DoCommand(cmd);	}	return true;}/*** *	Befehle bei Bedarf enablen ***/void			MCSelection::GetCommandStatus(long cmd, Boolean &enabled, short &markChar, Str255 &name){	switch(cmd) {	case cOpenHeadsheet:	// nur enablen, wenn mindestens ein Modell gefunden wird			enabled = ModFound >= 1;			break;	default:			DialogBase::GetCommandStatus(cmd, enabled, markChar, name);	}}/*** *	Infozeile zeichnen (statische UserItem-Redraw Funktion) ***/pascal void		MCSelection::DrawInfoline(WindowPtr theWindow, short itemNo){MCSelection		*This = (MCSelection*)WindowBase::Class(theWindow);	Rect			r;	This->GetItemRect(itemNo, &r);	OffscreenObject	ob(theWindow, &r);		// Offscreen zeichnen (das Kopieren auf den Bildschirm macht der Destructor!)	//  und doppelt unterstreichen	MoveTo(r.left, r.bottom - 1); Line(r.right - r.left, 0);	MoveTo(r.left, r.bottom - 3); Line(r.right - r.left, 0);	FontInfo		fInfo;	short			lineHeight;	SetFont(5001);	GetFontInfo(&fInfo);	lineHeight = fInfo.ascent + fInfo.leading;	// Höhe einer Textzeile ermitteln	// Anzahl der vorhandenen Datensätze ausgeben	Str255			theString,theStr2;	if(ModellAnz < 2) {		GetIndString(theString, 4008, (ModellAnz == 0)?1:2);	} else {		NumToString(ModellAnz, theString);		GetIndString(theStr2, 4008, 3);		ConcatPString(theString, theStr2);	}	MoveTo(9, 2 + lineHeight);	short		slen = StringWidth(theString) + 8 + 9;	// Offset des Strings, an dem der rechte String minimal anfangen darf (damit es keine Überlappung gibt)	DrawString(theString);	// Anzahl der gefundenen Datensätze ausgeben	if(This->ModFound < 2) {		GetIndString(theString, 4008, (This->ModFound == 0)?4:5);	} else {		NumToString(This->ModFound, theString);		GetIndString(theStr2, 4008, 6);		ConcatPString(theString, theStr2);	}	short		spos = r.right - StringWidth(theString) - 5;	// Wunschposition errechnen	if(spos < slen)								// zu weit links?		spos = slen;							// dann etwas nach rechts rücken (der Text wird somit nicht mehr ganz dargestellt)	MoveTo(spos, 2 + lineHeight);	DrawString(theString);}/*** *	Selektion öffnen ***/void		MCSelection::Open(void){	WWSelection = this;	InfoUI = nil;	ModFound = 0;	ModFoundList = nil;	DialogBase::Open(500);	short		lineHeight;	FontInfo	fInfo;	SetGraphicPort();	GetFontInfo(&fInfo);	lineHeight = fInfo.ascent + fInfo.descent + fInfo.leading;	// Infotexte an den TextEdit Feldern an die entsprechenden Felder ranziehen	for(int theItem=37; theItem<55; theItem+= 3) {		Handle	iHandle;		Rect	iRect;		Str255	theString;		GetItemRect(theItem, &iRect);		iHandle = GetCH(theItem);		theString[0] = GetHandleSize(iHandle);		BlockMoveData(*iHandle, theString + 1, theString[0]);		iRect.left = iRect.right - StringWidth(theString) - 5;	// 5 Pixel Abstand zum TextEdit Feld		iRect.bottom = iRect.top + lineHeight;		SetItemRect(theItem, &iRect);		GetItemRect(theItem + 1, &iRect);		iRect.bottom = iRect.top + lineHeight;		SetItemRect(theItem + 1, &iRect);		GetItemRect(theItem + 2, &iRect);		iRect.bottom = iRect.top + lineHeight;		SetItemRect(theItem + 2, &iRect);	}	InfoUI = NewUserItemProc(MCSelection::DrawInfoline);	SetUserItem(55, InfoUI);	// Modellagenturen in die Liste (Item #2) sortieren	DialogListItem	*dlp = (DialogListItem*)GetObject(2);	if(dlp && AList) {		TListIterator	t(AList);		Agentur			*a;		if((a = (Agentur*)t.First()) != nil) {			// erste Agentur ermitteln? Kein da? => raus!			do {				Str255		theString;				strcpy((char*)theString, a->GetName());				C2PStr((char*)theString);				dlp->SortToList(theString);				// in die Liste einsortieren			} while((a = (Agentur*)t.Next()) != nil);	// zur nächsten Agentur		}	}	SearchAgain();			// einmal das Suchen aufrufen	Select();	Show();}/*** *	Tastendrücke abfangen ***/Boolean			MCSelection::EventKey(char key, short modifiers){Boolean		ret = DialogBase::EventKey(key, modifiers);	SearchAgain();	return ret;}/*** *	Mausklick abfangen ***/void			MCSelection::EventKlick(Point p, short clicks){	DialogBase::EventKlick(p, clicks);	SearchAgain();}/*** *	ein Button wurde angeklickt ***/void			MCSelection::Button(short button){	switch(GetItemType(button) & ~resCtrl) {	// welches Control?	case ctrlItem:		ToggleButton(button);		SearchAgain();		LastBalloon = 0;						// Balloon Help zurücksetzen!		break;	case statText:	// Klick auf den Text vor der Liste => alle Elemente der Liste deselektieren		if(button > 36) break;					// Text gehört nicht mehr zur Liste		DialogListItem	*dlp = (DialogListItem*)GetObject(button + 1);		if(dlp) {			dlp->SetSelList(0L);				// alle Zellen deselektieren			SearchAgain();		}		break;	}	SelectTitle(1, true);}/*** *	Default-Mauszeiger für die Fenster setzen * *	Hier: Balloon Help setzen ***/void			MCSelection::MausMoved(Point thePoint, RgnHandle *mouseRgn){GrafPtr			savePort;	UNUSED(mouseRgn);	if(!gBalloonHelp) return;			// Balloon Help nicht vorhanden => raus	GetPort(&savePort);	SetPort((WindowPtr)WindRef);	GlobalToLocal(&thePoint);	int	dItem = FindDialogItem((DialogPtr)WindRef, thePoint) + 1;	SetPort(savePort);	if(!dItem || !HMGetBalloons()) {	// über keinem Item oder Balloon Help aus?		LastBalloon = 0;				// => Variable entsprechend zurücksetzen		return;							// Balloon Help ist aus => raus	}	if(!HMIsBalloon())					// kein Balloon sichtbar?		LastBalloon = 0;				// => Variable entsprechend zurücksetzen	if(LastBalloon == dItem) return;	// Item unverändert?	GetPort(&savePort);	SetPort((WindowPtr)WindRef);	Rect		theRect;	GetItemRect(dItem, &theRect);		// Rechteck des Items ermitteln	// Help-Message aus der hdlg-Resource extrahieren	short		whichState = GetButton(dItem) ? kHMCheckedItem : kHMEnabledItem;	if(dItem == 55) {					// Infozeile?		short	mid = theRect.left + ((theRect.right - theRect.left) >> 1);		if(mid < thePoint.h) {			whichState = kHMCheckedItem;// rechtes Item nehmen			theRect.left = mid;		} else {			theRect.right = mid;		}	}	HMMessageRecord	aHelpMsg;	if(HMExtractHelpMsg(kHMDialogResType, 500, dItem, whichState, &aHelpMsg) != noErr)		return;							// kein Hilfetext vorhanden => raus	LocalToGlobalRect(&theRect);		// Itemrechteck in globale Koordinaten wandeln	// Maus-Punkt in die Mitte des Items setzen	Point		mousePos;	SetPt(&mousePos, theRect.left + ((theRect.right - theRect.left) >> 1), theRect.top + ((theRect.bottom - theRect.top) >> 1));	// Balloon rechts an den Text hängen	if(dItem == 55 && whichState == kHMCheckedItem)	// rechtes Item nehmen		mousePos.h = theRect.right - 20;	// Balloon darstellen	if(HMShowBalloon(&aHelpMsg, mousePos, &theRect, nil, 0, 0, kHMRegularWindow) == noErr)		LastBalloon = dItem;			// aktuelles Item merken	SetPort(savePort);}/*** *	Datenbank durchsuchen ***/void			MCSelection::SearchAgain(void){char			*s;	if(!AList) return;	s = NewPtrClear(2048L);	AppendAgentur(s, 2);	AppendSearch(s, 4, 0, 'b');	AppendSearch(s, 6, 0, 'c');	AppendSearch(s, 17, 18, 'x');	AppendSearch(s, 8, 0, 'o');	AppendSearch(s, 10, 0, 'q');	AppendSearch(s, 12, 0, 'p');	AppendSearch(s, 14, 15, 's');	AppendSearch(s, 20, 0, 'r');	AppendSearch(s, 23, 24, 't');	AppendSearch(s, 26, 27, 'u');	AppendSearch(s, 29, 30, 'w');	AppendSearch(s, 32, 33, 'y');	AppendSearch(s, 35, 36, 'v');	AppendSearchValue(s, 38, 'd', '<');			// Alter (Werte sind absichtlich andersherum!)	AppendSearchValue(s, 39, 'd', '>');	AppendSearchValue(s, 42, 'e', '<');			// Größe	AppendSearchValue(s, 41, 'e', '>');	AppendSearchValue(s, 45, 'f', '<');			// Brust	AppendSearchValue(s, 44, 'f', '>');	AppendSearchValue(s, 51, 'g', '<');			// Taille	AppendSearchValue(s, 50, 'g', '>');	AppendSearchValue(s, 48, 'h', '<');			// Huefte	AppendSearchValue(s, 47, 'h', '>');//	AppendSearchValue(s, 54, 'k', '<');			// Bh//	AppendSearchValue(s, 53, 'k', '>');	AppendSearchValue(s, 54, 'l', '<');			// Schuhe	AppendSearchValue(s, 53, 'l', '>');	ModFound = 0;	if(ModFoundList) DisposePtr((Ptr)ModFoundList);	ModFoundList = (LDEFHeadsheetStruct*)NewPtrClear(ModellAnz * sizeof(LDEFHeadsheetStruct));	if(ModFoundList) {		ModellStruct	**mp = DB_MFoundFirst(s);		while(mp) {			ModFoundList[ModFound].ms = *mp;			ModFoundList[ModFound].pic = 1L;			ModFound++;			mp = DB_MFoundNext(s, mp);		}		DisposePtr(s);	}	RedrawItem(55, false);						// Infozeile updaten	// evtl. aktives Menü freischalten, Toolbar updaten	AdjustMenu(this);}/*** *	Titel über einer Liste selectieren oder deselektieren ***/void			MCSelection::SelectTitle(short item, Boolean select){	UNUSED(item); UNUSED(select);#if 0TEHandle		te;Rect			r;Str255			s;	GetItemRect(item, &r);		// Rechteck des Items	GetDialogText(item, s);		// Text des Items	te = TENew(&r, &r);	TESetText(s + 1, s[0], te);	// Text setzen	TESetSelect(0, !select ? 0 : 32767, te);	// Selektion ggf. setzen	TEActivate(te);	TEUpdate(&r, te);	TEDispose(te);#endif}/*** *	Filterstring zusammensetzen ***/void			MCSelection::AppendSearch(char *s, short item, short OrItem, char Command){DialogListItem	*di = (DialogListItem*)GetObject(item);long			bitm;Str31			str;	bitm = di->GetSelList();	if(!bitm) return;			// nichts angewählt => raus	s += strlen(s);				// den Kram anhängen	*s++ = Command;				// zuerst den Befehl	if(OrItem) {		if(GetButton(OrItem) == kCntlOn)			*s++ = '&';		else			*s++ = '|';	} else {		*s++ = '|';				// OR nehmen, wenn kein Item angegeben	}	NumToString(bitm, str);	BlockMoveData(str + 1, s, str[0]);	// dann das Bitfeld}void			MCSelection::AppendAgentur(char *s, short item){DialogListItem	*di = (DialogListItem*)GetObject(item);ListHandle		l = di->GetList();Cell			c;short			i;Str255			st;short			stLen;Boolean			flag = false;TListIterator	t(AList);Agentur			*a;	for(i=0;i<(*l)->dataBounds.bottom;i++) {	// alle Zellen durchsuchen		c.h = 0; c.v = i;		if(!LGetSelect(false,&c,l))				// selektierte Zelle gefunden?			continue;		stLen = 255;		LGetCell(st, &stLen, c, l);				// Vorgänger-Zelle holen		st[stLen] = 0;		if((a = (Agentur*)t.First()) != nil) {			// erste Agentur ermitteln? Kein da? => raus!			do {				if(strcmp(a->GetName(), (char*)st))		// String gefunden?					continue;				s += strlen(s);							// den Kram anhängen				if(!flag) {					*s++ = 'a';							// zuerst den Befehl					*s++ = '|';							// Agenturen stets OR-Verknüpfen					flag = true;				} else {					*s++ = ',';				}				NumToString(a->GetId(), st);				BlockMoveData(st + 1, s, st[0]);			// ID anhängen				break;			} while((a = (Agentur*)t.Next()) != nil);	// zur nächsten Agentur		}	}}void			MCSelection::AppendSearchValue(char *s, short item, char Command, char MinMax){Str31	str;int		value;	value = GetInteger(item);	if(!value) return;			// kein Wert eingegeben	if(Command == 'd') {		// Geburtsjahr?		static DateTimeRec	dtrp;		static Boolean		init = 0;		if(init % 100)			// Datum nur alle 100 Aufrufe abfragen			GetTime(&dtrp);		init++;		value = dtrp.year - value;	// vom aktuellen Jahr abziehen (=> Geburtsjahr)	}	s += strlen(s);				// den Kram anhängen	*s++ = Command;				// zuerst den Befehl	*s++ = MinMax;				// dann den Vergleich;	NumToString(value, str);	BlockMoveData(str + 1, s, str[0]);	// dann den Wert}