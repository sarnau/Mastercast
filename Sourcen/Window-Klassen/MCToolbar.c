/*** *	Toolbar öffnen ***/#include "MCToolbar.h"#include "Utilities.h"#include <Icons.h>#include <Balloons.h>#include "MenuLib.h"#include "DialogBase.h"#include "GlobalLib.h"#define ICONSIZE		32// Befehlscodes für die einzelnen Toolslong		ToolCmdList[ToolAnz] = { cOpenSelektion, cOpenBrowser, cOpenHeadsheet, cOpenPLayout, cOpenwtPInfo, cPrint, cOpenNewCD };// die Toolbar gibt es nur einmal…MCToolbar	*WWToolbar;/*** *	beim Löschen der Toolbar die globale Variable zurücksetzen ***/				MCToolbar::~MCToolbar(){	pref.openNotAtStart = true;	WritePref(kToolbarPrefType, kToolbarPrefId, (Ptr)&pref, sizeof(pref));		// Einstellungen abspeichern	WWToolbar = nil;}/*** *	Window wurde verschoben, Position merken ***/void			MCToolbar::WindowMoved(Point p){	if(EqualPt(pref.position, p))	// nicht verändert?		return;						// => raus	Point		pp;	SetPt(&pp, 0, 10 + GetMBarHeight() + 5);	if(EqualPt(pp, p))				// Default-Position?		SetPt(&p, 0, 0);			// dann als Default in die Preferences notieren	pref.position = p;	WritePref(kToolbarPrefType, kToolbarPrefId, (Ptr)&pref, sizeof(pref));		// Einstellungen abspeichern}/*** *	Toolbar initialisieren ***/void			MCToolbar::Open(void){	ReadPref(kToolbarPrefType, kToolbarPrefId, (Ptr)&pref, sizeof(pref));	if(pref.openNotAtStart) {		pref.openNotAtStart = false;		WritePref(kToolbarPrefType, kToolbarPrefId, (Ptr)&pref, sizeof(pref));		// Einstellungen abspeichern	}	// Windowrechteck gemäß des Defaults setzen	Rect		theRect;	Str255		theString;	SetPt(&topLeft(theRect), pref.position.h, pref.position.v);	// gesichtere Position setzen	theRect.bottom = theRect.top + (pref.toolbarHorizontal ? ICONSIZE : (ICONSIZE * ToolAnz));	theRect.right = theRect.left + (pref.toolbarHorizontal ? (ICONSIZE * ToolAnz) : ICONSIZE);	// Toolbar auf dem Bildschirm zu sehen?	RgnHandle	theRgn = NewRgn();	RgnHandle	theRgn2 = NewRgn();	theRect.top -= 11;							// Höhe der Titelzeile	RectRgn(theRgn, &theRect);					// Toolbar-Window-Rechteck	theRect.top += 11;	SectRgn(GetGrayRgn(), theRgn, theRgn2);	if(!EqualRgn(theRgn, theRgn2)) {		SetPt(&topLeft(theRect), 0, 0);		SetPt(&pref.position, 0, 0);		WritePref(kToolbarPrefType, kToolbarPrefId, (Ptr)&pref, sizeof(pref));		// Einstellungen auf Default zurücksetzen	}	DisposeRgn(theRgn);	DisposeRgn(theRgn2);	if(theRect.top == 0 && theRect.left == 0) {					// Ist der Default aktiv?		SetPt(&topLeft(theRect), 0, 10 + GetMBarHeight() + 5);	// dann Vorgabeposition setzen	}	theRect.bottom = theRect.top + (pref.toolbarHorizontal ? ICONSIZE : (ICONSIZE * ToolAnz));	theRect.right = theRect.left + (pref.toolbarHorizontal ? (ICONSIZE * ToolAnz) : ICONSIZE);	GetIndString(theString, 4006, 1);	WindowBase::Open(&theRect, theString, true, kHasZoomBoxMask|kHasCloseBoxMask|kHasPaletteTitlebarMask, 0L, (WindowRefX)-1L);}/*** *	Toolbar umschalten ***/void			MCToolbar::EventZoom(short part){	UNUSED(part);	if(pref.toolbarHorizontal) {		pref.toolbarHorizontal = false;		SetSize(ICONSIZE, ICONSIZE * ToolAnz);	} else {		pref.toolbarHorizontal = true;		SetSize(ICONSIZE * ToolAnz, ICONSIZE);	}	Draw();	WritePref(kToolbarPrefType, kToolbarPrefId, (Ptr)&pref, sizeof(pref));		// Einstellungen abspeichern}/*** *	Rechteck eines Icons in der Toolbar ermitteln ***/void			MCToolbar::GetIconRect(short id, Rect &theRect){	if(pref.toolbarHorizontal) {		theRect.left = id * ICONSIZE;		theRect.top = 0;		theRect.right = theRect.left + ICONSIZE;		theRect.bottom = ICONSIZE;	} else {		theRect.top = id * ICONSIZE;		theRect.left = 0;		theRect.bottom = theRect.top + ICONSIZE;		theRect.right = ICONSIZE;	}}/*** *	folgender Befehl hat sich im Status geändert - Toolbar-Buttons updaten (en- bzw. disablen) ***/void			MCToolbar::Update(){	for(int i=0; i<ToolAnz; i++)		RedrawIcon(i);}/*** *	folgender Befehl hat sich im Status geändert - Toolbar-Buttons updaten (en- bzw. disablen) ***/void			MCToolbar::Button(long cmd){	for(int i=0; i<ToolAnz; i++) {		if(ToolCmdList[i] != cmd)	// Befehl suchen			continue;		ToolPlotIcon(i, i, true);		UInt32	finalTick;		Delay(kDelayTime, &finalTick);		ToolPlotIcon(i, i, false);	}}/*** *	einzelnes Icon neu zeichnen (nur eine Redraw Message erzeugen!) ***/void			MCToolbar::RedrawIcon(short id){Rect		theRect;GrafPtr		savePort;	GetPort(&savePort);	SetPort((GrafPtr)WindRef);	GetIconRect(id, theRect);	InvalRect(&theRect);	SetPort(savePort);}/*** *	einzelnes Icon neu zeichnen ***/void			MCToolbar::ToolPlotIcon(short id, short resid, short select){Rect		theRect;GrafPtr		savePort;	GetPort(&savePort);	SetPort((GrafPtr)WindRef);	GetIconRect(id, theRect);	// Feld um das Icon herum mit Grau füllen	RgnHandle		theRgn1 = NewRgn();	RgnHandle		theRgn2 = NewRgn();	IconIDToRgn(theRgn1, &theRect, atAbsoluteCenter, ToolBaseId + resid * 2 + select);	RectRgn(theRgn2, &theRect);				// gesamtes Feld = Region 2	DiffRgn(theRgn2, theRgn1, theRgn2);		// gesamtes Feld - Icon Region = Rahmen um das Icon	DisposeRgn(theRgn1);	RGBColor	dialogGray = { 0xDDDD, 0xDDDD, 0xDDDD };	FontStruct	saveColors;	SaveText(&saveColors);	RGBForeColor(&cWhite);	RGBBackColor(&dialogGray);	EraseRgn(theRgn2);						// Rahmen um das Icon mit Hintergrund-Grau füllen	RestoreText(&saveColors);	DisposeRgn(theRgn2);	PlotIconID(&theRect, atAbsoluteCenter,				IsCommand(ToolCmdList[id], WindowBase::BaseFrontWindow()) ? ttNone : ttDisabled,				ToolBaseId + resid * 2 + select);	SetPort(savePort);}/*** *	Toolbar komplett neu ausgeben ***/void			MCToolbar::Draw(void){	for(int i=0; i<ToolAnz; i++)		ToolPlotIcon(i, i, 0);}/*** *	Klick in die Toolbar auswerten ***/void			MCToolbar::Klick(Point p, short clicks, Boolean &onItem){short		id;Rect		theRect;Boolean		state = true;	UNUSED(clicks); UNUSED(onItem);	id = pref.toolbarHorizontal ? p.h : p.v;	id /= ICONSIZE;					// Welches Tool angeklickt?	if(!IsCommand(ToolCmdList[id], WindowBase::BaseFrontWindow())) return;		// Tool ist disabled => raus!	GetIconRect(id, theRect);		// Button-Rechteck in dem der Maus-Button gedrückt wurde	// Klick in ein Icon? Nein? => raus	GetMouse(&p);	if(!PtInIconID(p, &theRect, atAbsoluteCenter, ToolBaseId + id * 2)) return;	// Icon selektiert darstellen	ToolPlotIcon(id, id, 1);	while(WaitMouseUp()) {		GetMouse(&p);		if(PtInIconID(p, &theRect, atAbsoluteCenter, ToolBaseId + id * 2 + state)) {			if(!state) {				ToolPlotIcon(id, id, 1);				state = true;			}		} else if (state) {			ToolPlotIcon(id, id, 0);			state = false;		}	}	if(state) {						// Funktion aktiviert?		SendMenuCmd(ToolCmdList[id], WindowBase::BaseFrontWindow());	// Command ausführen		ToolPlotIcon(id, id, 0);	// Button wieder deselektieren	}}/*** *	Default-Mauszeiger für die Fenster setzen * *	Hier: Balloon Help setzen ***/void		MCToolbar::MausMoved(Point thePoint, RgnHandle *mouseRgn){GrafPtr			savePort;static short	LastBalloon = 0;Boolean			inRect = false;	UNUSED(mouseRgn); UNUSED(thePoint);	if(!gBalloonHelp) return;			// Balloon Help nicht vorhanden => raus	if(!HMGetBalloons()) {		LastBalloon = 0;				// => Variable entsprechend zurücksetzen		return;							// Balloon Help ist aus => raus	}	GetPort(&savePort);	SetPort((WindowPtr)WindRef);	Point		mousePos;	GetMouse(&mousePos);				// Mausposition in lokalen Koordinaten holen	if(!HMIsBalloon())					// kein Balloon sichtbar?		LastBalloon = 0;				// => Variable entsprechend zurücksetzen	for(int i=0; i<ToolAnz; i++) {		Rect		theRect;		GetIconRect(i, theRect);				// Rechteck des Icons holen		if(!PtInRect(mousePos, &theRect))			continue;							// nicht innerhalb des Rechtecks		inRect = true;		LocalToGlobalRect(&theRect);			// Rechteck des Icons in globale Koordinaten wandeln		// Maus-Punkt in das rechte untere Viertel des Icons setzen		SetPt(&mousePos, theRect.right - ((theRect.right - theRect.left) >> 2), theRect.bottom - ((theRect.bottom - theRect.top) >> 2));		HMMessageRecord	helpMsg;		helpMsg.hmmHelpType = khmmStringRes;	// aus einer STR# Resource lesen		helpMsg.u.hmmStringRes.hmmResID = 4006;	// Toolbar-Resource		helpMsg.u.hmmStringRes.hmmIndex = 2 + (i << 1)		// String 1 ist der Windowname, ab 2 geht es los					+ (IsCommand(ToolCmdList[i], WindowBase::BaseFrontWindow()) ? 0 : 1);	// enabled oder disabled?		if(LastBalloon == helpMsg.u.hmmStringRes.hmmIndex)	// Balloon wird schon dargestellt?			break;								// Ja => raus		// Balloon darstellen		if(HMShowBalloon(&helpMsg, mousePos, &theRect, nil, 0, 0, kHMRegularWindow) == noErr)			LastBalloon = helpMsg.u.hmmStringRes.hmmIndex;		break;	}	if(!inRect)		LastBalloon = 0;	SetPort(savePort);}