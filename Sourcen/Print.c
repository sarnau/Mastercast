/*** *	alle Routinen zum Drucken ***/#include "Print.h"#include "GlobalLib.h"#include "GlobalStruct.h"#define	JobDlgID		-8191	/* resource ID of 'Job' or 'Print' DLOG, DITL, & hdlg		 */#define	StlDlgID		-8192	/* resource ID of 'Style' or 'PageSetup' DLOG, DITL, & hdlg	 */#if 0short		PrintStlDITL = 0;		// eigene DITL-Resource-IDshort		PrintJobDITL = 0;		// eigene DITL-Resource-ID#endif// Types for accessing the Printing Manager dialog resources.static TPPrDlg	PrtJobDialog;		// pointer to job dialogstatic TPPrDlg	PrtStlDialog;		// pointer to style dialogshort			prFirstItem;		// erstes eigenes Item im Dialog-HookProcPtr			prPItemProc;		// Originalroutine fŸr Dialog-Hooktypedef pascal Boolean (*PrDialogProcPtr)(TPPrDlg theDialog, short itemNo);pascal void		MyJobItems(TPPrDlg theDialog,short itemNo);pascal TPPrDlg	MyJobDlgInit(THPrint hPrint);pascal void		MyStlItems(TPPrDlg theDialog,short itemNo);pascal TPPrDlg	MyStlDlgInit(THPrint hPrint);pascal void		PrintIdleProc(void);short			gPrintPage;DialogPtr		PrintingStatusDialog;/*** *	vormals im Dokument stehend ***/Boolean			PrintStructValid;TPrint			PrintStruct;Str255			PrintDocName;//------ IsLandscapeSet -------------------------------------------------------------////	IsLandscapeSet will determine if the user has selected landscape orientation//	from the Style dialog. If the user has selected landscape orientation, we will//	return "true" to the calling function. Otherwise, return "false".//Boolean		IsLandscapeSet(void){TGetRotnBlk	GetRotRec;Boolean		ShowLandscapeResults = false;THPrint		p;OSErr		err;	PrOpen();	err = PrError();	if ((err == fnfErr)||(err == -8172)) err = -8150;	if (!err) {		p = (THPrint)NewHandle(sizeof(TPrint)); // neue Struktur allozieren		if (!p) return(memFullErr);				// Speicher reichte nicht!		BlockMove(&PrintStruct,*p,sizeof(TPrint)); // Dokumentendaten Ÿbertragen		if (!PrintStructValid)					// War die Struktur gŸltig?			PrintDefault(p);					// Nein, erstmal initialisieren		else			PrValidate(p);						// oder nur abtesten		if (!(err = PrError())) {			GetRotRec.iOpCode = getRotnOp;			GetRotRec.hPrint = p;		 	PrGeneral((Ptr)&GetRotRec);			//	We now have the result from our call to PrGeneral, but we check all			//	known errors to make sure that PrGeneral was successful and there			//	have not been any errors encountered from printing land.			if(GetRotRec.iError == noErr && PrError() == noErr && GetRotRec.fLandscape)				ShowLandscapeResults = true;		}		DisposeHandle((Handle)p);	}	PrClose();	return ShowLandscapeResults;}#if 0/*** *	Druckersetup-Einstellungen ***/OSErr		PageSetup(void){OSErr		err;THPrint		p;	PrOpen();	err = PrError();	if(err == fnfErr || err == -8172) err = -8150;	if(!err) {		p = (THPrint)NewHandle(sizeof(TPrint)); // neue Struktur allozieren		if (!p) return(memFullErr);				// Speicher reichte nicht!		BlockMove(&PrintStruct,*p,sizeof(TPrint)); // Dokumentendaten Ÿbertragen		if (!PrintStructValid)					// War die Struktur gŸltig?			PrintDefault(p);					// Nein, erstmal initialisieren		else			PrValidate(p);						// oder nur abtesten		if (!(err = PrError())) {			pfeil();			PrtStlDialog = PrStlInit(p);		// Dialogbox laden			if (PrError() == noErr) {				PDlgInitUPP		myRD = NewPDlgInitProc(MyStlDlgInit);#if 0				if (PrintStlDITL>0)					Append2hdlg(PrintStlDITL,StlDlgID);#endif				if (PrDlgMain(p, myRD)) {					BlockMove(*p,&PrintStruct,sizeof(TPrint)); // in Dokumenten-Struktur kopieren					PrintStructValid = true;		// Dokumentendaten nun gŸltig!				} else					err = userCanceledErr;		// Abbruch!				DisposeRoutineDescriptor(myRD);			}		}		DisposHandle((Handle)p);				// Handle wieder verwerfen	}	PrClose();	return(err);}/*** * ***/OSErr	AppPrintDocument(Boolean dispose,Boolean jobDlg,Boolean firstJob){OSErr				err;THPrint				p;TPPrPort			printPort;GrafPtr				oldPort;short				i,keepResFile,fstPage,lstPage,copies;TPrStatus			status;Str63				s;static THPrint		prMergeHndl = nil;PrIdleUPP			myIdleRD;	if (dispose) {								// abmelden?		if (prMergeHndl) {						// Handle noch vorhanden?			DisposHandle((Handle)prMergeHndl);	// dann freigeben			prMergeHndl = nil;		}		return noErr;							// alles ok!	}	PrintingStatusDialog = nil;	p = (THPrint)NewHandle(sizeof(TPrint));		// neue Struktur allozieren	if (!p) return(memFullErr);					// Speicher reichte nicht!	BlockMove(&PrintStruct,*p,sizeof(TPrint));	// Struktur fŸllen!	GetPort(&oldPort);	pfeil();	PrOpen();	err = PrError();	if(err == fnfErr || err == -8172) err = -8150;	if(!err) {		keepResFile = CurResFile();		if (!PrintStructValid) {			PrintDefault(p);					// The document print record was never			err = PrError();					// initialized. Now is is.		}		if (!err) {			PrValidate(p);						// Do this just 'cause Apple says so.			err = PrError();		}		pfeil();		if (!err) {			if (jobDlg) {						// User gets to click some buttons.				PrtJobDialog = PrJobInit(p);	// Dialogbox laden				if (PrError() == noErr) {					PDlgInitUPP	myRD = NewPDlgInitProc(MyJobDlgInit);#if 0					if (PrintJobDITL>0)						Append2hdlg(PrintJobDITL,JobDlgID);#endif					if (!PrDlgMain(p, myRD))						PrSetError(err = userCanceledErr);					else						err = PrError();					DisposeRoutineDescriptor(myRD);				}			}		}		if (!err) {			if (!firstJob) {				PrJobMerge(prMergeHndl,p);				err = PrError();			}		}		if (!err) {			// Put the defaulted/validated/jobDlg'ed print record in the doc.			biene();			fstPage	= (*p)->prJob.iFstPage;			if (fstPage == 0) fstPage = 1;			lstPage	= (*p)->prJob.iLstPage;			if (lstPage == 0) lstPage = 9999;			copies	= (*p)->prJob.iCopies;			if (copies == 0) copies = 1;			BlockMove(*p,&PrintStruct,sizeof(TPrint));			PrintStructValid = true;			(*p)->prJob.iFstPage = 1;		// ÒalleÓ Seiten ausdrucken (LaserWriter LC!)			(*p)->prJob.iLstPage = 9999;			PrintingStatusDialog = GetNewDialog(dPrStatusDlg,nil,(WindowPtr)-1);			if (PrintingStatusDialog) {				SetWTitle((WindowPtr)PrintingStatusDialog,PrintDocName);				PrValidate(p);	// Do this just 'cause Apple says so.				HiliteButton(PrintingStatusDialog,1,255);				NumToString(fstPage,s);				ParamText(PrintDocName,s,nil,nil);	// Dokumentname + Seitennummer				DrawDialog(PrintingStatusDialog);					// Hook in the proceed/pause/cancel dialog.			}			myIdleRD = NewPrIdleProc(PrintIdleProc);			for (i=1; (i<=copies) && (!err); ++i) {				Boolean		openFlag = false;				// Dialogbox-Hook eintragen (Apple machts auch an dieser StelleÉ)				(*p)->prJob.pIdleProc = myIdleRD;				// Restore the reource file to the printer driver«s				UseResFile(keepResFile);				for(gPrintPage = fstPage; gPrintPage <= lstPage; gPrintPage++) {					if ((gPrintPage - fstPage) % iPFMaxPgs == 0) {	// max. 128 Seiten!						if (gPrintPage != fstPage) {		// erster Durchgang?							PrCloseDoc(printPort);			// sonst das Dokument schlie§en!							PrPicFile(p,nil,nil,nil,&status);							err = PrError();						}						if (err) break;						// Fehler => Abbruch						printPort = PrOpenDoc(p,nil,nil);						openFlag = true;					// PrOpen aufgetreten						err = PrError();						if (err) break;						// Fehler => Abbruch						if (gPrintPage == fstPage) {		// erster Durchgang?							if (gG.Print) {								GrafPtr	savePort;								GetPort(&savePort);								SetPort(&printPort->gPort);								gPrintPage = -1;			// Seitennr = -1 <=> Init								{ G(Print)(printPort,p); }	// Init-Aufruf								gPrintPage = fstPage;								SetPort(savePort);							}						}					}					NumToString(gPrintPage,s);					ParamText(PrintDocName,s,nil,nil);	// Dokumentname + Seitennummer					DrawDialog(PrintingStatusDialog);					PrOpenPage(printPort,nil);					err = PrError();					if (err == noErr) {						if (gG.Print) {							GrafPtr	savePort;							GetPort(&savePort);							SetPort(&printPort->gPort);							{ G(Print)(printPort,p); }							SetPort(savePort);						}					}					PrClosePage(printPort);					if ((!gPrintPage)||					// Seitennummer = 0 => Ende						((err = PrError()) != noErr)) break;		// oder ein Fehler?				}				gPrintPage = 0;				if (openFlag)							// PrOpen aufgetreten?					PrCloseDoc(printPort);			}			DisposeRoutineDescriptor(myIdleRD);		}		if (			(!err) &&			((*p)->prJob.bJDocLoop == bSpoolLoop) &&			(!(err = PrError()))		) {			PrPicFile(p,nil,nil,nil,&status);			err = PrError();		}	}	if (firstJob)	prMergeHndl = p;	else			DisposHandle((Handle)p);	if (PrintingStatusDialog) DisposDialog(PrintingStatusDialog);	PrClose();	SetPort(oldPort);	pfeil();	return(err);}/* PrintIdleProc will handle events in the 'Printing Status Dialog' which** gives the user the option to 'Proceed', 'Pause', or 'Cancel' the current** printing job during print time.**** The buttons:**		1: Proceed**		2: Pause**		3: Cancel*/pascal void		PrintIdleProc(void){Boolean			button,paused;DialogPtr		d;EventRecord		anEvent;GrafPtr			oldPort;short			item,keepResFile;short			type;Handle			h;Rect			r;static short	lastPage = -1;	GetPort(&oldPort);	UseResFile(keepResFile = CurResFile());	HiliteButton(PrintingStatusDialog,1,255);	paused = false;	do {		if (paused)			pfeil();		// WŠhrend der Pause als Mauspfeil umschalten		else			biene();		if (AbortInQueue()) {			PrSetError(iPrAbort);               // Drucken abbrechen			gPrintPage = 0;						// abbrechen!			break;		}		GetNextEvent(mDownMask+mUpMask+updateMask,&anEvent);		if (lastPage != gPrintPage) {					// Seitennummer updaten			GetDItem(PrintingStatusDialog,4,&type,&h,&r);			SetPort(PrintingStatusDialog);			InvalRect(&r);								// neu zeichnen			lastPage = gPrintPage;		}		if (PrintingStatusDialog != FrontWindow())		// Drucken-Dialog			SelectWindow(PrintingStatusDialog);			// ist STETS das oberste Window		if (IsDialogEvent(&anEvent)) {			button = DialogSelect(&anEvent,&d,&item);			if ((button) && (d == PrintingStatusDialog)) {				switch (item) {					case 1:						HiliteButton(PrintingStatusDialog,2,0);		// Enable PAUSE						HiliteButton(PrintingStatusDialog,1,255);	// Disable PROCEED						paused = false;						break;					case 2:						HiliteButton(PrintingStatusDialog,2,255);	// Disable PAUSE						HiliteButton(PrintingStatusDialog,1,0);		// Enable PROCEED						paused = true;						break;					case 3:						PrSetError(iPrAbort);               // Drucken abbrechen						gPrintPage = 0;						// abbrechen!						paused = false;						break;				}			}		}	} while (paused != false);	SetPort(oldPort);}