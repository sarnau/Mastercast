/*** *	Diese kleine Klasse dient für den einfachen Zugriff auf dBASE Dateien * *	©1994 Dekotec Abt. Info-Sys, Markus Fritze ***/#include "GlobalDefines.h"#include "dBASE Import.h"#include <string.h>#include <Processes.h>/*** *	Datebase-Ptr setzen ***/void			dBASEFile::Init(UnsPtr dbp){	Dbp = dbp;	switch(dbp[0]) {	// Versionsnummer	case 0x02:	// dBASE II			Danz = dbp[1] + ((unsigned short)dbp[2]<<8);			DataSize = dbp[6] + ((unsigned short)dbp[7]<<8);			FieldHdrSize = 16;			FieldLenOffset = 12;			dbp += 8;			break;	case 0x03:	// dBASE III	case 0x83:	// dBASE III mit Memofeld			Danz = dbp[4] + ((unsigned short)dbp[5]<<8) + ((unsigned long)dbp[6]<<16) + ((unsigned long)dbp[7]<<24);			DataSize = dbp[10] + ((unsigned short)dbp[11]<<8);			FieldHdrSize = 32;			FieldLenOffset = 16;			dbp += 32;			break;	default:			SignalPStr_("\pNur dBASE II und dBASE III Dateien sind möglich!");			ExitToShell();	}	HeaderPtr = dbp;	// Ptr auf die Daten errechnen	for(DataSetPtr = dbp; *DataSetPtr != 0x0D; DataSetPtr += FieldHdrSize) {}	DataSetPtr++;	{	unsigned char	c;	UnsPtr			p = DataSetPtr;	UnsPtr			pe = p + Danz * DataSize;	// Ptr hinter das Ende der Datenbank	Handle			ch = GetNamedResource('DBF ', "\pDBF (IBM 850 to Mac)");	if(!ch) return;					// keine Resource => Daten nicht wandeln!	for( ;p < pe; *p++ = c) {		c = *p;		if(!(c & 0x80)) continue;	// kein Sonderzeichen => einfach übernehmen		c = (*ch)[c & 0x7F];		// Sonderzeichen gemäß Tabelle wandeln	}	ReleaseResource(ch);	}}/*** *	Feldnamen ins dBASE Format wandeln ***/void			dBASEFile::ConvertFieldname(Ptr name){short		i;char		c;	for(i=10;i-->0;) {							// Feldname ist maximal 10 Zeichen lang!		c = *name;		if(!c) break;		if(c & 0x80) {							// Umlaute, etc? => in ein '_' wandeln!			switch(c) {			case 'Ä':			case 'ä': c = 'A'; break;			case 'Ö':			case 'ö': c = 'O'; break;			case 'Ü':			case 'ü': c = 'U'; break;			case 'ß': c = '_'; break;			default:   SignalPStr_("\pUnbekannter Umlaut im Feldnamen!");			}		}		if(c >= 'a' && c <= 'z') c -= 'a'-'A';	// sonstige Zeichen in Großbuchstaben wandeln		*name++ = c;	}	*name = 0;}/*** *	Feldnamen ins dBASE Format wandeln ***/short			dBASEFile::GetFieldOffset(Ptr name, short *flen){UnsPtr		p;short		offset = 0;	*flen = 0;	for(p = HeaderPtr; *p != 0x0D; offset += p[FieldLenOffset], p += FieldHdrSize) {		// bis zum Ende der Feldliste abklappern		if(strcmp((Ptr)p, name))		// Namen gefunden?			continue;			// nein =>		*flen = p[FieldLenOffset];		return offset;			// gefunden!	}	SignalPStr_("\pFeldnamen nicht gefunden!");	return -1;					// Feld nicht gefunden!}/*** *	Feld eines Datensatz auslesen ***/UnsPtr			dBASEFile::Get(unsigned long no, Ptr fieldname){short					offset,flen;static unsigned char	data[256];	ConvertFieldname(fieldname);	offset = GetFieldOffset(fieldname, &flen);	if(offset < 0) return 0L;				// Feld nicht gefunden => raus	BlockMoveData(no * DataSize + DataSetPtr + offset + 1, data, flen);	data[flen] = 0;	// Leerzeichen am Stringende entfernen	while(flen > 0 && data[--flen] == ' ') data[flen] = 0;	return data;}/*** *	GetIndString-Cache-Funktion ***/typedef struct {	short		resId;	Handle		resHand;} CacheStrRes;void		MyGetIndString(StringPtr theString, short strListID, short index);void		MyGetIndString(StringPtr theString, short strListID, short index){#if 0		GetIndString(theString, strListID, index);	// dann normal versuchen…#else#define MaxCacheSize		100static CacheStrRes	*cache = nil;int					i;	if(cache == nil)		cache = (CacheStrRes*)NewPtrClear(sizeof(CacheStrRes) * MaxCacheSize);	for(i=0; i<MaxCacheSize; i++) {		if(cache[i].resId == 0) {			// Ende vom Cache erreicht?			cache[i].resId = strListID;			cache[i].resHand = GetResource('STR#', strListID);			break;		}		if(cache[i].resId != strListID)	// Eintrag im Cache gefunden?			continue;						// nein => weiter suchen		break;	}	if(i == MaxCacheSize) {					// nix gefunden?		GetIndString(theString, strListID, index);	// dann normal versuchen…		return;	}	Handle	h = cache[i].resHand;	i = *(short*)*h;							// Anzahl der Strings	theString[0] = 0;	if(i < index)		return;	StringPtr	sp = (StringPtr)*h + 2;	while(index > 1) {							// durch den Cache hangeln		sp += sp[0] + 1;		index--;	}	BlockMoveData(sp, theString, sp[0] + 1);	// und den String verschieben#endif}/*** *	Feld eines Datensatz auslesen ***/UnsPtr			dBASEFile::GetInd(unsigned long no, short strind, short id){Str255		theString;	MyGetIndString(theString, strind, id);	theString[theString[0] + 1] = 0;		// Nullbyte an den String anhängen (=> C-String)	return Get(no, (Ptr)theString + 1);}/*** *	Listenfeld in ein Bitfeld wandeln ***/#include <packages.h>unsigned long	dBASEFile::GetBitindex(unsigned long no,short strind, const int id, const int strListId){UnsPtr		s = GetInd(no, strind, id);			// Feld aus dem Datensatz holenUnsPtr		t;int			index;long		ret = 0L;Str255		stemp;Str255		str;	if(s && *s) {		// Feld vorhanden und steht was drin?		while(1) {			for(t = s, index = 0; *t && *t != '\r'; t++)				stemp[++index] = *t;				// Teilstring als Pascalstring extrahieren			stemp[0] = index;			for(index = 1; ; index++) {				// Stringliste abklappern				str[0] = 0;				MyGetIndString(str, strListId, index);				if(!str[0]) break;					// kein weiterer String				if(stemp[0] == str[0] && !IUEqualString(stemp, str)) {	// String gefunden?					ret |= 1L << (index - 1);		// Index ins Bitfeld eintragen					break;				}			}			if(!*t) break;							// Ende? => raus			s = t + 1;								// nächster Substring		}	}	return ret;}/*** *	Index eines Eintrages aus einem Bitfeld ermitteln (bei 1 geht es los) ***/int				dBASEFile::GetIndex(unsigned long no, short strind, const int id, const int strListId){unsigned long	l = GetBitindex(no, strind, id, strListId);int				i;	for(i = 0; i < 32; i++)		if((1L << i) & l)			return i + 1;	return 0;}