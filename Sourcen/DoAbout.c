#include "GeosErrors.h"#include "GlobalLib.h"#include "Utilities.h"#include "DialogBase.h"#include "Geos.h"#include <Traps.h>#include <Gestalt.h>#include <LowMem.h>#include <Packages.h>#include <QDOffscreen.h>#include <AppleScript.h>enum {	AD_Ok = 1,	AD_Version,	AD_Danke,	AD_Info,	AD_DefaultFrame = 7,	AD_Scroll,	AD_HDInfo,	AD_Picture};typedef struct AboutVarStruct {	Boolean			scrolltext;		// true, wenn Scrolltext	Boolean			StartupWithInfo;// true, wenn mit dem Rechnerinfo gestartet wird	short			aktPixelCount;	// Zeichensatz-Pixeloffset	short			aktIndex;		// aktueller Scrolltext-Stringindex	short			aktFontSize;	// aktuelle Fontgröße	short			aktPixelSize;	// aktuelle Fonthöhe in Pixeln	Str255			aktString;		// aktuelle letzte Zeile	Rect			scrollrect;		// Scrollrechteck	unsigned long	picttimer;	Rect			pictrect;		// Bild-Rechteck	long			**picth;		// Handle auf alle Modelle mit vorhanden Bildern	short			pictindex;		// letztes aktives Bild} AboutVarStruct;AboutVarStruct		*avp;static Boolean		GetVolInfo(short ioVRefNum, StringPtr ioNamePtr, long *free, long *all, long *blsize);static void			DrawHDInfo(DialogBase *dp, short theItem);static short		GetStringsIndex(short resid, short id);static void			AddString(StringPtr theString, Handle destStrH, char *sindex);static void			AddNumString(long theNum, Handle destStrH, char *sindex);static void			AddIndString(short strListID, short index, Handle destStrH, char *sindex);static void			AddChar(char *theChar, Handle destStrH, char *sindex);static void			AddVersion(long version, Handle destStrH, char *sindex);static void			WRITENEXTLINE(Rect *theRect, StringPtr theString, short offset);static void			DRAWALLLINES(DialogBase *dp, short theItem, short strListID);static void			ResetCredits(short theItem);static short		SETUPTODRAW(DialogBase *dp, short theItem, Rect *theRect);static pascal void	DRAWIT(DialogPtr theDialog, short theItem);static pascal Boolean	DOTHECREDITS(DialogPtr theDialog, EventRecord *theEvent, short *itemHit);static pascal void	DRAWPICT(DialogPtr theDialog, short theItem);void			DoAbout(void);void			ShowSplashInfo(void);void			RemoveSplashInfo(void);/*** *	JPEGs aus der Datenbank laden ***/#include "MCWindTools.h"#include "mc_db.h"static void				BuildPicList(void);static void				BuildPicList(void){ModellStruct	**mp;Rect			r;long			l;short			count = 0;short			nfndcount = 0;	SetAnimCursor(128);	avp->picth = (long**)NewHandle(0L);	for(mp = DB_MFoundFirst(""); mp; mp = DB_MFoundNext("", mp)) {	// Alle Datensätze durchsuchen		r = avp->pictrect;#if 1		SpinCursor(16);		if(count < 4 || nfndcount > 1) {			// große Lücken in der Bilddatenbank?			if(!GetPictData((*mp)->Id, 1, false)) {	// Headsheet vorhanden?				nfndcount++;				continue;			}			count++;		}#endif		l = GetHandleSize((Handle)avp->picth);		SetHandleSize((Handle)avp->picth, l + sizeof(long));		(*avp->picth)[l>>2] = (*mp)->Id;	}	l = (GetHandleSize((Handle)avp->picth) >> 2) - 1;	if(l)		avp->pictindex = (Random() & 0x7FFF) % l;	pfeil();}static pascal void		DRAWPICT(DialogPtr theDialog, short theItem){DialogBase		*dp = DialogBase::Class(theDialog);	if(avp->pictindex >= (GetHandleSize((Handle)avp->picth) >> 2))		avp->pictindex = 0;	long		id = (*avp->picth)[avp->pictindex++];	Rect		iRect, bRect;	dp->GetItemRect(theItem, &iRect);				// Rechteck des Items ermitteln	InsetRect(&iRect, 2, 2);						// wg. dem Rahmen um das Bild	short	x = iRect.right - iRect.left;			// max. Bildbreite abzgl. Rahmen um das Bild	short	y = iRect.bottom - iRect.top;			// max. Bildhöhe	SetRect(&bRect, 0,0, x,y);	GetPictRect(id, 1, bRect, false, true);			// Bild auf den Rahmen skalieren	bRect.left = (x - bRect.right) >> 1;			// Bild zentrieren	bRect.top = ((y - bRect.bottom) >> 1);	bRect.right += bRect.left;	bRect.bottom += bRect.top;	OffsetRect(&bRect, iRect.left, iRect.top);		// und um den Item-Offset	// Farbtabelle des Windows ermitteln	RGBColor		backColor = { 0xFFFF, 0xFFFF, 0xFFFF };	// Default: weiß	AuxWinHandle	colors;	GetAuxWin(dp->GetDialogPtr(), &colors);	if(colors) {		CTabHandle		awCTable = (*colors)->awCTable;		if(awCTable) {			for(int index = (*awCTable)->ctSize; index >= 0; index--) {				if((*awCTable)->ctTable[index].value != wContentColor)	// Hintergrundfarbe suchen					continue;			// nicht gefunden => weitersuchen				backColor = (*awCTable)->ctTable[index].rgb;	// Farbe aus der Tabelle kopieren				break;					// und abbrechen			}		}	}	RGBColor		saveBackCol;	GetBackColor(&saveBackCol);	RgnHandle	theRgn1, theRgn2;	InsetRect(&iRect, -2, -2);						// wg. dem Rahmen um das Bild	theRgn1 = NewRgn(); RectRgn(theRgn1, &iRect);	InsetRect(&bRect, -1, -1);	theRgn2 = NewRgn(); RectRgn(theRgn2, &bRect);	InsetRect(&bRect, 1, 1);	DiffRgn(theRgn1, theRgn2, theRgn1);	DisposeRgn(theRgn2);	RGBBackColor(&backColor);						// gefundene Hintergrundfarbe setzen	EraseRgn(theRgn1);								// Hiermit löschen wir _nur_ das Rechteck UM das Bild herum	DisposeRgn(theRgn1);							// => es flackert nicht!	DrawPic(id, 1, bRect, true, false);				// Bild zentriert zeichnen	// Wegen Rundungsfehlern müssen wir nochmal den Rest löschen	theRgn1 = NewRgn(); RectRgn(theRgn1, &iRect);	InsetRect(&bRect, -1, -1);	theRgn2 = NewRgn(); RectRgn(theRgn2, &bRect);	InsetRect(&bRect, 1, 1);	DiffRgn(theRgn1, theRgn2, theRgn1);	DisposeRgn(theRgn2);	RGBBackColor(&backColor);						// gefundene Hintergrundfarbe setzen	EraseRgn(theRgn1);								// Hiermit löschen wir _nur_ das Rechteck UM das Bild herum	DisposeRgn(theRgn1);							// => es flackert nicht!	RGBBackColor(&saveBackCol);						// alte Hintergrundfarbe wieder setzen}/*** *	Platz auf einem Laufwerk ermitteln ***/static Boolean		GetVolInfo(short ioVRefNum, StringPtr ioNamePtr, long *free, long *all, long *blsize){HVolumeParam	vp;	vp.ioVolIndex = 0;	vp.ioVRefNum = ioVRefNum;	vp.ioNamePtr = ioNamePtr;	if(PBHGetVInfoSync((HParmBlkPtr)&vp) != noErr) return false;	*free = vp.ioVFrBlk;	*all = vp.ioVNmAlBlks;	*blsize = vp.ioVAlBlkSiz;	return true;}#if !DEMO/*** *	Info über die aktuelle Harddisk ausgeben ***/static void			DrawHDInfo(DialogBase *dp, short theItem){long		free;long		all;long		blsize;Str31		name;short		lineheight;Rect		theRect;Handle		iStrHandle;short		index;Str255		stemp;char		sindex[2];short		SearchCD(void);	if(!GetVolInfo(SearchCD(), name, &free, &all, &blsize)) return;		// Laufwerksinfo abfragen	lineheight = SETUPTODRAW(dp, theItem, &theRect);	iStrHandle = NewHandle(sizeof(Str255));	for(index = 1; index < 3; index++) {		GetIndString(stemp, 131, index);		PtrToXHand(stemp, iStrHandle, stemp[0]+1);		*(short*)&sindex = '^0';		switch(index) {		case 1:	AddNumString((free * blsize) >> 10, iStrHandle, sindex);				sindex[1]++;				AddNumString((free * 100L) / all, iStrHandle, sindex);				break;		case 2:	AddString(name, iStrHandle, sindex);				break;		}		HLock(iStrHandle);		WRITENEXTLINE(&theRect, (StringPtr)*iStrHandle, lineheight);		HUnlock(iStrHandle);	}	DisposeHandle(iStrHandle);}#endif/*** * ***/static short		GetStringsIndex(short resid, short id){short		*sh = (short*)*GetResource('Data', resid);short		index;	for(index = 1; index <= sh[0]; index++)		if(sh[index] == id) return index;	return 1;}/*** * ***/static void			AddString(StringPtr theString, Handle destStrH, char *sindex){	Munger(destStrH, 0L, sindex, 2, theString+1, theString[0]);	**destStrH += theString[0] - 2;}/*** * ***/static void			AddNumString(long theNum, Handle destStrH, char *sindex){Str255			theString;	NumToString(theNum, theString);	Munger(destStrH, 0L, sindex, 2, theString+1, theString[0]);	**destStrH += theString[0] - 2;}/*** * ***/static void			AddIndString(short strListID, short index, Handle destStrH, char *sindex){Str255			theString;	GetIndString(theString, strListID, index);	Munger(destStrH, 0L, sindex, 2, theString+1, theString[0]);	**destStrH += theString[0] - 2;}/*** * ***/static void			AddChar(char *theChar, Handle destStrH, char *sindex){	Munger(destStrH, 0L, sindex, 2, theChar, sizeof(char));	(**destStrH)--;}/*** * ***/static void			AddVersion(long version, Handle destStrH, char *sindex){Str255		vStr;Str255		tempStr;short		subVersion = version;	version >>= 16;	NumToString(version >> 8, vStr);	ConcatPString(vStr, "\p.");	NumToString((version & 0xF0) >> 4, tempStr);	ConcatPString(vStr, tempStr);	if(version & 0x0F) {		ConcatPString(vStr, "\p.");		NumToString(version & 0x0F, tempStr);		ConcatPString(vStr, tempStr);	}	char	c;	switch((subVersion >> 8) & 0xFF) {	case 0x20:	// "Development"			c = 'd';			goto found;	case 0x40:	// "Alpha"			c = 'a';			goto found;	case 0x60:	// "Beta"			c = 'b';			goto found;	case 0x80:	// "Final"			if((char)subVersion == 0) break;	// keine Unterversion? => nix ausgeben			c = '-';	found:	tempStr[0] = 1; tempStr[1] = c;			ConcatPString(vStr, tempStr);			NumToString((char)subVersion, tempStr);			ConcatPString(vStr, tempStr);			break;	}	AddString(vStr, destStrH, sindex);	sindex[1]++;}/*** *	eine einzelne Zeile ausgeben ***/static void			WRITENEXTLINE(Rect *theRect, StringPtr theString, short offset){	TETextBox(theString+1, theString[0], theRect, teJustLeft);	OffsetRect(theRect, 0, offset);}/*** *	Infozeilen einer ganzen Seite ausgeben ***/static void			DRAWALLLINES(DialogBase *dp, short theItem, short strListID){short		lineheight;short		index = 1;Rect		theRect;Str255		theString;	lineheight = SETUPTODRAW(dp, theItem, &theRect);	while(1) {		GetIndString(theString, strListID, index++);		if(!theString[0]) break;		WRITENEXTLINE(&theRect, theString, lineheight);	}}/*** *	Credits-Scrolltext zurücksetzen ***/static void			ResetCredits(short index){short		nextitem = index < **(short**)GetResource('STR#', 128) ? index : 1;FontInfo	fInfo;	avp->aktIndex = nextitem;	avp->aktPixelCount = 0;	GetIndString(avp->aktString, 128, nextitem);	avp->aktFontSize = (avp->aktString[1] == '%')?6000:6001;	SetFont(avp->aktFontSize);	GetFontInfo(&fInfo);	avp->aktPixelSize = fInfo.ascent + fInfo.descent + fInfo.leading;}/*** *	Grafport für Textausgabe vorbereiten ***/static short		SETUPTODRAW(DialogBase *dp, short theItem, Rect *theRect){FontInfo	fInfo;short		lineheight;	dp->GetItemRect(theItem, theRect);	dp->SetGraphicPort();	SetFont(6001);	GetFontInfo(&fInfo);	lineheight = fInfo.ascent + fInfo.descent + fInfo.leading;	theRect->bottom = theRect->top + lineheight;	return lineheight;}/*** *	Zeichen-Funktion für User-Objekte ***/static pascal void	DRAWIT(DialogPtr theDialog, short theItem){Rect			theRect;short			lineheight;Handle			iStrHandle;short			index;Str255			stemp;char			sindex[2];DialogBase		*dp = DialogBase::Class(theDialog);	switch(theItem) {	case AD_DefaultFrame:	// Defaultbutton		dp->OutlineDialogItem(AD_Ok);		break;	case AD_HDInfo:			// Laufswerksinfo, etc.#if 0		if(avp->scrolltext || avp->StartupWithInfo)			dp->GetItemRect(theItem, &theRect);		else			SetRect(&theRect, 0, 0, 0, 0);		if(SectRect(&theRect, &avp->scrollrect, &theRect)) return;#endif#if !DEMO		DrawHDInfo(dp, theItem);#endif		break;	case AD_Scroll:			// Scrollfläche, etc.		if(avp->scrolltext) {			EraseRect(&avp->scrollrect);			ResetCredits(1);			return;		}		if(avp->StartupWithInfo) {			long		auxversion;			if(TrapAvailable(_Gestalt)) {				if(Gestalt(gestaltAUXVersion, &auxversion) != noErr)					auxversion = 0x7FFFL;			} else {				auxversion = (LMGetHWCfgFlags() & 0x200) == 0x200 ? 0x100L : 0x7FFFL;			}			lineheight = SETUPTODRAW(dp, theItem, &theRect);			iStrHandle = NewHandle(sizeof(Str255));			for(index = 1; index < 12; index++) {				GetIndString(stemp, 129, index);				PtrToXHand(stemp, iStrHandle, stemp[0]+1);				*(short*)&sindex = '^0';				switch(index) {				case 1:	break;				case 2:	{						short		i, j;							AddVersion((long)gSystemVersion << 16, iStrHandle, sindex);							j = (*(Intl0Hndl)GetIntlResource(0))->intl0Vers >> 8;							i = GetStringsIndex(128, j);							AddIndString(132, i, iStrHandle, sindex);							if(i == 1) {								*(short*)&sindex = '^0';								AddNumString(j, iStrHandle, sindex);							}						}						break;				case 3:	#if defined(powerc) || defined(__powerc)						AddIndString(129, 18, iStrHandle, sindex);#else						AddIndString(129, 17, iStrHandle, sindex);#endif						break;				case 4:	{						long		response;							Gestalt(gestaltMachineType, &response);							AddIndString(kMachineNameStrID, response, iStrHandle, sindex);						}						break;				case 5:						goto nextline;				case 6:						if(TrapAvailable(_QDExtensions)) {							AddVersion(OffscreenVersion() << 16, iStrHandle, sindex);						} else {							AddIndString(129, 14, iStrHandle, sindex);							while(++sindex[1] < '5')								AddChar("", iStrHandle, sindex);						}						break;				case 7:						{						long		resp;						Gestalt(gestaltQuickTime, &resp);						AddVersion(resp, iStrHandle, sindex);						while(++sindex[1] < '5')							AddChar("", iStrHandle, sindex);						}						break;				case 8:						{						long		resp;						if(Gestalt(gestaltAppleScriptVersion, &resp) == noErr) {							AddVersion(resp & 0xFFFF0000L, iStrHandle, sindex);						} else {							AddIndString(129, 12, iStrHandle, sindex);							while(++sindex[1] < '5')								AddChar("", iStrHandle, sindex);						}						}						break;				case 9:	if(auxversion >= 0x200)							AddNumString((TrapAvailable(_OSDispatch)?(long)TempTopMem():(long)TopMem()) >> 10, iStrHandle, sindex);						else							AddIndString(129, 13, iStrHandle, sindex);						break;				case 10:if(auxversion >= 0x200)							AddNumString(((long)LMGetApplLimit() - (long)LMGetApplZone()) >> 10, iStrHandle, sindex);						else							AddIndString(129, 13, iStrHandle, sindex);						break;				case 11:if(auxversion >= 0x200) {							long		growBytes;							AddNumString(MaxMem(&growBytes) >> 10, iStrHandle, sindex);						} else {							AddIndString(129, 13, iStrHandle, sindex);						}						break;				}				HLock(iStrHandle);				WRITENEXTLINE(&theRect, (StringPtr)*iStrHandle, lineheight);				HUnlock(iStrHandle);			nextline:				{}			}			DisposeHandle(iStrHandle);			break;		} else {			DRAWALLLINES(dp, theItem, 130);		}		break;	}}/*** *	Modal-Dialogfilter ***/static pascal Boolean	DOTHECREDITS(DialogPtr theDialog, EventRecord *theEvent, short *itemHit){RgnHandle		scrollrgn, cliprgn;Rect			theRect;short			index, len, offset;DialogBase		*dp = DialogBase::Class(theDialog);	UNUSED(theEvent); UNUSED(itemHit);	dp->SetGraphicPort();	if(!avp->scrolltext && avp->picttimer < (unsigned long)TickCount()) {		avp->picttimer = (unsigned long)TickCount() + 60*4;	// alle 4 Sekunden das Bild wechseln		InvalRect(&avp->pictrect);	}	if(avp->scrolltext && !Button()) {	// Scrolltext aktiv und Maustaste nicht gedrückt?		scrollrgn = NewRgn();		cliprgn = NewRgn();		GetClip(cliprgn);		// um einen Tick verzögern//		unsigned long	lTicks;//		lTicks = (unsigned long)TickCount() + 1;//		while(lTicks >= (unsigned long)TickCount()) {}		// nun um eine Zeile nach oben scrollen		ScrollRect(&avp->scrollrect, 0, -1, scrollrgn);		// Clipping auf den hereingescrollen Bereich setzen		SetClip(scrollrgn);		theRect = avp->scrollrect;		theRect.top = theRect.bottom - 1;		if(avp->aktString[1] != '~') {			theRect.bottom = theRect.top + avp->aktPixelSize;			index = 1;			len = avp->aktString[0];			offset = 50;						// 50 Pixel Offset zum linken Rand			if(avp->aktString[1] == '%') {		// ausrücken?				index++; len--;				offset = 20;					// 20 Pixel Offset zum linken Rand			}			OffsetRect(&theRect, offset, avp->aktPixelCount);			SetFont(avp->aktFontSize);			TETextBox(avp->aktString + index, len, &theRect, teJustLeft);		} else {	// wir können auch PICT-Resourcen ausgeben: ~Resource-ID, z.B. "~128"			Str255		s;			CopyPString(s, avp->aktString);			s[1] = s[0] - 1;					// "~" Zeichen am Stringanfang wegcutten			long		picID;			StringToNum(s + 1, &picID);			// PICT-Resource-ID holen			PicHandle	thePicture = GetPicture(picID);	// und das Bild einlesen			if(thePicture) {				HLock((Handle)thePicture);				PicPtr	pp = *thePicture;				// Bild nach (0,0) verschieben				OffsetRect(&pp->picFrame, -pp->picFrame.left, -pp->picFrame.top);				short	width = pp->picFrame.right;				if(width < theRect.right) {				// Bild kleiner als der Rahmen? (Sollte möglichst immer der Fall sein!)					if(width < theRect.right - 20) {	// Bild paßt an die 1. Einrückung?						theRect.left += 20;				// dann einrücken!						if(width < theRect.right - 50)	// Bild paßt sogar an die 2. Einrückung?							theRect.left += 50 - 20;	// dann sogar soweit einrücken!					}					theRect.right = theRect.left + width;	// Bildbreite richtig setzen				}				// Höhe des Bildes als Zeilenhöhe setzen				avp->aktPixelSize = pp->picFrame.bottom;				theRect.bottom = theRect.top + avp->aktPixelSize;				OffsetRect(&theRect, 0, avp->aktPixelCount);				DrawPicture(thePicture, &theRect);				HUnlock((Handle)thePicture);				HPurge((Handle)thePicture);			} else {				avp->aktPixelSize = 0;			}		}		avp->aktPixelCount--;			// eine Pixelzeile hochscrollen		if((avp->aktPixelSize + 1) < ((avp->aktPixelCount < 0)?-avp->aktPixelCount:avp->aktPixelCount))			ResetCredits(avp->aktIndex + 1);		SetClip(cliprgn);		DisposeRgn(scrollrgn);		DisposeRgn(cliprgn);	}	return false;}////	“About…” aus dem Drop-Down-Menü wurde angewählt.//void			DoAbout(void){GrafPtr			savePort;short			theItem;UserItemUPP		myDrawItemProc = NewUserItemProc(DRAWIT);UserItemUPP		myDrawPictProc = NewUserItemProc(DRAWPICT);DialogBase		*dp;	avp = (AboutVarStruct*)NewPtrClear(sizeof(AboutVarStruct));	GetPort(&savePort);	avp->StartupWithInfo = CheckKey(0x3A);	// Option abtesten	BuildPicList();	dp = new DialogBase;	dp->Open(136);							// Dialog laden	dp->SetUserItem(AD_DefaultFrame, myDrawItemProc);	dp->SetUserItem(AD_Scroll, myDrawItemProc);	dp->GetItemRect(AD_Scroll, &avp->scrollrect);	dp->SetUserItem(AD_HDInfo, myDrawItemProc);	dp->SetUserItem(AD_Picture, myDrawPictProc);	dp->GetItemRect(AD_Picture, &avp->pictrect);	dp->EnDisableItem(avp->StartupWithInfo ? AD_Info : AD_Version, false);	while(1) {		dp->ModalDialog(DOTHECREDITS, &theItem);		if(theItem == AD_Ok) break;		dp->EnDisableItem(AD_Version, theItem != AD_Version);		dp->EnDisableItem(AD_Danke, theItem != AD_Danke);		dp->EnDisableItem(AD_Info, theItem != AD_Info);		switch(theItem) {		case AD_Version:		case AD_Info:				avp->scrolltext = false;				avp->StartupWithInfo = theItem == 4;				break;		case AD_Danke:				avp->scrolltext = true;				ResetCredits(1);				break;		}		dp->RedrawItem(AD_Scroll, true);	}	delete dp;	DisposeRoutineDescriptor(myDrawItemProc);	DisposeRoutineDescriptor(myDrawPictProc);	if(avp->picth)		DisposeHandle((Handle)avp->picth);	SetPort(savePort);	DisposePtr((Ptr)avp);}////	Splash Screen aufrufen//DialogBase		*SplashDialogPtr;UserItemUPP		SPmyDrawItemProc;void			ShowSplashInfo(void){	avp = (AboutVarStruct*)NewPtrClear(sizeof(AboutVarStruct));	SPmyDrawItemProc = NewUserItemProc(DRAWIT);	SplashDialogPtr = new DialogBase;	SplashDialogPtr->Open(128);				// Dialog laden	SplashDialogPtr->SetUserItem(AD_Scroll, SPmyDrawItemProc);	SplashDialogPtr->GetItemRect(AD_Scroll, &avp->scrollrect);	SplashDialogPtr->SetUserItem(AD_HDInfo, SPmyDrawItemProc);	SplashDialogPtr->GetItemRect(AD_Scroll, &avp->pictrect);	SplashDialogPtr->Show();	SplashDialogPtr->Draw();}////	Splash Screen entfernen//void			RemoveSplashInfo(void){	if(SplashDialogPtr) {		delete SplashDialogPtr;		SplashDialogPtr = nil;	}	if(SPmyDrawItemProc) {		DisposeRoutineDescriptor(SPmyDrawItemProc);		SPmyDrawItemProc = nil;	}	if(avp) {		if(avp->picth)			DisposeHandle((Handle)avp->picth);		DisposePtr((Ptr)avp);		avp = nil;	}}