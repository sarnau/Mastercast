#include "FAXstf.h"#include <Folders.h>#include <Aliases.h>#include <Script.h>// Name des Fax-TreibersStr31		FaxName = "\pFaxPrint";// Name der EmpfŠnger-DateiStr31		FaxDestName = "\pDestinations";// Device-Name vom FaxtreiberStr31		FaxDevName = "\p.FaxSTF_Monitor";static void			PStrCpy(StringPtr d, StringPtr s);static void			currentPrinter(AliasHandle *ah, Handle *strh);static void			setCurrentPrinter(AliasHandle ah, Handle strh);static OSErr		CreateDestinations(void);static OSErr		CloseFaxDriver(void);/*** *	Hauptprogramm-Test ***/#if 0void		main(void);void		main(void){	FaxStart();	FaxDestination("\p0,5478556", "\p040 5223955", "\p·-Soft", "\pMarkus", "\pFritze", "\pHerr", true);	FaxStop();}#endif/*** *	Bei FaxStart() geretteter Drucker, wird bei FaxStop() wieder aktiviert. ***/AliasHandle		OldPrinterAlias;Handle			OldPrinterString;/*** *	Fax-Treiber anmelden ***/void			FaxStart(void){OSErr			iErr;AliasHandle		alias;FSSpec			target;Boolean			wasChanged;Handle			nameHand;	// alten Drucker retten	currentPrinter(&OldPrinterAlias, &OldPrinterString);	// Namen vom FaxPrint in eine Handle wandeln	iErr = PtrToHand(FaxName,&nameHand,FaxName[0] + 1);	// Alias auf den alten Drucker auflšsen => Volume + Directory wo die Druckertreiber liegen	iErr = ResolveAlias(0L, OldPrinterAlias, &target, &wasChanged);	// Aus FaxPrint-Filenamen und Volume + Directory einen FSSpec erzeugen	HLock(nameHand);	iErr = FSMakeFSSpec(target.vRefNum, target.parID, (StringPtr)*nameHand, &target);	// neuen Druckernamen setzen	HUnlock(nameHand);	// Alias auf den FaxPrint erzeugen	iErr = NewAlias(nil, &target, &alias);	// FaxPrint als aktuellen Drucker setzen	setCurrentPrinter(alias, nameHand);	// Nun was Fax-SpezifischesÉ	CreateDestinations();}/*** *	Fax-Treiber abmelden ***/void			FaxStop(void){	// Alte Destiations-Datei lšschen, Treiber canceln	CloseFaxDriver();	// Alten Drucker wieder aktivieren	setCurrentPrinter(OldPrinterAlias, OldPrinterString);}/*** *	Pascal-String kopieren (um Platz zu sparen) ***/static void		PStrCpy(StringPtr d, StringPtr s){	BlockMoveData(s, d, s[0]+1);}/*** *	Resource durch eine neue †berschreiben, ggf. erzeugen. Die aktuelle Resource-Map-Handle (!) *	wird zurŸckgegeben. * *	Wird als neue Resource NIL Ÿbergeben, so wird eine evtl. alte Resource gelšscht. * *	Achtung: Der Inhalt von newRh ist nach dem Aufruf ungŸltig!!! (freigegeben o.Š.) ***/static Handle	overWrite(ResType rType, short rID, Str255 rName, Handle newRh){Handle			oldRh;long			hSize;	oldRh = Get1Resource(rType, rID);				// alte Resource erstmal lesen	if(newRh) {										// keine neue Resource definiert? => Lšschen!		if(oldRh) {									// Alte Resource vorhanden?			hSize= GetHandleSize(newRh);			SetHandleSize(oldRh, hSize);			// auf neue Grš§e bringen			HLock(newRh);			PtrToXHand(*newRh,oldRh,hSize);			// und Daten Ÿbertragen			HUnlock(newRh);			DisposeHandle(newRh);			newRh = oldRh;		} else {			AddResource(newRh,rType,rID,rName);		// nicht vorhanden => hinzufŸgen		}		ChangedResource(newRh);		WriteResource(newRh);						// Resource wegschreiben	} else {		if(oldRh)			RmveResource(oldRh);					// ggf. vorhandene alte Resource lšschen	}	return newRh;									// Handle auf neue Resource zurŸckgeben}/*** *	RefNum eines Drivers mit Hilfe des Namens ermitteln ***/static short	GetDrvrRefNum(StringPtr driverName){#define UnitNtryCnt		0x1d2// bit in dCtlFlags that indicates ROM/RAM#define	_dRAMBased		6// length byte and name of driver [string]#define	drvrName		0x12short			negCount, dRef;DCtlHandle		DCEh;DCtlPtr			DCEp;StringPtr		drivePtr;	negCount = -*(short*)UnitNtryCnt;	// get -(table size)	// Check to see that driver is installed, obtain refNum.	// Assumes that an Open was done previously -- probably by an INIT.	// Driver doesn't have to be open now, though.	dRef = -12 + 1;  // we'll start with driver refnum == -12, right after .ATP entry	// Look through unit table until we find driver or reach the end.	do {		dRef--;							// bump to next refnum		DCEh = GetDCtlEntry(dRef);		// get handle to DCE		if(DCEh && ((drivePtr = (StringPtr)(DCEp = *DCEh)->dCtlDriver) != 0L)) {			if(DCEp->dCtlFlags & (1 << _dRAMBased))		// test dRamBased bit				drivePtr = *(StringPtr*)drivePtr;			if(drivePtr && EqualString(drivePtr + drvrName, driverName, false, false))				return dRef;		}	} while(dRef != negCount);	return 0; 							// can't find driver}/*** *	Aktuellen Drucker ermitteln. Die zurŸckgegebenen Handles sind _keine_ Resource-Map-Handles! ***/static void		currentPrinter(AliasHandle *ah, Handle *strh){short			saveRes;	saveRes = CurResFile();	UseResFile(0);	*ah = (AliasHandle)GetResource(rAliasType, -8192);	if(*ah)		DetachResource((Handle)*ah);	*strh = GetResource('STR ', -8192);	if(*strh)		DetachResource(*strh);	UseResFile(saveRes);}/*** *	Neuen Drucker setzen ***/static void		setCurrentPrinter(AliasHandle ah, Handle strh){short			saveRes;	saveRes = CurResFile();	UseResFile(0);	overWrite(rAliasType, -8192, "\p", (Handle)ah);	overWrite('STR ', -8192, "\p", strh);	UpdateResFile(0);	UseResFile(saveRes);}/*** *	File mit den EmpfŠngern erstellen ***/static OSErr	CreateDestinations(void){OSErr			iErr;short			fRefNum;short			saveRes;FSSpec			spec;Handle			theHandle;	// Systemordner suchen, FSSpec fŸr die "Destinations" erzeugen	iErr = FindFolder(kOnSystemDisk,kSystemFolderType,kDontCreateFolder,&spec.vRefNum,&spec.parID);	if(iErr) return iErr;	PStrCpy(spec.name, FaxDestName);	// ggf. vorhandene alte Datei lšschen	FSpDelete(&spec);	// Dort die "Destinations"-Datei inkl. Resource-Fork anlegen	iErr = FSpCreate(&spec, '\?\?\?\?', 'DSTR', smSystemScript);	if(iErr) return iErr;	HCreateResFile(spec.vRefNum,spec.parID,spec.name);	iErr = ResError();	if(iErr) return iErr;	// Resource-Fork šffnen	fRefNum = FSpOpenResFile(&spec,fsCurPerm);	iErr = ResError();	if(iErr) return iErr;	// und aktivieren	saveRes = CurResFile();	UseResFile(fRefNum);	// 'NdSt'-Resource erzeugen und wegschreiben	theHandle = NewHandleClear(34);	iErr = MemError();	if(iErr == noErr)		overWrite('NdSt', -8063, "\pDon't Delete Dests", theHandle);	// alte Resource wieder verwenden	UseResFile(saveRes);	// Resource schlie§en	CloseResFile(fRefNum);	return noErr;}/*** *	Fax-Treiber vorhanden??? ***/Boolean			FaxExist(void){	return GetDrvrRefNum(FaxDevName) != 0;}/*** *	Fax-Treiber schlie§en ***/static OSErr	CloseFaxDriver(void){short			devno;CntrlParam		pb;OSErr			iErr;FSSpec			spec;	// Systemordner suchen, FSSpec fŸr die "Destinations" erzeugen	iErr = FindFolder(kOnSystemDisk,kSystemFolderType,kDontCreateFolder,&spec.vRefNum,&spec.parID);	if(iErr == noErr) {		PStrCpy(spec.name, FaxDestName);		// ggf. vorhandene alte Datei lšschen		FSpDelete(&spec);	}	devno = GetDrvrRefNum(FaxDevName);	if(!devno) return dInstErr;	pb.ioCRefNum = devno;	pb.csCode = 1000;	return PBControlSync((ParmBlkPtr)&pb);}/*** *	Fax-EmpfŠnger definieren ***/typedef struct {	Str255	a;	Str255	CoverNotiz;				// 0x0100	char	b;						// 0x0200	short	d;						// 0x0202	unsigned long	startdate;		// 0x0204	char	CoverID[256];			// 0x0208	char	Delete;					// 0x0308	char	Group;					// 0x0309	short	c;						// 0x030A} faxsStruct;typedef struct {	Str31		FaxNummer;	Str31		Telefon;	Str31		Firma;	Str31		Vorname;	Str31		Name;	Str31		Titel;	Str15		CoverNotiz;	long		l1;	short		ResId;	char		b1;	char		b2;	long		l2;} DestStruct,*DestPtr,**DestHandle;OSErr			FaxDestination(Str255 FaxNummer, Str255 Telefon, Str255 Firma, Str255 Vorname, Str255 Name,								Str255 Titel, Boolean Delete){OSErr			iErr;short			fRefNum;short			saveRes;FSSpec			spec;DestHandle		dh;DestPtr			dp;faxsStruct		**fh;faxsStruct		*fp;//DateTimeRec		dtrp, ndate;	// Systemordner suchen, FSSpec fŸr die "Destinations" erzeugen	iErr = FindFolder(kOnSystemDisk,kSystemFolderType,kDontCreateFolder,&spec.vRefNum,&spec.parID);	if(iErr) goto sraus;	PStrCpy(spec.name, FaxDestName);	// Resource-Fork der "Destinations" šffnen	fRefNum = FSpOpenResFile(&spec,fsCurPerm);	iErr = ResError();	if(iErr) goto sraus;	// und aktivieren	saveRes = CurResFile();	UseResFile(fRefNum);	// 'dEST' Resource erzeugen	dh = (DestHandle)NewHandleClear(sizeof(DestStruct));	iErr = MemError();	if(iErr) goto raus;	HLock((Handle)dh);	dp = *dh;	PStrCpy(dp->FaxNummer, FaxNummer);	PStrCpy(dp->Telefon, Telefon);	PStrCpy(dp->Firma, Firma);	PStrCpy(dp->Vorname, Vorname);	PStrCpy(dp->Name, Name);	PStrCpy(dp->Titel, Titel);//	PStrCpy(dp->CoverNotiz, CoverNotiz);	dp->CoverNotiz[0] = 0;	dp->ResId = UniqueID('dEST');	dp->b2 = -1;	dp->l2 = -1L;	overWrite('dEST', dp->ResId, "\pDestinations", (Handle)dh);	// 'faxs' Resource erzeugen	fh = (faxsStruct**)NewHandleClear(sizeof(faxsStruct));	iErr = MemError();	if(iErr) goto raus;	HLock((Handle)fh);	fp = *fh;	fp->a[0] = 0;//	PStrCpy(fp->CoverNotiz, CoverNotiz);	fp->CoverNotiz[0] = 0;			// keine Cover-Notiz, da kein Cover!	fp->b = 0;	fp->d = 0;//	GetTime(&dtrp);//	ndate = dtrp;//	ndate.minute += Delay;			// Fax um "Delay"-Minuten verzšgern (auskommentiert)//	if(Delay)//		SetTime(&ndate);	GetDateTime(&fp->startdate);//	if(Delay)//		SetTime(&dtrp);	fp->CoverID[0] = 0;				// kein Cover!	fp->Delete = Delete;	fp->Group = false;				// kein Sammelanruf!	fp->c = 100;					// Anzahl der Versuche???	overWrite('faxs', 128, "\p", (Handle)fh);raus:	// Resource schlie§en	UseResFile(saveRes);	CloseResFile(fRefNum);sraus:	return iErr;}