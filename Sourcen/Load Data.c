#include "GlobalDefines.h"#include "mc_db.h"#include "utilities.h"#include "DialogBase.h"#include "dBASE Import.h"#include "GlobalLib.h"#include "GlobalStruct.h"#include "GeosErrors.h"#include <LFileStream.h>#include "MoreFilesExtras.h"#include <Devices.h>void		NewCD(Boolean eject);void		MyLoad(void);void		CloseFile(void);LFile		*CDFile;Boolean			IsCDROMDevice(short id);OSErr			GetIndVolume(short whichVol, Str255 volName, short *refnum);short			SearchCD(void);pascal Boolean	OwnCDMountFilter(DialogPtr d,EventRecord *event,short *item);/*** *	Ist das Laufwerk "refNum" ein CD-ROM Laufwerk? * *	Wir testen das, indem wir den Namen des entsprechenden Treibers vergleichen. Der Name *	ist bei _allen_ CD-ROM-Treibern Ò.AppleCDÓ! ***/Boolean			IsCDROMDevice(short refNum){DCtlHandle	dh = GetDCtlEntry(refNum);StringPtr	sp = (StringPtr)((*dh)->dCtlDriver + 18);	return ComparePString("\p.AppleCD", sp);}/*** *	Namen eines Volumes ermitteln ***/short		CDDriveInfo;OSErr		GetIndVolume(short whichVol, Str255 volName, short *refnum){// Return the name and vRefNum of volume specified by whichVol.HVolumeParam	volPB;OSErr			iErr;FSSpec			fileSpec;	*refnum = 0;	volPB.ioNamePtr = volName;			// make sure it returns the name	volPB.ioVRefNum = 0;				// 0 means use ioVolIndex	volPB.ioVolIndex = whichVol;		// use this to determine the volume	iErr = PBHGetVInfoSync((HParmBlkPtr)&volPB);	if(iErr != noErr)		return iErr;// Sicherer Test auf ein CD-ROM Laufwerk://	if(!IsCDROMDevice(volPB.ioVDRefNum))	// kein CD-ROM?//		return noErr;	*refnum = volPB.ioVRefNum;//	if(!(volPB.ioVAtrb & 0x8080))		// Laufwerk nicht schreibgeschŸtzt? 0x8000 = Soft, 0x80 = Hard)//		*refnum = 0;					// dann ein illegales Laufwerk!	CDDriveInfo = volPB.ioVDrvInfo;	// Modelldatenbank suchen	GetIndString(fileSpec.name, 4000, 5);	fileSpec.vRefNum = 0; fileSpec.parID = 0;	FInfo		fndrInfo;	iErr = FSpGetFInfo(&fileSpec, &fndrInfo);	if(iErr)		*refnum = 0;					// Datei nicht gefunden!	return iErr;						// evtl. Fehler melden}/*** *	Mastercast CD-ROM suchen ***/short			SearchCD(void){short			i;Str255			volName;Str255			theString;short			refnum = 0;	GetIndString(theString, 4000, 1);		// gesuchter Laufwerksname	for(i=1;;i++) {		if(GetIndVolume(i, volName, &refnum) != noErr)		// Namen eines Laufwerkes holen			break;		if(!refnum)			continue;		if(EqualString(volName, theString, false, false))	// Laufwerk gefunden?			break;							// Ja => raus		refnum = 0;	}	return refnum;}/*** *	eigener Dialoghandler fŸr das Mounten der CD ***/pascal Boolean	OwnCDMountFilter(DialogPtr d,EventRecord *event,short *item){	UNUSED(d); UNUSED(event);	short	refnum = SearchCD();		// CD suchen	if(refnum) {						// gefunden?		*item = 5;						// Button 5 auslšsen		return true;	}	return false;}/*** *	Datei - falls nštig - schlie§en ***/void		CloseFile(void){	if(CDFile) {		delete CDFile;		CDFile = nil;	}}/*** *	neue CD einlegen ***/void		NewCD(Boolean eject){	CloseFile();#if !DEMO	if(eject) {							// CD auswerfen?		OSErr	iErr = UnmountAndEject(nil, SearchCD());		if(iErr) {			CheckOSError(iErr);			// Fehler melden!			return;		}#if 0		short		refnum = SearchCD();		OSErr		iErr;		iErr = UnmountVol(nil, refnum);	// CD erstmal unmounten (vom Desktop werfen)		iErr = Eject(nil, CDDriveInfo);	// dann entgŸltig auswerfen#endif	}	if(!SearchCD()) {					// keine CD eingelegt?		if(DialogBase::Do(130, OwnCDMountFilter) == 1)			Exit();						// Programmende	}#endif	MyLoad();			// neue einlesen}/*** *	Dokument laden ***/void		MyLoad(void){Ptr				EnterDatensatz(dBASEFile *db, long id);Ptr				EnterAgenturDatensatz(dBASEFile *db, long id);void			ShowSplashInfo(void);void			RemoveSplashInfo(void);extern DialogBase	*SplashDialogPtr;long			count;FSSpec			fileSpec;dBASEFile		*db;Handle			fData;short			dataCount;	CloseFile();	SetAnimCursor(128);	DB_FreeAll();			// alte Daten freigeben	ShowSplashInfo();	{		// Modelldatenbank einlesen#if !DEMO	GetIndString(fileSpec.name, 4000, 5);#else	GetIndString(fileSpec.name, 4000, 15);#endif	fileSpec.vRefNum = 0; fileSpec.parID = 0;	{	LFileStream		theFile(fileSpec);	theFile.OpenDataFork(fsCurPerm);	fData = theFile.ReadDataFork();	}	HLockHi(fData);	{	void		DecodeGgubs(Ptr p, long size);		DecodeGgubs(*fData, GetHandleSize(fData));	}	// Datei offen halten, damit die CD nicht ausgeworfen werden kann	CDFile = new LFile(fileSpec);	CDFile->OpenDataFork(fsCurPerm);	db = new dBASEFile;	db->Init((UnsPtr)*fData);	dataCount = db->Count();#if !DEMO	DB_MInit(dataCount);#else	if(dataCount > MAXMODELLANZ)		dataCount = MAXMODELLANZ;#endif	ProgressBarItem	*pbp = (ProgressBarItem*)SplashDialogPtr->GetObject(2);	if(pbp)		pbp->SetMaxValue(dataCount);	for(count = 0; count<dataCount; count++) {		EnterDatensatz(db, count);				// Datensatz eintragen		ProgressBarItem	*pbp = (ProgressBarItem*)SplashDialogPtr->GetObject(2);		if(pbp)			pbp->SetValue(count);		SpinCursor(2);	}	delete db;	pbp = (ProgressBarItem*)SplashDialogPtr->GetObject(2);	if(pbp)		pbp->SetValue(dataCount);	DB_MSort();	DisposeHandle(fData);	}	{ // Agenturdatenbank einlesen	GetIndString(fileSpec.name, 4000, 7);	fileSpec.vRefNum = 0; fileSpec.parID = 0;	{	LFileStream		theFile(fileSpec);	theFile.OpenDataFork(fsCurPerm);	fData = theFile.ReadDataFork();	}	HLockHi(fData);#if 1	// Agenturdaten nicht kodieren!	{	void		DecodeGgubs(Ptr p, long size);		DecodeGgubs(*fData, GetHandleSize(fData));	}#endif	db = new dBASEFile;	db->Init((UnsPtr)*fData);	AList = new AgenturList;	for(count = 0; count<db->Count(); count++) {		AList->EnterAgenturDatensatz(db, count);		// Datensatz eintragen		SpinCursor(2);	}	delete db;	DisposeHandle(fData);	}raus:#if DEMO	for(int theItem=1; theItem<=5; theItem++)		SplashDialogPtr->HideItem(theItem);	SplashDialogPtr->ShowItem(11);	SplashDialogPtr->RedrawItem(11);	pfeil();	while(!::Button()) {}#endif	RemoveSplashInfo();	::FlushEvents(mouseDown|keyDown, 0);	pfeil();}