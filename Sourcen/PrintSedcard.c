/*** *	Sedcard ausdrucken ***/#include "PrintSedcard.h"#include "mc_db.h"#include "MCWindTools.h"#include "Utilities.h"#include <string.h>/*** *	Das Bild wird mit dem Konstructor ausgedruckt ***/PrintSedcard::PrintSedcard(long mid, Boolean first, Boolean &cancel){	ModellId = mid;	cancel = true;	if(first && !IsLandscapeSet())		// Landscape ausgeschaltet?		if(DialogBase::Do(129) == 2)	// dann warnen! ggf. abbrechen			return;	cancel = false;	ModellStruct	*ms = DB_MGet(ModellId);		// Modell suchen	strcpy((char*)PrDocName, ms->Modellname);	C2PStr((char*)PrDocName);	Print(false, first, true);		// Drucken	Print(true, first, true);		// Drucken abschlie§en}/*** *	diese statische Funktion enabled den Drucken-MenŸpunkt und setzt den Namen ggf. richtig ***/void		PrintSedcard::Enable(Boolean &enabled, short &markChar, Str255 &name){	UNUSED(markChar);	GetIndString(name, 4001, 1);	enabled = true;}/*** *	Hier geht es nun zum Drucken ***/#define PRINT_DEBUG		0#if PRINT_DEBUG#include "GlobalLib.h"#endif/*** *	Bild innerhalb eines Rechteckes zentriert ausdrucken ***/void		PrintSedcard::CenterDrawPict(short pict, Rect &r, Boolean draw){short		width, height;	width = r.right - r.left;	height = r.bottom - r.top;#if PRINT_DEBUG	FrameRect(&r);#endif	DrawPic(ModellId, pict, r, false, true);		// Bildgrš§e ermitteln	width -= r.right - r.left; width >>= 1;	height -= r.bottom - r.top; height >>= 1;	r.left += width;								// Bild zentrieren	r.right += width;	r.top += height;	r.bottom += height;#if PRINT_DEBUG	FillRect(&r, &qd.gray);#endif	if(draw) {		DrawPic(ModellId, pict, r, true, true);		// und in hoher QualitŠt ausgeben	}}/*** *	eine Seite ausdrucken ***/void		PrintSedcard::PrintPage(TPPrPort port, THPrint p){Rect			iRect, r1, r2, r3, r;ModellStruct	*ms = DB_MGet(ModellId);			// Modell suchenFontInfo		fi;short			width;static char		ptSizeTab[] = { 48,36,24,18,12 };short			i,pict;#if PRINT_DEBUGGrafPtr			savePort;WindowBase		*aWindow;Rect			wRect;#endif	UNUSED(p);	iRect = ((GrafPtr)port)->portRect;#if PRINT_DEBUG	GetPort(&savePort);	wRect = (*p)->rPaper;	OffsetRect(&wRect, 50, 50);	aWindow = new WindowBase;	aWindow->Open(&wRect, "\p", true, kHasThickDropShadowMask, 0L, (WindowRefX)-1L);	SetPort((GrafPtr)aWindow->WindRef);	// bedruckbaren Bereich umrahmen	iRect = ((GrafPtr)port)->portRect;	OffsetRect(&iRect, -(*p)->rPaper.left, -(*p)->rPaper.top);	FrameRect(&iRect);	{	// nicht bedruckbaren Bereich mit hellem Grau fŸllen	RgnHandle		rgn1,rgn2;	SetRect(&wRect, 0,0, 32767,32767);	rgn1 = NewRgn(); RectRgn(rgn1,&wRect);	rgn2 = NewRgn(); RectRgn(rgn2,&iRect);	DiffRgn(rgn1, rgn2, rgn1);	GetClip(rgn2);	SetClip(rgn1);	FillRect(&wRect, &qd.ltGray);	SetClip(rgn2);	DisposeRgn(rgn1);	DisposeRgn(rgn2);	}#endif	switch(GetPageNo()) {	// die Au§enseite der Sedcard drucken	case 1:		r1 = iRect; r2 = iRect;		r1.right = ((iRect.right - iRect.left)>>1) + iRect.left;		// Seite horizontal halbieren		r2.left = r1.right;		MoveTo(r1.right, r1.top); LineTo(r1.right, r1.bottom);	// Mittellinie der Seite zeichnen		// Copyright von MasterCast unter das Bild		{		Str255			stemp;		Rect			rr = iRect;		SetFont(1002);		GetFontInfo(&fi);		rr.bottom -= 3;		rr.top = rr.bottom - (fi.ascent + fi.descent + fi.leading);		r1.bottom = rr.top - ((rr.bottom - rr.top) >> 2);		// unter dem Bild Platz fŸr den Text + 1/4 der Fonthšhe lassen		rr.left += 20;		GetIndString(stemp, 4002, 10); P2CStr(stemp);			// Copyright-Text		rr.right = rr.left + TextWidth(stemp, 0L, strlen((char*)stemp)) + 4;	// Breite der Box beschrŠnken		TETextBox(stemp, strlen((char*)stemp), &rr, teFlushDefault);		}		// Linke Seite (letzte Seite!) der Sedcard ausgeben		InsetRect(&r1, 5, 5);				// etwas verkleinern		CenterDrawPict(2, r1, false);					// Bild zentrieren		Agentur	*ap = nil;		if(AList)			ap = AList->FindId(ms->Agentur);		if(ap) {			RgnHandle		rgn1,rgn2;			Rect			rr;			char			str[256];			Str255			stemp;			// Info-Rechteck mit der Modell- und Agenturinfo zusammensetzen			SetFont(1003);			GetFontInfo(&fi);			strcpy(str, ap->GetName()); strcat(str, "\r");			strcat(str, ap->GetStrasse()); strcat(str, "\r");			strcat(str, ap->GetOrt()); strcat(str, "\r");			GetIndString(stemp, 4002, 1); P2CStr(stemp); strcat(str,(char*)stemp); strcat(str, ap->GetTelefon()); strcat(str, "\r");			GetIndString(stemp, 4002, 2); P2CStr(stemp); strcat(str,(char*)stemp); strcat(str, ap->GetFax()); strcat(str, "\r");			strcat(str, "\r");			GetIndString(stemp, 4002, 3); P2CStr(stemp); strcat(str,(char*)stemp);			NumToString(ms->Groesse,stemp); P2CStr(stemp); strcat(str, (char*)stemp); strcat(str, "  ");			GetIndString(stemp, 4002, 4); P2CStr(stemp); strcat(str,(char*)stemp);			NumToString(ms->Brust,stemp); P2CStr(stemp); strcat(str, (char*)stemp); strcat(str, "\r");			GetIndString(stemp, 4002, 5); P2CStr(stemp); strcat(str,(char*)stemp);			NumToString(ms->Taille,stemp); P2CStr(stemp); strcat(str, (char*)stemp); strcat(str, "  ");			GetIndString(stemp, 4002, 6); P2CStr(stemp); strcat(str,(char*)stemp);			NumToString(ms->Huefte,stemp); P2CStr(stemp); strcat(str, (char*)stemp); strcat(str, "\r");			GetIndString(stemp, 4002, 7); P2CStr(stemp); strcat(str,(char*)stemp);			NumToString(ms->Schuhe,stemp); P2CStr(stemp); strcat(str, (char*)stemp); strcat(str, "\r");			GetIndString(stemp, 4002, 8); P2CStr(stemp); strcat(str,(char*)stemp);			GetIndString(stemp, 2000, ms->Haarfarbe); P2CStr(stemp); strcat(str, (char*)stemp); strcat(str, "\r");			GetIndString(stemp, 4002, 9); P2CStr(stemp); strcat(str,(char*)stemp);			GetIndString(stemp, 2003, ms->Augenfarbe); P2CStr(stemp); strcat(str, (char*)stemp); strcat(str, "\r");			// Das Bild mit Clipping ausgeben			rgn1 = NewRgn(); InsetRect(&r1, -1, -1); RectRgn(rgn1,&r1);			SetRect(&rr, r1.left, r1.bottom - (fi.ascent + fi.descent + fi.leading)*11, r1.left + 130, r1.bottom + 1);			rgn2 = NewRgn(); RectRgn(rgn2,&rr);			DiffRgn(rgn1, rgn2, rgn1);			GetClip(rgn2);			SetClip(rgn1);			InsetRect(&r1, 1, 1);			DrawPic(ModellId, 2, r1, true, true);		// und in hoher QualitŠt ausgeben			SetClip(rgn2);			DisposeRgn(rgn1);			DisposeRgn(rgn2);			// Textbox mit dem Modellinfo			OffsetRect(&rr, 0, -1);			FrameRect(&rr); InsetRect(&rr, 1, 1);			TETextBox(str, strlen(str), &rr, teFlushDefault);		} else {			DrawPic(ModellId, 2, r1, true, true);		// und in hoher QualitŠt ausgeben		}		// Rechte Seite (Seite 1!) der Sedcard ausgeben		InsetRect(&r2, 5, 5);							// etwas verkleinern		width = r2.right - r2.left;		SetFont(1004);		for(i=0;;i++) {			TextSize(ptSizeTab[i]);						// Fontgrš§e setzen			if(width >= TextWidth(ms->Modellname, 0L , strlen(ms->Modellname)))				break;									// der Text mu§ in der Breite passenÉ		}		GetFontInfo(&fi);		r3 = r2;		r2.bottom -= fi.ascent + fi.descent + fi.leading + 5;		CenterDrawPict(1, r2, true);					// Bild zentrieren		// Namen des Modells unter das Bild		r2.top = r2.bottom + 5;		r2.bottom = r2.top + fi.ascent + fi.descent + fi.leading;		r1.left = r3.left; r1.right = r3.right;		TETextBox(ms->Modellname, strlen(ms->Modellname), &r2, teJustCenter);		break;	// die Innenseite(n) der Sedcard drucken	default:		r1 = iRect; r2 = iRect;		r1.right = ((iRect.right - iRect.left)>>1) + iRect.left;		// Seite horizontal halbieren		r2.left = r1.right;		MoveTo(r1.right, r1.top); LineTo(r1.right, r1.bottom);	// Mittellinie der Seite zeichnen		// Beide Seiten der Sedcard ausgeben		pict = (GetPageNo()-2)*8+3;		for(i=0, r = r1; i<2; i++, r = r2) {			Rect	ra,rb,rc,rd;			// Aufteilung der Rechtecke auf der Seite:			// ra rc			// rb rd			InsetRect(&r, 5, 5);					// etwas verkleinern			ra = r; rb = r; rc = r; rd = r;			ra.right = ((ra.right - ra.left)>>1) + ra.left;					// Seite in der Mitte halbieren			rb.right = ra.right; rc.left = ra.right + 5; rd.left = rc.left;			ra.bottom = ((ra.bottom - ra.top)>>1) + ra.top;			rb.top = ra.bottom + 5; rc.bottom = ra.bottom; rd.top = rb.top;			if(pict <= ms->PicAnz) {	// oben links				CenterDrawPict(pict, ra, true);				pict++;			}			if(pict <= ms->PicAnz) {	// oben rechts				CenterDrawPict(pict, rc, true);				pict++;			}			if(pict <= ms->PicAnz) {	// unten links				CenterDrawPict(pict, rb, true);				pict++;			}			if(pict <= ms->PicAnz) {	// unten rechts				CenterDrawPict(pict, rd, true);				pict++;			}		}		if(pict > ms->PicAnz)			SetPageNo(0);				// Alle Seiten sind nun ausgedruckt		break;	}#if PRINT_DEBUG	while(!CheckKey(0x3B) && !AbortInQueue()) {}	// auf "Control" warten	delete aWindow;	SetPort(savePort);#endif}