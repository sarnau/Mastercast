/*** *	ein Bild ausdrucken ***/#include "PrintPict.h"#include "mc_db.h"#include "MCWindTools.h"#include "Utilities.h"#include <string.h>/*** *	Das Bild wird mit dem Konstructor ausgedruckt ***/PrintPict::PrintPict(long mid, short pict, Boolean first, Boolean &cancel){	ModellId = mid;	Pict = pict;	cancel = true;	if(first && IsLandscapeSet())		// Landscape eingeschaltet?		if(DialogBase::Do(135) == 2)	// dann warnen! ggf. abbrechen			return;	cancel = false;	ModellStruct	*ms = DB_MGet(ModellId);		// Modell suchen	strcpy((char*)PrDocName, ms->Modellname);	C2PStr((char*)PrDocName);	ConcatPString(PrDocName, "\p #");	Str255		tempStr;	NumToString(pict, tempStr);	ConcatPString(PrDocName, tempStr);	Print(false, first, true);		// Drucken	Print(true, first, true);		// Drucken abschlie§en}/*** *	diese statische Funktion enabled den Drucken-MenŸpunkt und setzt den Namen ggf. richtig ***/void		PrintPict::Enable(Boolean &enabled, short &markChar, Str255 &name){	UNUSED(markChar);	GetIndString(name, 4001, 2);	enabled = true;}/*** *	Hier geht es nun zum Drucken ***/#define PRINT_DEBUG		0#if PRINT_DEBUG#include "GlobalLib.h"#endif/*** *	Bild innerhalb eines Rechteckes zentriert ausdrucken ***/void		PrintPict::CenterDrawPict(short pict, Rect &r, Boolean draw){short		width, height;	width = r.right - r.left;	height = r.bottom - r.top;#if PRINT_DEBUG	FrameRect(&r);#endif	DrawPic(ModellId, pict, r, false, true);		// Bildgrš§e ermitteln	width -= r.right - r.left; width >>= 1;	height -= r.bottom - r.top; height >>= 1;	r.left += width;								// Bild zentrieren	r.right += width;	r.top += height;	r.bottom += height;#if PRINT_DEBUG	FillRect(&r, &qd.gray);#endif	if(draw) {		DrawPic(ModellId, pict, r, true, true);		// und in hoher QualitŠt ausgeben	}}/*** *	eine Seite (ein Photo ist eh nur eine Seite gro§) ausdrucken ***/void		PrintPict::PrintPage(TPPrPort port, THPrint p){Rect			iRect;ModellStruct	*ms = DB_MGet(ModellId);			// Modell suchenFontInfo		fi;#if PRINT_DEBUGGrafPtr			savePort;WindowBase		*aWindow;Rect			wRect;#endif	UNUSED(p);	iRect = ((GrafPtr)port)->portRect;#if PRINT_DEBUG	GetPort(&savePort);	wRect = (*p)->rPaper;	OffsetRect(&wRect, 50, 50);	aWindow = new WindowBase;	aWindow->Open(&wRect, "\p", true, kHasThickDropShadowMask, 0L, (WindowRefX)-1L);	SetPort((GrafPtr)aWindow->WindRef);	// bedruckbaren Bereich umrahmen	iRect = ((GrafPtr)port)->portRect;	OffsetRect(&iRect, -(*p)->rPaper.left, -(*p)->rPaper.top);	FrameRect(&iRect);	{	// nicht bedruckbaren Bereich mit hellem Grau fŸllen	RgnHandle		rgn1,rgn2;	SetRect(&wRect, 0,0, 32767,32767);	rgn1 = NewRgn(); RectRgn(rgn1,&wRect);	rgn2 = NewRgn(); RectRgn(rgn2,&iRect);	DiffRgn(rgn1, rgn2, rgn1);	GetClip(rgn2);	SetClip(rgn1);	FillRect(&wRect, &qd.ltGray);	SetClip(rgn2);	DisposeRgn(rgn1);	DisposeRgn(rgn2);	}#endif	InsetRect(&iRect, 5, 5);	// Blatt etwas verkleinern	iRect.bottom -= 30;	CenterDrawPict(Pict, iRect, true);	// Namen des Modells unter das Bild	SetFont(3000);	GetFontInfo(&fi);	iRect.top = iRect.bottom + 5;	iRect.bottom = iRect.top + fi.ascent + fi.descent + fi.leading + 3;	ms = DB_MGet(ModellId);				// Modell suchen	TETextBox(ms->Modellname, strlen(ms->Modellname), &iRect, teJustCenter);	SetPageNo(0);					// Alle Seiten sind nun ausgedruckt#if PRINT_DEBUG	while(!CheckKey(0x3B) && !AbortInQueue()) {}	// auf "Control" warten	delete aWindow;	SetPort(savePort);#endif}