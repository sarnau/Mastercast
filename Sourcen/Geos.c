#include "Geos.h"#include "DoEvent.h"#include "GlobalLib.h"#include "GeosErrors.h"#include "GlobalStruct.h"#include "MenuLib.h"#include "PrintBase.h"#include "DialogBase.h"#include "AEAktion.h"#include <string.h>#include <Processes.h>#include <ImageCompression.h>#include <Movies.h>#include <Gestalt.h>#include <LFileStream.h>#include <TextUtils.h>OSErr			DoSendAEMCQuit(void);/*** *	Window-Klasse ***/#include "MCSelection.h"#include "MCHeadsheet.h"#include "MCInfo.h"#include "MCLayout.h"#include "MCToolbar.h"#include "MCView.h"#include "MCBrowser.h"////	Größe eines Feldes im Browser//short		PLayoutWidth = 150;		// Gesamtbreiteshort		PLayoutHeight = 220;	// Gesamthöhe/*** *	Funktionsprototypen ***/void		NewCD(Boolean eject);void		CloseFile(void);void		CmdFind(void);void		DoPrint(TPPrPort port,THPrint p);void		Exit(void);void		InitMastercastSuite(void);EDebugAction	UDebugging::gDebugThrow  = debugAction_Nothing;EDebugAction	UDebugging::gDebugSignal = debugAction_Nothing;/*** *	das “Hauptprogramm” ***/void	main(void){//	DebugStr("\pActivating Discipline; DSCA ON; G;");//	DebugStr("\pAktiviere Debugmode; Zap ON; Leaks ON; G;");	InitAll();							// Macintosh Toolbox, Stackgröße, etc.	// Fehler führen zu Alerts//	gDebugThrow = debugAction_SourceDebugger;//	gDebugSignal = debugAction_SourceDebugger;	UDebugging::SetDebugThrow(debugAction_Alert);	UDebugging::SetDebugSignal(debugAction_Alert);	try {		// 	Software: min. System 7.0		if (gSystemVersion < 0x700)			Throw_(gestaltSystemVersion);// Software zu alt…		// QuickTime mit Comression Manager vorhanden?		long	resp;		if (Gestalt(gestaltQuickTime, &resp) != noErr)			Throw_(gestaltQuickTime);		if (Gestalt(gestaltCompressionMgr, &resp) != noErr || resp < 15)			Throw_(gestaltCompressionMgr);		EnterMovies();					// QuickTime initialisieren		MenuBarInit(128);				// Menüleiste anmelden		InitMastercastSuite();			// Apple Events anmelden		extern void InitAppleEvents(void);		InitAppleEvents();				// AppleEvents anmelden		// Fenster-Klassen initialisieren (da stat. Konstruktoren fehlen)		NewCD(false);					// CD muß vorhanden sein, Daten einlesen		// in den Preferences nachsehen, ob die Toolbar geöffnet werden sollen		ToolbarPref		pref;		ReadPref('TOOL', 1, (Ptr)&pref, sizeof(pref));		if(!pref.openNotAtStart)			SendMenuCmd(cOpenToolbar, nil);	// Toolbar öffnen		EventLoop();	}	// Fehler während der Initphase sind alle schwerwiegend	catch(PP_PowerPlant::ExceptionCode inErr) {		switch(inErr) {		case gestaltSystemVersion:			DialogBase::Do(10400);			break;		case gestaltQuickTime:		case gestaltCompressionMgr:			DialogBase::Do(10401);			break;		case err_NilPointer:			CheckOSError(nilHandleErr);			break;		case err_AssertFailed:			CheckOSError(abortErr);			break;		default:			CheckOSError(inErr);	// Fehler melden		}	}//	DebugStr("\pDeaktiviere Debugmode; Zap OFF; Leaks OFF");//	DebugStr("\pTurning Discipline off; DSCA OFF; G;");	Exit();							// Programmende}////	Programmende nach schweren Fehlern —IRQs abmelden—//void	Exit(void){	CloseFile();	ExitToShell();					// letzter Befehl: Programm verlassen}/*** *	Menüpunkt enablen, etc. ***/void	GetCommandStatus(long cmd, Boolean &enabled, short &markChar, Str255 &name){	UNUSED(markChar);	switch(cmd) {	case cOpen:	case cFind:	case cOpenSelektion:	case cOpenBrowser:			if(!ModellAnz || !AList || !AList->Count())// keine Daten vorhanden?				break;						// => disablen!			enabled = true;			break;	case cOpenToolbar:			GetIndString(name, 4006, WWToolbar?17:16);	case cAboutApp:	case cPageSetup:	case cQuit:#if !DEMO	case cOpenNewCD:#endif			enabled = true;			break;	case cClose:	// Fenster schließen			if(WindowBase::BaseFrontWindow())				enabled = true;			break;	}}/*** *	Menüpunkt angewählt ***/void	DoCommand(long cmd){	switch(cmd) {	// Apfel Menü	case cAboutApp:			void	DoAbout(void);			DoAbout();					// “About” angewählt			break;	// Ablage Menü	case cOpenNewCD:			if(DialogBase::Do(140) != 1) break;		// User will nicht wechseln? => raus			WindowBase	*wwb;			// alle Fenster schließen!			do {				wwb = WindowBase::BaseFrontWindow();				if(wwb) delete wwb;			} while(wwb);			NewCD(true);				// CD auswerfen, neue CD mounten			MCSelection::Create();		// Selection wieder öffnen			break;	case cOpen:			LoadHeadsheet();			break;	case cPageSetup:			PrintBase::PageSetup();			break;	case cQuit:			ThrowIfOSErr_(DoSendAEMCQuit());			break;	// Bearbeiten Menü	case cFind:			CmdFind();			break;	// Windows Menü	case cClose:	// Fenster schließen			WindowBase	*wb = WindowBase::BaseFrontWindow();			if(wb) delete wb;			break;	case cOpenToolbar:			if(!WWToolbar) {		// Toolbar noch nicht offen?				WWToolbar = new MCToolbar;				WWToolbar->Open();			} else {				delete WWToolbar;				WWToolbar = nil;			}			break;	case cOpenSelektion:			MCSelection::Create();			break;	case cOpenBrowser:			MCBrowser::Create();			break;	}// Reste der alten Version#if 0	if (title == gFileId) {	// “Datei”-Menü		switch(item) {		case iHeadsheetSave://							WWHeadsheet->Save();						break;		case iPageSetup:// PageSetup();						break;		case iPrint:	#if 0						{						WindowPtr	w = (WindowPtr)gTopWindow;						if(w)							if(!((MCWindow*)GetWRefCon(w))->PrintSetup())								break;		// User will nicht drucken => raus						}						AppPrintDocument(false,true,true);						AppPrintDocument(true,false,false);#endif						break;#if 0		case iFaxPreferences:						AFax->Preferences();						break;		case iFaxPageSetup:						AFax->Init();						PageSetup();						AFax->Exit();						break;		case iFaxPrint:	AFax->Init();#if 0						{						WindowPtr	w = (WindowPtr)gTopWindow;						if(w)							if(!((MCWindow*)GetWRefCon(w))->PrintSetup()) {								AFax->Exit();								break;		// User will nicht drucken => raus							}						}#endif						AppPrintDocument(false,false,true);						AppPrintDocument(true,false,false);						AFax->Exit();						break;#endif		}	}#endif}/*** *	Drucken… im File-Menü angewählt ***/#if 0void		DoPrint(TPPrPort port,THPrint p){WindowPtr	w = (WindowPtr)gTopWindow;	if(w)		((MCWindow*)GetWRefCon(w))->Print(port, p);}#endif/*** *	Modell nach Namen oder ID suchen ***/LDEFHeadsheetStruct		*SuchHasso(StringPtr suchString, short &anz);LDEFHeadsheetStruct		*SuchHasso(StringPtr suchString, short &anz){Boolean					flag;StringPtr				sp;long					theNum;LDEFHeadsheetStruct		*dp, *pp;	dp = (LDEFHeadsheetStruct*)NewPtr(ModellAnz * sizeof(LDEFHeadsheetStruct));	pp = dp;	UpperText((Ptr)suchString, strlen((char*)suchString));	flag = true;	for(sp = suchString; *sp; sp++)		if(*sp < '0' || *sp > '9')	// Nur Ziffern eingegeben?			flag = false;			// Nein!	if(flag) {						// Nach einer Modell-ID suchen		C2PStr((char*)suchString);		StringToNum(suchString,&theNum);		P2CStr(suchString);		for(int i=0; ModellList[i]; i++) {			if(ModellList[i]->Id != theNum)				continue;			pp->ms = ModellList[i];			pp->pic = 1;			pp++;		}	} else {						// Ansonsten den Teil eines Modellnamens suchen		for(int i=0; ModellList[i]; i++) {			Str255		stemp;			strcpy((Ptr)stemp, ModellList[i]->Modellname);			UpperText((Ptr)stemp, strlen((char*)stemp));			if(strstr((char*)stemp, (char*)suchString) == 0L)	// ein Modell gefunden?				continue;				// Nein => weitersuchen			pp->ms = ModellList[i];			pp->pic = 1;			pp++;		}	}	anz = pp - dp;	if(anz) {		// überhaupt Modelle gefunden?		MCHeadsheet::Create(anz, dp);		DisposePtr((Ptr)dp);	} else {		if(AEInteractWithUser(60 * 60, nil, nil) == noErr)			DialogBase::Do(138);	}	return dp;}/*** *	Suchen Dialogbox ***/void			CmdFind(void){short			item;DialogBase		*dp;static Str255	SuchBegriff;	dp = new DialogBase;	dp->Open(134);					// Dialog laden	dp->SetDialogText(4, SuchBegriff);	dp->SelectInputItem(4);			// Text selektieren	dp->ModalDialog(nil, &item);	// Dialog abarbeiten	if(item == ok)		dp->GetDialogText(4, SuchBegriff);	// Bei "OK" den SuchBegriff merken	delete dp;						// Dialog schließen	if(item == ok) {				// Ok? Dann Event-Anfrage an uns schicken		AppleEvent		theAppleEvent;		OSErr			iErr;		P2CStr(SuchBegriff);		iErr = AECreateAppleEvent('MCas', 'find', &gSelfAddress, kAutoGenerateReturnID, kAnyTransactionID, &theAppleEvent);		if(iErr == noErr)			iErr = AEPutParamPtr(&theAppleEvent, keyDirectObject, typeChar, SuchBegriff, strlen((char*)SuchBegriff));		if(iErr == noErr)			iErr = AESend(&theAppleEvent, nil, kAENoReply, kAENormalPriority, kAEDefaultTimeout, nil, nil);		ThrowIfOSErr_(iErr);		iErr = AEDisposeDesc(&theAppleEvent);		ThrowIfOSErr_(iErr);		C2PStr((char*)SuchBegriff);	}}/*** *	Find AppleEvent installieren ***/pascal OSErr	DoAEMCFind(const AppleEvent *message,AppleEvent *reply,long refcon);void			InitMastercastSuite(void){	AEInstallEventHandler('MCas', 'find', NewAEEventHandlerUPP(DoAEMCFind), 0L, false);}/*** *	Übergebene Modelle suchen ***/pascal OSErr	DoAEMCFind(const AppleEvent *message,AppleEvent *reply,long refcon){DescType	typeCode;OSErr		iErr;Str255		suchString;Size		actualSize;	UNUSED(refcon);LDEFHeadsheetStruct	*dp = nil;short		anz;	// Suchbegriff ermitteln	iErr = AEGetParamPtr(message, keyDirectObject, typeChar, &typeCode, suchString, sizeof(suchString) - 1, &actualSize);	if(iErr) goto raus;	suchString[actualSize] = 0;					// Suchbegriff in C-String wandeln	dp = SuchHasso(suchString, anz);	// und suchen… (Rückgabe: Liste der gefundenen Modelle (ModellStruct*))	// wird ein Reply erwartet?	if(!reply->dataHandle) goto raus;			// nein =>	// Namen aller gefundenen Modelle als Liste zurückgeben	AEDescList	resultList;	iErr = AECreateList(nil, 0L, false, &resultList);	if(iErr) goto raus;	int		i;	for(i=0; i<anz; i++) {		char	*sp = dp[i].ms->Modellname;		iErr = AEPutPtr(&resultList, 0, typeChar, sp, strlen(sp));		if(iErr) goto raus;	}	iErr = AEPutParamDesc(reply, keyDirectObject, &resultList);raus:	if(dp)		DisposePtr((Ptr)dp);	return iErr;}/*** *	AppleEvent Quit Event abarbeiten ***/OSErr			DoSendAEMCQuit(void){AppleEvent		theAppleEvent;OSErr			iErr;	iErr = AECreateAppleEvent(kCoreEventClass, kAEQuitApplication, &gSelfAddress, kAutoGenerateReturnID, kAnyTransactionID, &theAppleEvent);	if(iErr == noErr)		iErr = AESend(&theAppleEvent, nil, kAENoReply|kAEAlwaysInteract, kAENormalPriority, kAEDefaultTimeout, nil, nil);	AEDisposeDesc(&theAppleEvent);	return iErr;}/*** *	Headsheet laden ***/void		LoadDoc(FSSpecPtr f){	LFileStream		theFile(*f);	// Datei öffnen und einlesen	theFile.OpenDataFork(fsCurPerm);	Handle	theData = theFile.ReadDataFork();	int		count = GetHandleSize(theData) / sizeof(LDEFHeadsheetStruct);	// Anzahl der Datensätze in der Datei	ThrowIfMemError_();	// Aufbereiten einer Liste, die dem Headsheet übergeben wird	LDEFHeadsheetStruct	*dp = (LDEFHeadsheetStruct*)NewPtr(count * sizeof(LDEFHeadsheetStruct));	ThrowIfMemFail_(dp);	int					MAnz = 0;	LDEFHeadsheetStruct	*lp = (LDEFHeadsheetStruct*)*theData;	for(LDEFHeadsheetStruct	*pp = dp; count > 0; count--, lp++) {		ModellStruct	*ms = DB_MGet((long)lp->ms);	// Modell suchen		if(!ms) continue;		MAnz++;		pp->ms = ms;			// ModellStructPtr merken		pp->pic = lp->pic;		// Bildnummer übertragen		pp++;	}	MCHeadsheet::Create(MAnz, dp);	DisposePtr((Ptr)dp);	DisposeHandle(theData);}void		LoadHeadsheet(void){StandardFileReply	reply;SFTypeList			typeList;	typeList[0] = gSignature;	StandardGetFile(nil, 1, typeList, &reply);	if(!reply.sfGood) return;		// Abbruch => raus	LoadDoc(&reply.sfFile);			// Datei laden}