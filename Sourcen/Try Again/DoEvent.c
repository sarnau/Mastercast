/*** *	Event Handler * *	©1994 Dekotec Info-Sys, Markus Fritze ***/#include "DoEvent.h"#include "GlobalLib.h"#include "MenuLib.h"#include <AppleEvents.h>#include "WindowBase.h"#include "GeosErrors.h"#include <Sound.h>#include <ToolUtils.h>#include <DiskInit.h>EventRecord		gTheEvent;				// globaler Event-RecordBoolean			gQuitApplication;		// true, dann Programmende/*** *	globale Event-Schleife ***/void	EventLoop(void){Boolean		gFlag;	while(!gQuitApplication) {		try {			gFlag = GetEvent(everyEvent);			if (gFlag)					// ein Event vorhanden?				DoEvent();				// dann diesen auswerten			else				DoIdleTasks();			// sonst nur Idle…		}		catch(PP_PowerPlant::ExceptionCode inErr) {			if(inErr == err_NilPointer)				CheckOSError(nilHandleErr);			else				CheckOSError(inErr);	// Fehler melden		}		catch(short inErr) {			if(inErr == err_NilPointer)				CheckOSError(nilHandleErr);			else				CheckOSError(inErr);	// Fehler melden		}		catch(...) {			CheckOSError(-1);			// unbekannter Fehler!		}	}}/*** *	Einen Event abholen ***/Boolean	GetEvent(short eventMask){static RgnHandle	mouseRgn = nil;Boolean				flag;	if(!mouseRgn)		mouseRgn = NewRgn();	flag = WaitNextEvent(eventMask, &gTheEvent, WindowBase::AllGetTicks(), mouseRgn);	WindowBase::AdjustCursor(gTheEvent.where, &mouseRgn);	return flag;}/*** *	Vararbeitung von Idle (Null)-Events ***/void	DoIdleTasks(void){	WindowBase::AllEventIdle();}/*** *	aktuellen Event verarbeiten ***/void	DoEvent(void){static EventRecord	gLastEvent;				// letzter Maus-up-Event (Doppelklick!)	switch(gTheEvent.what) {	case	mouseUp:			gLastEvent = gTheEvent;	// letzten Event für Doppelklick merken			break;	case	mouseDown:				// mit Doppelklick-Verwaltung			short		part;			WindowPtr	whichWindow;			static short	DClickCount;			if(((gLastEvent.when + GetDblTime()) > gTheEvent.when) &&					(ABS(gTheEvent.where.h - gLastEvent.where.h)+					ABS(gTheEvent.where.v - gLastEvent.where.v))<6) {				DClickCount++;		// ein Mausklick mehr			} else				DClickCount = 1;	// ein Mausklick			part = FindWindow(gTheEvent.where, &whichWindow);			WindowBase	*wb = nil;			if(whichWindow)				wb = WindowBase::Class(whichWindow);			switch(part) {			case	inDesk:					case	inSysWindow:WindowBase	*fw = WindowBase::BaseFrontWindow();								if(fw && fw->IsModal()) {									SysBeep(1);									break;								}								if(part == inSysWindow)									SystemClick(&gTheEvent, (WindowPtr)whichWindow);								break;			case	inMenuBar:	wb = WindowBase::BaseFrontWindow();								AdjustMenu(wb);								EventMenu(MenuSelect(gTheEvent.where), wb);								break;			case	inDrag:		wb->EventDrag();								break;			case	inGrow:		wb->EventGrow();								break;			case	inContent:	wb->EventKlick(gTheEvent.where, DClickCount);								break;			case	inZoomIn:			case	inZoomOut:	if(!TrackBox((WindowPtr)whichWindow, gTheEvent.where, part))			// Klick in die Zoom-Box abwarten									break;						// => außerhalb die Maustaste losgelassen => raus								wb->EventZoom(part);								break;			case	inGoAway:	if(!TrackGoAway((WindowPtr)whichWindow, gTheEvent.where))									break;								wb->EventGoAway();								break;			}			break;	case	keyDown:	case	autoKey:			if(WindowBase::AllEventKey(gTheEvent.message, gTheEvent.modifiers)) break;			if(!(gTheEvent.modifiers & cmdKey))		// Command gedrückt?				break;								// nein => raus			if(gTheEvent.what != keyDown)			// Auto-Repeat?				break;								// => raus			wb = WindowBase::BaseFrontWindow();			AdjustMenu(wb);			EventMenu(MenuKey(gTheEvent.message), wb);			break;	case	updateEvt:			WindowBase::Class((WindowPtr)gTheEvent.message)->EventDraw();			break;	case	activateEvt://			DebugStr("\pGot activate from event loop.");//			WindowBase::Class((WindowPtr)gTheEvent.message)->EventActivate((gTheEvent.modifiers & activeFlag) == activeFlag);			break;	case	diskEvt:			if(HiWord(gTheEvent.message) == noErr) break;			Point	p;			SetPt(&p, kDILeft, kDITop);			DIBadMount(p,gTheEvent.message);			break;	case	kHighLevelEvent:			AEProcessAppleEvent(&gTheEvent);			break;	case	osEvt:			switch((gTheEvent.message>>24) & 0xFF) {			case	mouseMovedMessage:					DoIdleTasks();					break;#if 1		// während des Debuggens diesen Event wegschalten (er nervt :-)			case	suspendResumeMessage:					SetCursor(&qd.arrow);					if(gTheEvent.message & resumeFlag) {						ResumeFloatingWindows();						AdjustMenu(WindowBase::BaseFrontWindow());					} else {						::HiliteMenu(0);						SuspendFloatingWindows();					}#endif			}	}}