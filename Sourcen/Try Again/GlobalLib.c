/*** *	eine globale Sammlung von neuen Routinen * *	©1994 Dekotec Abt. Info-Sys, Markus Fritze ***/#include "GlobalDefines.h"#include "GlobalLib.h"#include "Utilities.h"#include "GeosErrors.h"#include "DialogBase.h"#include <Traps.h>#include <Gestalt.h>#include <Processes.h>#include <LowMem.h>//#include <CursorCtl.h>Boolean		gDrapAndDrop;			// Drag & Drop Manager vorhanden?Boolean		gBalloonHelp;			// Balloon Help vorhanden?short		gSystemVersion;			// Versionsnummer vom Systemshort		gQDVersion;				// Haupt-Quickdraw-Version:									//	0: originales QD									//	1: Color QD									//	2: 32-bit QDOSType		gSignature;				// Signatur der ApplikationStr31		gAppName;				// Name des Programmsshort		gCurrentCursor = -1;	// aktueller Cursor/*** *	Trap-Abfragefunktionen ***/short		NumToolboxTraps(void){	return((NGetTrapAddress(_InitGraf,ToolTrap) == NGetTrapAddress(0xAA6E,ToolTrap))?			0x200:0x400);}TrapType	GetTrapType(short theTrap){	return((theTrap & 0x800)?ToolTrap:OSTrap);}Boolean		TrapAvailable(short theTrap){TrapType	fType;	fType = GetTrapType(theTrap);	if (fType == ToolTrap) {		theTrap &= 0x7FF;		if (theTrap >= NumToolboxTraps())	// Trap-Nummer zu gro§?			return(false);					// dann Fehler!	}	return(NGetTrapAddress(theTrap,fType) != NGetTrapAddress(_Unimplemented,ToolTrap));}/*** *	GetGestaltResult() ermittelt den RŸckgabewert der Gestalt Funktion. Falls ein *	Fehler auftritt, so wird 0 zurŸckgegeben. Somit ist diese Funktion nur dann *	brauchbar, wenn kein Fehler auftreten kann (Gegenbeispiel: AUX-Version erfragen) ***/long	GetGestaltResult(OSType gestaltSelector){long	gestaltResult;	if (Gestalt(gestaltSelector,&gestaltResult) == noErr)		return gestaltResult;	else		return 0;}/*** *	Neuen Cursor setzen ***/void		FetchCursor(short id){CursHandle		swCur = nil;CCrsrHandle		colCur = nil;	if(id && gCurrentCursor == id) return;	// Cursor ist bereit aktiv!	gCurrentCursor = id;	if(gQDVersion > 0)					// Color QuickDraw vorhanden?		colCur = GetCCursor(id);		// dann einen Farbcursor laden	if(colCur) {						// Farbcursor gefunden?		SetCCursor(colCur);				// dann setzen		DisposeCCursor(colCur);			// und gleich wieder freigebenÉ (ACHTUNG: NICHT ReleaseResource() !!!)	} else {		if (id != 0)					// nicht auf den Pfeil umschalten?			swCur = GetCursor(id);		// dann einen Cursor laden		if (swCur) {			SetCursor(*swCur);			// geladenen Cursor setzen			ReleaseResource((Handle)swCur);	// Resource freigeben (da GetCursor(id) == GetResource('CURS', id))		} else {			SetCursor(&qd.arrow);		// ansonsten auf den Pfeil umschalten		}	}}/*** *	Animierten Cursor laden ***/// Struktur der "acur" Resourcetypedef struct {	unsigned short	numCursors;	unsigned short	index;	struct {		short		ID;		short		unused;	} cursors[1];} Acur, *AcurPtr, **AcurHandle;AcurHandle			pCursors;			// Handle to the acur resource.short				pDesiredCount;		// Value to be placed in the vblCount field of out VBL task record.void		SetAnimCursor(short resID){	// alten Cursor freigeben	if(pCursors) {		HUnlock((Handle)pCursors);		ReleaseResource((Handle)pCursors);	}	// 'acur' Resource suchen	pCursors = (AcurHandle)GetResource('acur', resID);	if(!pCursors) {						// nicht gefunden!		FetchCursor(resID);				// => normalen Cursor (nicht animiert) nehmen		return;	}	HLock((Handle)pCursors);	(*pCursors)->numCursors &= 0x7FFF;	// Bit 15 (Farbe-Cursor nehmen) lšschen - entscheiden wir automatisch	(*pCursors)->numCursors *= 32;		// Timer-Index	(*pCursors)->index = 0;				// mit dem 1. Cursor anfangen	// ersten Cursor setzen	gCurrentCursor = -1;	SpinCursor(0);}void		SpinCursor(short increment){short	index;	if(!pCursors) return;				// kein animierter Cursor vorhanden => raus	// Wir erhšhen die Cursor-ID (alle 32 Schritte gibt es einen neuen Cursor, macht MPW auch so)	(*pCursors)->index += increment;	(*pCursors)->index %= (*pCursors)->numCursors;	// Take care of wraparound	index = (*pCursors)->index / 32;	// neuen Cursor setzen (fragt auch ab, ob der Cursor evtl. schon richtig gesetzt ist)	FetchCursor((*pCursors)->cursors[index].ID);}/*** *	Globales Rechteck in lokale Koordinaten umrechnen ***/void	GlobalToLocalRect(Rect *aRect){	GlobalToLocal(&TopLeft(*aRect));	GlobalToLocal(&BotRight(*aRect));}/*** *	Lokales Rechteck in globale Koordinaten umrechnen ***/void	LocalToGlobalRect(Rect *aRect){	LocalToGlobal(&TopLeft(*aRect));	LocalToGlobal(&BotRight(*aRect));}/*** *	Variables for the Command-period checker. ***/#define	kModifiersMask		0xFF00 & ~cmdKey	// We need all modifiers except the command key for KeyTrans()#define kOtherCharCodeMask	0x00FF0000			// Get the key out of the ASCII byte.static const char			kPeriod = '.';/*** *	Call an A/UX service routine. ***/#if defined(powerc) || defined(__powerc)#elsepascal long AUXDispatch(short select, void *arg) = 0xabf9;#endif/*** *	Diese Routine ŸberprŸft, ob der User Command-Punkt gedrŸckt hat. *	Command-Punkt bedeutet auf dem Mac: Funktion abbrechen. * *	Quelle: Macintosh Programming Secrets (Second Edition, p. 505) * *	Looks for a Command-period in the event queue. If we are running under the *	Mac OS, we find the head of the queue and walk the elements, looking for a *	keyDown event. This won't work under A/UX, which doesn't maintain a normal *	Mac OS event queue. When running under A/UX, we make a special call, *	asking A/UX to look through its private structures for a specific event *	for us. * *	Note that this routine returns false, if we are running in the background. *	This is because we don't want to stop whatevet we're doing if the user *	presses Command-period for the foreground application. ***/Boolean		AbortInQueue(void){#if defined(powerc) || defined(__powerc)#elseconst short	AUX_FIND_EVENT = 8;	struct {		EventRecord	mask;		EventRecord	value;	} eventFilter;#endif	EvQElPtr	queueEntryPtr;	Boolean		result;	result = false;	if(IsFrontProcess()) {#if defined(powerc) || defined(__powerc)#else		if(IsRunningUnderAUX()) {			// To get A/UX to look for a certain event, we fill out a			// specification and a mask. This is in the form of two			// EventRecords. The first one contains the values we want			// to look for. The second specifies the fields we want to			// search.					eventFilter.value.what = keyDown;			// Find a keyDown event			eventFilter.value.message = kPeriod;		// key = '.'			eventFilter.value.modifiers = cmdKey;		// with command key			eventFilter.mask.what = everyEvent;			eventFilter.mask.message = charCodeMask;			eventFilter.mask.modifiers = cmdKey;			eventFilter.mask.when = 0;			SetPt(&eventFilter.mask.where, 0, 0);			// We return that there is a Command-period on the queue			// if AUXDispatch returns a positive value AND			// it returns a non-nullEvent in eventFilter.					result = (AUXDispatch(AUX_FIND_EVENT, &eventFilter) > 0) &&						(eventFilter.value.what != nullEvent);		} else#endif		{			// Running under Mac OS, so walk the queue. The head is in			// the low-memory location returned by GetEvQHdr, and			// follows the normal OS queue conventions. For each entry			// in the queue, call "CmdPeriod" to test it.			queueEntryPtr = (EvQElPtr) GetEvQHdr()->qHead;			while (!result && (queueEntryPtr != nil)) {				result = CmdPeriod((EventRecord*) &queueEntryPtr->evtQWhat);				if (!result) {					queueEntryPtr = (EvQElPtr) queueEntryPtr->qLink;				}			}	// Scanning queue		}	// Running under Mac OS	}	// If front process	return result;}/*** *	Diese Routine ŸberprŸft, ob ein EventRecord ein Command-Punkt enthŠlt *	Command-Punkt bedeutet auf dem Mac: Funktion abbrechen. * *	Quelle: Macintosh Programming Secrets (Second Edition, p. 506) * *	Radical cool way to see if the event record represents a Command-period *	Keypress. Normally, you might wonder, What's the problem? All you have to *	do is check the modifiers field to see if the Command key is down, and *	check the message field to see what key was pressed. Well, the problem is *	that under some systems, holding down the Command key negates any effect *	the Shift key has. THis means that on system where the period is a *	shifted character, when you hold down the Command key, you won't be able *	to press period. * *	The way to fix this is to rerun the sequence of events involved in mapping *	a key code into an ASCII value, except that this time we don't factor the *	Command key into the equation. * *	The event record has everything we need. It has the modifier keys that *	were pressed at the time of the event, and it has the key code. What we do *	is take the modifiers, clear the bit that says the Command key was *	pressed, and pass the modified modifiers and the key code to KeyTrans. *	After that, we'll be able to examine the resulting ASCII value on its own *	merits. * *	From Harvey's Technical Note #263: International Canceling ***/Boolean		CmdPeriod(EventRecord *theEvent){Boolean		result;short		keyCode;long		virtualKey, keyInfo, lowChar, highChar, keyCID;UInt32		state;Handle		hKCHR;	result = false;	if ((theEvent->what == keyDown) || (theEvent->what == autoKey)) {		// See if the Command key is down. If it is, find out the ASCII		// equivalent for the accompanying key.		if ((theEvent->modifiers & cmdKey) != 0) {			virtualKey = (theEvent->message & keyCodeMask) >> 8;			// Mask out the Command key and merge in the virtualKey			keyCode = (theEvent->modifiers & kModifiersMask) | virtualKey;			state	= 0;			keyCID	= GetScriptVariable(GetScriptManagerVariable(smKeyScript), smScriptKeys);			hKCHR	= GetResource('KCHR', keyCID);			if (hKCHR != nil) {				keyInfo = KeyTranslate(*hKCHR, keyCode, &state);				ReleaseResource(hKCHR);			} else {				keyInfo = theEvent->message;			}			lowChar =  keyInfo & charCodeMask;			highChar = (keyInfo & kOtherCharCodeMask) >> 16;			if ((lowChar == kPeriod) || (highChar == kPeriod))				result = true;		}	// end the Command key is down	}	// end key down event	return result;}/*** *	Ist der aktuelle Prozess im Vordergrund? Besser als mit Suspend & Resume, aber erst ab System 7 * *	Quelle: Macintosh Programming Secrets (Second Edition, p. 508) ***/Boolean		IsFrontProcess(void){ProcessSerialNumber	aPSN;ProcessSerialNumber	currentPSN = { 0, kCurrentProcess };Boolean				result;	ThrowIfOSErr_(GetFrontProcess(&aPSN));	ThrowIfOSErr_(SameProcess(&aPSN, &currentPSN, &result));	return result;}/*** *	LŠuft der Rechner unter A/UX? * *	Quelle: Macintosh Programming Secrets (Second Edition, p. 508) * *	See if we are running under A/UX. We make this check in two ways. First, *	we call Gestalt to see what it says. If it knows about A/UX, we see if the *	version that was returned is non-zero (indicating that A/UX is running) or *	not. If Gestalt doesn't recognize the A/UX selector, then we check by *	hand by looking into low memory. Bit 9 of HWCfgFlags is set if A/UX is *	running (dann ist A/UX < Version 2 vorhanden) ***/Boolean		IsRunningUnderAUX(void){OSErr		err;long		response;	err = Gestalt(gestaltAUXVersion, &response);	if(err == noErr)		return response != 0L;	else		return (LMGetHWCfgFlags() & (1 << 9)) != 0;}/*** *	Kleinkram initialisieren ***/void	InitUtilities(void);void	InitUtilities(void){	gSystemVersion = GetGestaltResult(gestaltSystemVersion);	gQDVersion = (GetGestaltResult(gestaltQuickdrawVersion) >> 8) & 0xFF;	gDrapAndDrop = (GetGestaltResult(gestaltDragMgrAttr) & (1L<<gestaltDragMgrPresent)) == (1L<<gestaltDragMgrPresent);	gBalloonHelp = (GetGestaltResult(gestaltHelpMgrAttr) & (1L<<gestaltHelpMgrPresent)) == (1L<<gestaltHelpMgrPresent);	// Signatur ermitteln	ProcessSerialNumber	currentPSN;	ProcessInfoRec		info;	FSSpec				appSpec;	short				refNum;	info.processInfoLength = sizeof(ProcessInfoRec);	info.processName = gAppName;	info.processAppSpec = &appSpec;	if(GetCurrentProcess(&currentPSN) == noErr &&		GetProcessInformation(&currentPSN, &info) == noErr) {		gSignature = info.processSignature;		FSpOpenDF(&appSpec, fsRdPerm, &refNum);	// Programm-Datei šffnen (damit die CD nicht unmountet werden kann!)	}}/*** *	SetMinimumStack * *	Setzt die Stackgrš§e auf minSize. Nur EINMAL aufrufen und die als ALLERERSTEN *	Befehl im Programm! ***/void	SetMinimumStack(long minSize){register long	defaultStack = LMGetDefltStack();	if (minSize > defaultStack)		SetApplLimit(GetApplLimit() - (minSize - defaultStack));}/*** *	allgemeines Init ***/void	InitAll(void){	MaxApplZone();	for(int i = 0; i<20; i++)		MoreMasters();						// Platz fŸr ein paar Master-Pointer mehr	InitGraf(&qd.thePort);					// QuickDraw init	InitFonts();							// Font Manager init	InitWindows();							// Window Manager init	InitMenus();							// Menu Manager init	TEInit();								// Text Edit init	InitDialogs(nil);						// Dialog Manager Init	InitCursor();							// Cursor auf Pfeil schalten	InitUtilities();						// Kleinkram initialisieren	qd.randSeed = TickCount();				// Zufallsbasis setzen}