/*** *	Menüverwaltung * *	©1994 Dekotec Abt. Info-Sys, Markus Fritze ***/#include "MenuLib.h"#include "GeosErrors.h"#include "Utilities.h"#include "MCToolbar.h"#include <Menus.h>#include <ToolUtils.h>#include <Devices.h>short		gAppleId; 		// Menü-ID vom Apfel-Menüshort		**MBarIDs;		// MBAR-Resourcehandletypedef struct {	short	menu;	// Menü-ID	short	item;		// Menü-Punkt	long	cmd;	// dazugehöriger Befehl} MCmdStruct,*MCmdPtr,**MCmdHandle;MCmdHandle	AllMenu;static MenuHandle	ConvertToMenu(Handle CMNUHandle);static void			MenuAddCmd(short menu, short item, long cmd);static long			MenuId2Cmd(short menu, short item);static short		MenuCmd2Id(long cmd, short &item);/*** *	Befehl zu einem Menüpunkt merken ***/void		MenuAddCmd(short menu, short item, long cmd){	if(!AllMenu) {		AllMenu = (MCmdHandle)NewHandle(0);		ThrowIfMemError_();	}	long	offset = ::GetHandleSize((Handle)AllMenu);	ThrowIfMemError_();	::SetHandleSize((Handle)AllMenu, offset + sizeof(MCmdStruct));	ThrowIfMemError_();	MCmdPtr		mp = (MCmdPtr)((Ptr)*AllMenu + offset);	mp->menu = menu;	mp->item = item;	mp->cmd = cmd;}/*** *	Menü-Punkt in einen Befehl umrechnen (<=0 => kein passender Befehl) ***/long		MenuId2Cmd(short menu, short item){MCmdPtr		mp = *AllMenu;int			anz = ::GetHandleSize((Handle)AllMenu) / sizeof(MCmdStruct);	ThrowIfMemError_();	for( ; anz > 0; anz--, mp++) {		if(mp->menu != menu)			continue;		if(mp->item != item)			continue;		return mp->cmd;	}	return -(((long)menu << 16) | item);}/*** *	Befehl in einen Menü-Punkt umrechnen (=0 => kein passender Menüpunkt) ***/short		MenuCmd2Id(long cmd, short &item){MCmdPtr		mp = *AllMenu;int			anz = ::GetHandleSize((Handle)AllMenu) / sizeof(MCmdStruct);	ThrowIfMemError_();	for( ; anz > 0; anz--, mp++) {		if(mp->cmd != cmd)			continue;		item = mp->item;		return mp->menu;	}	return 0;}/*** *	CMNU-Resourcehandle in eine MenuHandle wandeln ***/static MenuHandle ConvertToMenu(Handle CMNUHandle){	MenuHandle theMenuHandle = nil;	Ptr theCMNUPtr;	short i;	short menuNo;	short itemNo;	long cmdNo;	Ptr endPtr;	::HLockHi(CMNUHandle);	theCMNUPtr = (Ptr)StripAddress(*CMNUHandle);	menuNo = *((short*)theCMNUPtr);				// Menü-Nummer	i = theCMNUPtr[14] + 15;					// Ptr hinter den Header (inkl. Menütitel)	theMenuHandle = (MenuHandle)::NewMenu(menuNo, 14 + (StringPtr)theCMNUPtr);	theCMNUPtr = (Ptr)(theCMNUPtr + i);			// Ptr auf die Menüeinträge	itemNo = 1;	endPtr = (Ptr)(theCMNUPtr + GetHandleSize(CMNUHandle));	// Ptr hinter das Menü	while((theCMNUPtr < endPtr) && (theCMNUPtr[0] != 0)) {		i = theCMNUPtr[0] + 5;					// Stringlänge + Längenbyte + 4 Byte Flags		MacAppendMenu(theMenuHandle, (StringPtr)theCMNUPtr);		SetMenuItemText(theMenuHandle, itemNo, (StringPtr)theCMNUPtr);		SetItemIcon(theMenuHandle, itemNo, theCMNUPtr[i - 4]);		SetItemCmd(theMenuHandle, itemNo, theCMNUPtr[i - 3]);		SetItemMark(theMenuHandle, itemNo, theCMNUPtr[i - 2]);		SetItemStyle(theMenuHandle, itemNo, theCMNUPtr[i - 1]);		theCMNUPtr = (Ptr)(theCMNUPtr + i);		if ((((long)theCMNUPtr) & 0x00000001) == 1)// auf gerade Bytes alignen			theCMNUPtr = (Ptr)(theCMNUPtr + 1);		cmdNo = *((long*)theCMNUPtr);			// Command-Nummer holen		theCMNUPtr = (Ptr) (theCMNUPtr + sizeof(long));	// Ptr auf den nächsten Eintrag		MenuAddCmd(menuNo, itemNo, cmdNo);		++itemNo;	}	::HUnlock(CMNUHandle);	return theMenuHandle;}/*** *	 ***/void		MenuBarInit(short MenuBarId){	MBarIDs = (short**)::GetResource('MBAR', MenuBarId);	// MBAR einlesen	ThrowIfNil_(MBarIDs);	::HLock((Handle)MBarIDs);	gAppleId = (*MBarIDs)[1];	// initialize all CMNUs with positive item	for(int i = 1; i <= **MBarIDs; ++i) {		Handle aCMNUHandle = ::GetResource('CMNU', (*MBarIDs)[i]);		ThrowIfNil_(aCMNUHandle);		// A little known fact about GetResInfo is that if you specify nil for any of the		// info parameters, then it won’t return that information.  Handy, huh?		short		menuResID;		::GetResInfo(aCMNUHandle, &menuResID, nil, nil);		short menuID = (*(MenuHandle)aCMNUHandle)->menuID;		if(((* (MenuHandle) aCMNUHandle)->menuID) > 0) {		// not in reserved range			MenuHandle	theMenu = ConvertToMenu(aCMNUHandle);			::InsertMenu(theMenu, 0);			::CalcMenuSize(theMenu);			for(int j = 1; j < CountMItems(theMenu); j++) {				if(MenuId2Cmd(menuID, j) == 0)					::DisableItem(theMenu, j);	// alle Menüpunkte disablen			}		}	}	// Apfel-Menü installieren	MenuHandle	m = ::GetMenuHandle(gAppleId);	// Handle des Apfel-Menüs	ThrowIfNil_(m);	::AppendResMenu(m,'DRVR');					// DAs anhängen	::DrawMenuBar();}/*** *	Menüpunkt enabled bzw. disabled? ***/static Boolean		GetMenuAble(MenuHandle m,short item);static Boolean		GetMenuAble(MenuHandle m,short item){	return(BTstBool((*m)->enableFlags,item));}#if 0/*** *	Mehrere Menüpunkte enablen bzw. disablen. * *	Format: *	m		= MenuHandle des Menüs *	item[]	= Liste der Menüpunkte *			0	= Ende *			<0	= Menüpunkt disablen *			>0	= Menüpunkt enablen ***/void		MenuAble(short menuid,char *item){short		i;MenuHandle	m = GetMenuHandle(menuid);	while((i = *item++) != 0) {			// alle Menüpunkte durch?		if (i < 0)			::DisableItem(m,-i);			// negativ => disablen		else			::EnableItem(m,i);			// positiv => enablen	}}#endif/*** *	Abtesten, ob ein bestimmter Befehl erlaubt ist ***/Boolean		IsCommand(long cmd, MenuBase *mc){	if(!AllMenu) return false;Boolean		enabled;short		markChar, oldMarkChar;Str255		itemString, oldString;short		whichItem;short		title = MenuCmd2Id(cmd, whichItem);	MenuHandle	theMenu = ::GetMenuHandle(title);	ThrowIfNil_(theMenu);	::GetMenuItemText(theMenu, whichItem, itemString);	CopyPString(oldString, itemString);	::GetItemMark(theMenu, whichItem, &markChar);	oldMarkChar = markChar;	// per Default: disablen	enabled = false;	// Status abfragen	// 1. Global	GetCommandStatus(cmd, enabled, markChar, itemString);	// 2. im obersten Fenster	if(mc)		mc->GetCommandStatus(cmd, enabled, markChar, itemString);	if(enabled != GetMenuAble(theMenu, whichItem)) {		if(enabled)			::EnableItem(theMenu, whichItem);		else			::DisableItem(theMenu, whichItem);	}	if(oldMarkChar != markChar)		::SetItemMark(theMenu, whichItem, markChar);	if(!ComparePString(oldString, itemString))		::SetMenuItemText(theMenu, whichItem, itemString);	return enabled;}/*** *	Menü anpassen ***/void		AdjustMenu(MenuBase *mc){	if(!AllMenu) return;	MCmdPtr	mp;	int		anz = ::GetHandleSize((Handle)AllMenu) / sizeof(MCmdStruct);	ThrowIfMemError_();	HLock((Handle)AllMenu);	for(mp = *AllMenu; anz > 0; anz--, mp++)		IsCommand(mp->cmd, mc);	HUnlock((Handle)AllMenu);	// So: hier klappern wir alle Menüs ab und disablen alle Menüs, deren Menüpunkte	// vollständig disabled sind. Die Menüleiste zeichnen wir nur neu, wenn es nötig ist.	// (das Apfel-Menü wird dabei nicht berücksichtig)	Boolean		redraw = false;	for(int i = 1; i <= **MBarIDs; i++) {	// alle Menüs abklappern		MenuHandle	theMenu = ::GetMenuHandle((*MBarIDs)[i]);		ThrowIfNil_(theMenu);		Boolean		enabled = false;		short		count = CountMItems(theMenu);		if(i == 1)			// nur den About im Apfel-Menü abtesten!			count = 1;		for(int whichItem = 1; whichItem <= count; whichItem++) {			if(!GetMenuAble(theMenu, whichItem))	// Item disabled?				continue;				// dann weitersuchen			enabled = true;				// ein enabletes Item gefunden			break;						// dann abbrechen		}		// Menüzeile komplett disablen bzw. wieder enablen		if(enabled != GetMenuAble(theMenu, 0)) {			if(enabled)				::EnableItem(theMenu, 0);			else				::DisableItem(theMenu, 0);			redraw = true;				// Redraw nötig!		}	}	if(redraw) {		::HiliteMenu(0);		DrawMenuBar();	}	// Toolbar ggf. updaten	if(WWToolbar)		WWToolbar->Update();}/*** *	Befehl ausführen ***/void		SendMenuCmd(long cmd, MenuBase *mc){	if(cmd < 0) {			} else {		// Toolbar ggf. aufblinken lassen		if(WWToolbar)			WWToolbar->Button(cmd);		Boolean	flag = false;		if(mc)			flag = mc->DoCommand(cmd);		if(!flag)					// Commando schon ausgewertet?			DoCommand(cmd);			// nein, dann global auswerten	}	::HiliteMenu(0);}/*** *	Menüpunkt auslösen ***/void		EventMenu(long m, MenuBase *mc){short		title = HiWord(m);short		item = LoWord(m);	if(!title || !item) return;			// nix angeklickt! => raus	if(!GetMenuAble(GetMenuHandle(title), item)) return;	// Menüpunkt disabled! => raus	if(title == gAppleId && item != 1) {// DA öffnen?		Str255		accName;		::GetMenuItemText(GetMenuHandle(gAppleId), item, accName);		::OpenDeskAcc(accName);			// DA öffnen		::HiliteMenu(0);	} else {		SendMenuCmd(MenuId2Cmd(title, item), mc);	}}