/*** *	JFIF->PICT Konverter * *	Dieser Source wandelt eine Handle mit JFIF-Daten mit Hilfe von QuickTime in eine PicHandle. Ferner gibt es *	eine Routine um die Größe eines JFIF-Bildes schnell (d.h. ohne das Bild zu entpacken) zu ermitteln. * *	Das JFIF-Format entspricht dem JPEG-Format, nur ist ein spezieller zusätzlicher Marker vorhanden, der die *	dpi Auflösung des Bildes enthält. Da wird aber stets mit 72dpi Bildern zu tun haben, ignoriere ich diese *	Informationen, d.h. dies ist weniger ein JFIF-Konverter, als ein JPEG-Konverter. Ich habe entsprechenden *	Code inzwischen auch rausgeworfen (hat diesen Source von >4kb Objektcode auf <1kb Code gebracht) * *	©1994 Dekotec Info-Sys, Markus Fritze - Teile sind von Mark Krueger, Apple Computer, Inc. ***/#include "GlobalDefines.h"#include <ImageCompression.h>#include <FixMath.h>void					JPEG2GrafPort(Handle data, Rect &iRect);Boolean					JFIFPictRect(Handle data, Rect &iRect);PicHandle				JPEG2PicHandle(Handle data);static Ptr						MarkerDetect(Handle dataHand, int &width, int &height);static ImageDescriptionHandle	ScanJPEG(Handle data, OpenCPicParams &pictureHeader);/*** *	Bildrechteck des JPEG-Bildes ermitteln - ohne Aufruf von FDecompressImage()!!! ***/Boolean					JFIFPictRect(Handle data, Rect &iRect){ImageDescriptionHandle	desc;OpenCPicParams			header;	// JPEG Header nach Infos über das Bild durchsuchen	desc = ScanJPEG(data, header);	if(!desc) return false;	iRect = header.srcRect;	DisposeHandle((Handle)desc);	return true;}/*** *	JPEG-Bild in den aktuellen Grafport ausgeben ***/void					JPEG2GrafPort(Handle data, Rect &iRect){OpenCPicParams			header;MatrixRecord			matrix;ImageDescriptionHandle	desc = nil;CGrafPtr				savePort;GDHandle				saveDev;	GetGWorld(&savePort, &saveDev);		// aktuellen Grafport ermitteln	try {		// Extract the JPEG data if possible and create Image Description.		desc = ScanJPEG(data, header);		// Default-Matrix setzen		SetIdentityMatrix(&matrix);		// und auf die richtige Größe skalieren		ScaleMatrix(&matrix, FixDiv(Long2Fix(iRect.right - iRect.left), Long2Fix(header.srcRect.right - header.srcRect.left)),							 FixDiv(Long2Fix(iRect.bottom - iRect.top), Long2Fix(header.srcRect.bottom - header.srcRect.top)),							Long2Fix(0), Long2Fix(0));		// Bild ins Zielrechteck verschieben		TranslateMatrix(&matrix, Long2Fix(iRect.left), Long2Fix(iRect.top));//		SkewMatrix(&matrix, Long2Fix(10), Long2Fix(10), Long2Fix(0), Long2Fix(0));//		RotateMatrix(&matrix, Long2Fix(90), Long2Fix(10), Long2Fix(10));		// FDecompressImage() ermöglicht das Wählen des schnellsten und besten JPEG Entpackers und erzielt zudem bessere		// Ergebnisse im 256 Farben Modus		//		// FDecompressImage() kostet beim Redraw >90% der Rechenzeit. Alle weiteren Optimierungen sind quasi witzlos,		// solange diese Routine derart viel Zeit kostet!		HLock(data);		RGBColor	saveFore, saveBack;		GetForeColor(&saveFore);		GetBackColor(&saveBack);		ForeColor(blackColor);		BackColor(whiteColor);		OSErr	iErr = FDecompressImage(StripAddress(*data), desc, savePort->portPixMap, &header.srcRect, &matrix, ditherCopy,										nil, nil, nil, codecMaxQuality, bestSpeedCodec, 0, nil,										(ICMProgressProcRecordPtr)-1L);		HUnlock(data);		RGBForeColor(&saveFore);		RGBBackColor(&saveBack);		if(iErr == -8967 || iErr == -8976)	// User hat “Abbruch” angeklickt?			iErr = noErr;				// keinen Fehler melden!		ThrowIfOSErr_(iErr);	}	catch(PP_PowerPlant::ExceptionCode inErr) {		// nix tun (Bild wird dann einfach nicht dargestellt)	} 	// alle überflüssigen Daten wieder freigeben	if(desc)		DisposeHandle((Handle)desc);}/*** *	JPEG-Bild in den aktuellen Grafport ausgeben ***/PicHandle				JPEG2PicHandle(Handle data){PicHandle				ph = 0L;OpenCPicParams			header;MatrixRecord			matrix;ImageDescriptionHandle	desc = nil;PicHandle				originalPicture = nil;GWorldPtr				offscreenGWorld = nil;CGrafPtr				savePort;GDHandle				saveDev;	GetGWorld(&savePort,&saveDev);	try {		// Extract the JPEG data if possible and create Image Description.		desc = ScanJPEG(data, header);		// Wir entpacken erstmal in eine Offscreen-Bitmap		ThrowIfOSErr_(NewGWorld(&offscreenGWorld, 0, &header.srcRect, 0L, 0L, useTempMem));		SetGWorld(offscreenGWorld, 0L);		LockPixels(GetGWorldPixMap(offscreenGWorld));		// und den ganzen Kram wollen wir in eine PicHandle bekommen - die wir später zurückgeben		originalPicture = OpenCPicture(&header);		ThrowIfNil_(originalPicture);		SetIdentityMatrix(&matrix);		HLock(data);		// FDecompressImage() ermöglicht das Wählen des schnellsten und besten JPEG Entpackers und erzielt zudem bessere		// Ergebnisse im 256 Farben Modus		//		// FDecompressImage() kostet beim Redraw >90% der Rechenzeit. Alle weiteren Optimierungen sind quasi witzlos,		// solange diese Routine derart viel Zeit kostet!		RGBColor	saveFore, saveBack;		GetForeColor(&saveFore);		GetBackColor(&saveBack);		ForeColor(blackColor);		BackColor(whiteColor);		OSErr	iErr = FDecompressImage(StripAddress(*data), desc, offscreenGWorld->portPixMap, &header.srcRect, &matrix, ditherCopy, (RgnHandle)nil,				(PixMapHandle)nil, (Rect *)nil, codecMaxQuality, bestSpeedCodec, 0, nil, nil);		RGBForeColor(&saveFore);		RGBBackColor(&saveBack);		ClosePicture();		ThrowIfOSErr_(iErr);		ThrowIf_(GetHandleSize((Handle)originalPicture) == sizeof(Picture));		// PicHandle im Rückgabecode merken und temp. Variable löschen, damit das Picture nicht wieder freigegeben wird		ph = originalPicture;		originalPicture = nil;	}	catch(PP_PowerPlant::ExceptionCode inErr) {		// nix tun (Bild wird dann einfach nicht dargestellt)	}	HUnlock(data);	// alle überflüssigen Daten wieder freigeben	if(originalPicture)		KillPicture(originalPicture);	if(offscreenGWorld)		DisposeGWorld(offscreenGWorld);	if(desc)		DisposeHandle((Handle)desc);	SetGWorld(savePort, saveDev);	return ph;}/*** *	Filedaten in der Handle nach JPEG Daten durchsuchen und einen Picture Header, sowie *	eine ImageDescription Handle erzeugen. ***/static ImageDescriptionHandle	ScanJPEG(Handle data, OpenCPicParams &pictureHeader){int						w, h;ImageDescriptionHandle	desc;ImageDescriptionPtr		desp;	desc = (ImageDescriptionHandle)NewHandleClear(sizeof(ImageDescription));	ThrowIfMemFail_(desc);	HLockHi((Handle)desc);	HLock(data);	if(MarkerDetect(data, w, h) == 0) {		HUnlock(data);		DisposeHandle((Handle)desc);		ThrowIf_(true);	}	HUnlock(data);	desp = (ImageDescriptionPtr)StripAddress((Ptr)*desc);	desp->idSize = sizeof(ImageDescription);	desp->width = w;				// Bildgröße	desp->height = h;	desp->temporalQuality = 0;	desp->spatialQuality = codecNormalQuality;	desp->dataSize = GetHandleSize(data);	desp->cType = 'jpeg';			// JPEG-Kompression	desp->version = 0;	desp->revisionLevel = 0;	desp->vendor = 0;	desp->hRes = Long2Fix(72);		// 72dpi	desp->vRes = desp->hRes;	desp->depth = 32;				// die Bildtiefe ist stets 32 Bit	desp->clutID = -1;	BlockMoveData("\pPhoto", desp->name, 6);	SetRect(&pictureHeader.srcRect, 0, 0, w, h);	pictureHeader.version = -2;	pictureHeader.reserved1 = 0;	pictureHeader.reserved2 = 0;	pictureHeader.hRes = desp->hRes;	pictureHeader.vRes = desp->vRes;	return desc;}/*** *	JPEG Stream nach einigen Markern durchsuchen um die Größe des Bildes und die Image-Daten *	zu finden. * *	Ein Returncode von "nil" zeigt an, daß die Daten fehlerhaft sind bzw. in einem unbekannten *	Format vorliegen. * *	Näheres über das JPEG Format in der C'7 5/94 (wenn ich mich nicht irre) bzw. in den *	entsprechenden Specs der ISO. ***/// JPEG Marker, die uns interessieren#define	MARKER_PREFIX	0xff#define	MARKER_SOF		0xc0		// start of frame#define	MARKER_SOS		0xda		// start of scanstatic Ptr				MarkerDetect(Handle dataHand, int &width, int &height){unsigned char	c;Ptr				data = StripAddress(*dataHand);Ptr				dataEnd = data + GetHandleSize(dataHand);	ThrowIfMemError_();	c = *data++;	while (c != (unsigned char)MARKER_SOS) {		while (c != (unsigned char)MARKER_PREFIX) {			c = *data++;						// looking for marker prefix bytes			if(data > dataEnd)				return nil;		}		while (c == (unsigned char)MARKER_PREFIX) {			c = *data++;						// (multiple?) marker prefix bytes			if(data > dataEnd)				return nil;		}		if (c == 0)			continue;							// 0 is never a marker code		switch(c) {		case MARKER_SOF:	// (Start of Frame) DCT-Basisprozeß (baseline) - Huffmann-Kodierung			data += 2;			if ( *data++ != 8 )				return nil;			height = *(short *)data;	// Bildhöhe in Pixeln			data += 2;			width = *(short *)data;		// Bildbreite in Pixeln			data += 2;			switch ( *data++  ) {			case 3:				data += 9;				break;			case 1:				data += 3;				break;			}			continue;		case MARKER_SOS:	// Dieses Segment enthält die komprimierten Bilddaten			return data;		case 0x01:			// diese Marker haben kein nachfolgendes Längenwort		case 0xd0: case 0xd1: case 0xd2: case 0xd3:		case 0xd4: case 0xd5: case 0xd6: case 0xd7:		case 0xd8: case 0xd9:			continue;		default:			data += *(short *)data;			continue;		}	}	return nil;}